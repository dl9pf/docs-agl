<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="José Bollo">
  <title>HOWTO WRITE a BINDING for AFB-DAEMON</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="doc.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">HOWTO WRITE a BINDING for AFB-DAEMON</h1>
<h2 class="author">José Bollo</h2>
<h3 class="date">27 juillet 2016</h3>
</header>
<nav id="TOC">
<ul>
<li><a href="#howto-write-a-binding-for-afb-daemon">HOWTO WRITE a BINDING for AFB-DAEMON</a><ul>
<li><a href="#summary">Summary</a><ul>
<li><a href="#nature-of-a-binding">Nature of a binding</a></li>
<li><a href="#class-of-bindings">Class of bindings</a></li>
<li><a href="#live-cycle-of-bindings-within-afb-daemon">Live cycle of bindings within afb-daemon</a></li>
<li><a href="#binding-contend">Binding Contend</a></li>
</ul></li>
<li><a href="#the-tic-tac-toe-example">The Tic-Tac-Toe example</a></li>
<li><a href="#dependencies-when-compiling">Dependencies when compiling</a></li>
<li><a href="#header-files-to-include">Header files to include</a></li>
<li><a href="#choosing-names">Choosing names</a><ul>
<li><a href="#names-for-api-binding">Names for API (binding)</a></li>
<li><a href="#names-for-methods">Names for methods</a></li>
<li><a href="#names-for-arguments">Names for arguments</a></li>
<li><a href="#forging-names-widely-available">Forging names widely available</a></li>
</ul></li>
<li><a href="#writing-a-synchronous-method-implementation">Writing a synchronous method implementation</a><ul>
<li><a href="#the-incoming-request">The incoming request</a></li>
<li><a href="#associating-a-client-context-to-a-session">Associating a client context to a session</a></li>
<li><a href="#sending-reply-to-a-request">Sending reply to a request</a></li>
</ul></li>
<li><a href="#getting-argument-of-invocation">Getting argument of invocation</a><ul>
<li><a href="#basic-functions-for-querying-arguments">Basic functions for querying arguments</a></li>
<li><a href="#arguments-for-received-files">Arguments for received files</a></li>
<li><a href="#arguments-as-a-json-object">Arguments as a JSON object</a></li>
</ul></li>
<li><a href="#initialisation-of-the-binding-and-declaration-of-methods">Initialisation of the binding and declaration of methods</a></li>
<li><a href="#sending-messages-to-the-log-system">Sending messages to the log system</a><ul>
<li><a href="#verbs-for-logging-messages">Verbs for logging messages</a></li>
<li><a href="#managing-verbosity">Managing verbosity</a></li>
<li><a href="#output-format-and-destination">Output format and destination</a></li>
</ul></li>
<li><a href="#sending-events">Sending events</a></li>
<li><a href="#writing-an-asynchronous-method-implementation">Writing an asynchronous method implementation</a></li>
<li><a href="#how-to-build-a-binding">How to build a binding</a><ul>
<li><a href="#example-for-cmake-meta-build-system">Example for cmake meta build system</a></li>
<li><a href="#exporting-the-function-afbbindingv1register">Exporting the function afbBindingV1Register</a></li>
<li><a href="#building-within-yocto">Building within yocto</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="howto-write-a-binding-for-afb-daemon">HOWTO WRITE a BINDING for AFB-DAEMON</h1>
<h2 id="summary">Summary</h2>
<p>Afb-daemon binders serve files through HTTP protocol and offers to developers the capability to expose application API methods through HTTP or WebSocket protocol.</p>
<p>Binder bindings are used to add API to afb-daemon. This part describes how to write a binding for afb-daemon.</p>
<p>Excepting this summary, this document target developers.</p>
<p>Before moving further through an example, here after a short overview of binder bindings fundamentals.</p>
<h3 id="nature-of-a-binding">Nature of a binding</h3>
<p>A binding is an independent piece of software. A binding is self contain and exposes application logic as sharable library. A binding is intended to be dynamically loaded by afb-daemon to expose application API.</p>
<p>Technically, a binder binding does not reference and is not linked with any afb-daemon library.</p>
<h3 id="class-of-bindings">Class of bindings</h3>
<p>Application binder supports two kinds of bindings: application bindings and service bindings. Technically both class of binding are equivalent are use the same coding convention. Only sharing mode and security context diverge.</p>
<h4 id="application-bindings">Application-bindings</h4>
<p>Application-bindings implements the glue in between application's UI and services. Every AGL application has a corresponding binder that typically activates one or many bindings to interface the application logic with lower platform services. When an application is started by the AGL application framework, a dedicate binder is started that loads/activates application binding(s). API expose by application-binding are executed within corresponding application security context.</p>
<p>Application bindings generally handle a unique context for a unique client. As the application framework start a dedicated instance of afb_daemon for each AGL application, if a given binding is used within multiple application each of those application get a new and private instance of eventually &quot;shared&quot; binding.</p>
<h4 id="service-bindings">Service-bindings</h4>
<p>Service-bindings enable API activation within corresponding service security context and not within calling application context. Service-bindings are intended to run as a unique instance. Service-bindings can be shared in between multiple clients.</p>
<p>Service-bindings can either be stateless or manage client context. When managing context each client get a private context.</p>
<p>Sharing may either be global to the platform (ie: GPS service) or dedicated to a given user (ie: user preferences)</p>
<h3 id="live-cycle-of-bindings-within-afb-daemon">Live cycle of bindings within afb-daemon</h3>
<p>Application and service bindings are loaded and activated each time a new afb-daemon is started.</p>
<p>At launch time, every loaded binding initialise itself. If a single binding initialisation fail corresponding instance of afb-daemon self aborts.</p>
<p>Conversely, when a binding initialisation succeeds, it should register its unique name as well as the list of verbs attached to the methods it exposes.</p>
<p>When initialised, on request from application clients to the right API/verb, binding methods are activated by the afb-daemon attached to the application or service.</p>
<p>At exit time, no special action is enforced by afb-daemon. When a specific actions is required at afb-daemon stop, developers should use 'atexit/on_exit' during binding initialisation sequence to register a custom exit function.</p>
<h3 id="binding-contend">Binding Contend</h3>
<p>Afb-daemon's binding register two classes of objects: names and functions.</p>
<p>Bindings declare categories of names: - A unique binding name to access all API expose by this binding, - One name for each methods/verbs provided by this binding.</p>
<p>Bindings declare two categories of functions: - function use for the initialisation - functions implementing exposed API methods</p>
<p>Afb-daemon parses URI requests to extract the API(binding name) and the VERB(method to activate). As an example, URI <strong>foo/bar</strong> translates to binding named <strong>foo</strong> and method named <strong>bar</strong>. To serve such a request, afb-daemon looks for an active binding named <strong>foo</strong> and then within this binding for a method named <strong>bar</strong>. When find afb-daemon calls corresponding method with attached parameter if any.</p>
<p>Afb-daemon ignores letter case when parsing URI. Thus <strong>TicTacToe/Board</strong> and <strong>tictactoe/board</strong> are equivalent.</p>
<h4 id="the-name-of-the-binding">The name of the binding</h4>
<p>The name of a given binding is also known as the name of the API prefix that defines the binding.</p>
<p>The name of a binding SHOULD be unique within a given afb-daemon instance.</p>
<p>For example, when a client of afb-daemon calls a URI named <strong>foo/bar</strong>. Afb-daemon extracts the prefix <strong>foo</strong> and the suffix <strong>bar</strong>. <strong>foo</strong> must match a binding name and <strong>bar</strong> a VERB attached to some method.</p>
<h4 id="names-of-methods">Names of methods</h4>
<p>Each binding exposes a set of methods that can be called by the clients of a given afb-daemon.</p>
<p>VERB's name attached to a given binding (API) MUST be unique within a binding.</p>
<p>Bindings static declaration link VERBS to corresponding methods. When clients emit requests on a given API/VERB corresponding method is called by afb-daemon.</p>
<h4 id="initialisation-function">Initialisation function</h4>
<p>Binding's initialisation function serves several purposes.</p>
<ol type="1">
<li><p>It allows afb-daemon to control binding version depending on initialisation function name. As today, the only supported initialisation function is <strong>afbBindingV1Register</strong>. This identifies version &quot;one&quot; of bindings.</p></li>
<li><p>It allows bindings to initialise itself.</p></li>
<li><p>It enables names declarations: descriptions, requirements and implementations of exposed API/VERB.</p></li>
</ol>
<h4 id="functions-instantiation-of-apiverbs">Functions instantiation of API/VERBs</h4>
<p>When an API/VERB is called, afb-daemon constructs a request object. Then it passes this request object to the implementation function corresponding to requested method, this within attached API binding.</p>
<p>An implementation function receives a request object that is used to: get arguments of the request, send answer, store session data.</p>
<p>A binding MUST set an answer to every received requests.</p>
<p>Nevertheless it is not mandatory to set the answer before returning from API/VERB implementing function. This behaviour is important for asynchronous actions.</p>
<p>API/VERB implementation that set an answer before returning are called <em>synchronous implementations</em>. Those that do not systematically set an answer before returning are called <em>asynchronous implementations</em>.</p>
<p>Asynchronous implementations typically launch asynchronous actions. They record some context at request time and provide answer to the request only at completion of asynchronous actions.</p>
<h2 id="the-tic-tac-toe-example">The Tic-Tac-Toe example</h2>
<p>This part explains how to write an afb-binding. For the sake of being practical it uses many examples based on tic-tac-toe. This binding example is in <em>bindings/samples/tic-tac-toe.c</em>.</p>
<p>This binding is named <strong><em>tictactoe</em></strong>.</p>
<h2 id="dependencies-when-compiling">Dependencies when compiling</h2>
<p>Afb-daemon provides a configuration file for <em>pkg-config</em>. Typing the command</p>
<pre><code>pkg-config --cflags afb-daemon</code></pre>
<p>Print flags use for compilation:</p>
<pre><code>$ pkg-config --cflags afb-daemon
-I/opt/local/include -I/usr/include/json-c </code></pre>
<p>For linking, you should use</p>
<pre><code>$ pkg-config --libs afb-daemon
-ljson-c</code></pre>
<p>Afb-daemon automatically includes dependency to json-c. This is activated through <strong>Requires</strong> keyword in pkg-config. While almost every binding replies on <strong>json-c</strong> this is not a must have dependency.</p>
<p>Internally, afb-daemon relies on <strong>libsystemd</strong> for its event loop, as well as for its binding to D-Bus. Bindings developers are encouraged to leverage <strong>libsystemd</strong> when possible. Nevertheless there is no hard dependency to <strong>libsystemd</strong> if ever you rather not use it, feel free to do so.</p>
<blockquote>
<p>Afb-daemon binding are fully self contain. They do not enforce dependency on any libraries from the application framework. Afb-daemon dependencies requirer to run AGL bindings are given at runtime through pointers leveraging read-only memory feature.</p>
</blockquote>
<h2 id="header-files-to-include">Header files to include</h2>
<p>Binding <em>tictactoe</em> has following includes:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define _GNU_SOURCE</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;json-c/json.h&gt;</span>
<span class="ot">#include &lt;afb/afb-binding.h&gt;</span></code></pre></div>
<p>Header <em>afb/afb-binding.h</em> is the only hard dependency, it includes all features that a binding MUST HAVE. Outside of includes used to support application logic, common external headers used within bindings are:</p>
<ul>
<li><em>json-c/json.h</em>: should be include to handle json objects;</li>
<li><em>systemd/sd-event.h</em>: should be include to access event main loop;</li>
<li><em>systemd/sd-bus.h</em>: should be include for dbus connections.</li>
</ul>
<p>The <em>tictactoe</em> binding does not leverage systemd features, also only json.h is used on top of mandatory afb/afb-binding.h.</p>
<p>When including <em>afb/afb-binding.h</em>, the macro **_GNU_SOURCE** MUST be defined.</p>
<h2 id="choosing-names">Choosing names</h2>
<p>Designers of bindings should define a unique name for every API binding as well as for methods VERBs. They should also define names for request arguments passed as name/value pair in URI.</p>
<p>While forging names, designers should respect few rules to ensure that created names are valid and easy to use across platforms.</p>
<p>All names and strings are UTF-8 encoded.</p>
<h3 id="names-for-api-binding">Names for API (binding)</h3>
<p>Binding API name are checked. All characters are authorised except:</p>
<ul>
<li>the control characters (000 .. 01f)</li>
<li>the characters of the set { ' ', '&quot;', '#', '%', '&amp;', ''', '/', '?', '`', '7f' }</li>
</ul>
<p>In other words the set of forbidden characters is { 000..020, 022, 023, 025..027, 02f, 03f, 060, 07f }.</p>
<p>Afb-daemon makes no distinction between lower case and upper case when searching for API/VERB.</p>
<h3 id="names-for-methods">Names for methods</h3>
<p>The names of methods VERBs are totally free and not checked.</p>
<p>However, the validity rules for method's VERB name are the same as for Binding API name except that the dot(.) character is forbidden.</p>
<p>Afb-daemon makes no case distinction when searching for an API by name.</p>
<h3 id="names-for-arguments">Names for arguments</h3>
<p>Argument's name are not restricted and can be everything you wish.</p>
<blockquote>
<p>Warning arguments search is case sensitive and &quot;index&quot; and &quot;Index&quot; are not two different arguments.</p>
</blockquote>
<h3 id="forging-names-widely-available">Forging names widely available</h3>
<p>The key names of javascript object can be almost anything using the arrayed notation:</p>
<pre><code>object[key] = value</code></pre>
<p>Nevertheless this is not the case with javascript dot notation:</p>
<pre><code>object.key = value</code></pre>
<p>Using the dot notation, the key must be a valid javascript identifier and dash(-) as well as few other reserved characters cannot be used.</p>
<p>For this reason, we advise developper to chose name compatible with both javascript and HTML notation.</p>
<p>It is a good practice, even for arguments not to rely on case sensitivity. This may reduce headache strength at debug time, especially with interpreted language like javascript that may not warn you that a variable was not defined.</p>
<h2 id="writing-a-synchronous-method-implementation">Writing a synchronous method implementation</h2>
<p>The method <strong>tictactoe/board</strong> is a synchronous implementation. Here is its listing:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * get the board</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="dt">void</span> board(<span class="kw">struct</span> afb_req req)
{
    <span class="kw">struct</span> board *board;
    <span class="kw">struct</span> json_object *description;

    <span class="co">/* retrieves the context for the session */</span>
    board = board_of_req(req);
    INFO(afbitf, <span class="st">&quot;method &#39;board&#39; called for boardid %d&quot;</span>, board-&gt;id);

    <span class="co">/* describe the board */</span>
    description = describe(board);

    <span class="co">/* send the board&#39;s description */</span>
    afb_req_success(req, description, NULL);
}</code></pre></div>
<p>This example shows many aspects of a synchronous method implementation. Let summarise it:</p>
<ol type="1">
<li><p>The function <strong>board_of_req</strong> retrieves the context stored for the binding: the board.</p></li>
<li><p>The macro <strong>INFO</strong> sends a message of kind <em>INFO</em> to the logging system. The global variable named <strong>afbitf</strong> used represents the interface to afb-daemon.</p></li>
<li><p>The function <strong>describe</strong> creates a json_object representing the board.</p></li>
<li><p>The function <strong>afb_req_success</strong> sends the reply, attaching to it the object <em>description</em>.</p></li>
</ol>
<h3 id="the-incoming-request">The incoming request</h3>
<p>For any implementation, the request is received by a structure of type <strong>struct afb_req</strong>.</p>
<blockquote>
<p>Note that this is a PLAIN structure, not a pointer to a structure.</p>
</blockquote>
<p>The definition of <strong>struct afb_req</strong> is:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Describes the request by bindings from afb-daemon</span>
<span class="co"> */</span>
<span class="kw">struct</span> afb_req {
    <span class="dt">const</span> <span class="kw">struct</span> afb_req_itf *itf;  <span class="co">/* the interfacing functions */</span>
    <span class="dt">void</span> *closure;          <span class="co">/* the closure for functions */</span>
};</code></pre></div>
<p>It contains two pointers: first one <em>itf</em>, points to functions used to handle internal request. Second one <em>closure</em> point onto function closure.</p>
<blockquote>
<p>The structure must never be used directly. Instead developer should use the intended functions provided by afb-daemon as described here after.</p>
</blockquote>
<p><em>req</em> is used to get arguments of the request, to send answer, to store session data.</p>
<p>This object and its interface is defined and documented in the file names <em>afb/afb-req-itf.h</em></p>
<p>The above example uses twice <em>req</em> object request.</p>
<p>The first time, to retrieve the board attached to the session of the request.</p>
<p>The second time, to send the reply: an object that describes the current board.</p>
<h3 id="associating-a-client-context-to-a-session">Associating a client context to a session</h3>
<p>When <em>tic-tac-toe</em> binding receives a request, it musts get the board describing the game associated to the session.</p>
<p>For a binding, having data associated to a session is common. This data is called &quot;binding context&quot; for the session. Within <em>tic-tac-toe</em> binding the context is the board.</p>
<p>Requests <em>afb_req</em> offer four functions for storing and retrieving session associated context.</p>
<p>These functions are:</p>
<ul>
<li><p><strong>afb_req_context_get</strong>: retrieves context data stored for current binding.</p></li>
<li><p><strong>afb_req_context_set</strong>: store context data of current binding.</p></li>
<li><p><strong>afb_req_context</strong>: if exist retrieves context data of current binding. if context does not yet exist, creates a new context and store it.</p></li>
<li><p><strong>afb_req_context_clear</strong>: reset the stored context data.</p></li>
</ul>
<p>The binding <em>tictactoe</em> use a convenient function to retrieve its context: the board. This function is <em>board_of_req</em>:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * retrieves the board of the request</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="kw">inline</span> <span class="kw">struct</span> board *board_of_req(<span class="kw">struct</span> afb_req req)
{
    <span class="kw">return</span> afb_req_context(req, (<span class="dt">void</span>*)get_new_board, (<span class="dt">void</span>*)release_board);
}</code></pre></div>
<p>The function <strong>afb_req_context</strong> ensures an existing context for the session of the request. Its two last arguments are functions to allocate and free context. Note function type casts to avoid compilation warnings.</p>
<p>Here is the definition of the function <strong>afb_req_context</strong></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Gets the pointer stored by the binding for the session of &#39;req&#39;.</span>
<span class="co"> * If the stored pointer is NULL, indicating that no pointer was</span>
<span class="co"> * already stored, afb_req_context creates a new context by calling</span>
<span class="co"> * the function &#39;create_context&#39; and stores it with the freeing function</span>
<span class="co"> * &#39;free_context&#39;.</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> *afb_req_context(<span class="kw">struct</span> afb_req req, <span class="dt">void</span> *(*create_context)(), <span class="dt">void</span> (*free_context)(<span class="dt">void</span>*))
{
    <span class="dt">void</span> *result = afb_req_context_get(req);
    <span class="kw">if</span> (result == NULL) {
        result = create_context();
        afb_req_context_set(req, result, free_context);
    }
    <span class="kw">return</span> result;
}</code></pre></div>
<p>The second argument if the function that creates the context. For binding <em>tic-tac-toe</em> (function <strong>get_new_board</strong>). The function <strong>get_new_board</strong> creates a new board and set usage its count to 1. The boards are checking usage count to free resources when not used.</p>
<p>The third argument is a function that frees context resources. For binding <em>tic-tac-toe</em> (function <strong>release_board</strong>). The function <strong>release_board</strong> decrease usage count of the board passed in argument. When usage count falls to zero, data board are freed.</p>
<p>Definition of other functions dealing with contexts:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Gets the pointer stored by the binding for the session of &#39;req&#39;.</span>
<span class="co"> * When the binding has not yet recorded a pointer, NULL is returned.</span>
<span class="co"> */</span>
<span class="dt">void</span> *afb_req_context_get(<span class="kw">struct</span> afb_req req);

<span class="co">/*</span>
<span class="co"> * Stores for the binding the pointer &#39;context&#39; to the session of &#39;req&#39;.</span>
<span class="co"> * The function &#39;free_context&#39; will be called when the session is closed</span>
<span class="co"> * or if binding stores an other pointer.</span>
<span class="co"> */</span>
<span class="dt">void</span> afb_req_context_set(<span class="kw">struct</span> afb_req req, <span class="dt">void</span> *context, <span class="dt">void</span> (*free_context)(<span class="dt">void</span>*));

<span class="co">/*</span>
<span class="co"> * Frees the pointer stored by the binding for the session of &#39;req&#39;</span>
<span class="co"> * and sets it to NULL.</span>
<span class="co"> *</span>
<span class="co"> * Shortcut for: afb_req_context_set(req, NULL, NULL)</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> afb_req_context_clear(<span class="kw">struct</span> afb_req req)
{
    afb_req_context_set(req, NULL, NULL);
}</code></pre></div>
<h3 id="sending-reply-to-a-request">Sending reply to a request</h3>
<p>Two kinds of replies: successful or failure.</p>
<blockquote>
<p>Sending a reply to a request MUST be done once and only once.</p>
</blockquote>
<p>It exists two functions for &quot;success&quot; replies: <strong>afb_req_success</strong> and <strong>afb_req_success_f</strong>.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Sends a reply of kind success to the request &#39;req&#39;.</span>
<span class="co"> * The status of the reply is automatically set to &quot;success&quot;.</span>
<span class="co"> * Its send the object &#39;obj&#39; (can be NULL) with an</span>
<span class="co"> * informationnal comment &#39;info (can also be NULL).</span>
<span class="co"> *</span>
<span class="co"> * For convenience, the function calls &#39;json_object_put&#39; for &#39;obj&#39;.</span>
<span class="co"> * Thus, in the case where &#39;obj&#39; should remain available after</span>
<span class="co"> * the function returns, the function &#39;json_object_get&#39; shall be used.</span>
<span class="co"> */</span>
<span class="dt">void</span> afb_req_success(<span class="kw">struct</span> afb_req req, <span class="kw">struct</span> json_object *obj, <span class="dt">const</span> <span class="dt">char</span> *info);

<span class="co">/*</span>
<span class="co"> * Same as &#39;afb_req_success&#39; but the &#39;info&#39; is a formatting</span>
<span class="co"> * string followed by arguments.</span>
<span class="co"> *</span>
<span class="co"> * For convenience, the function calls &#39;json_object_put&#39; for &#39;obj&#39;.</span>
<span class="co"> * Thus, in the case where &#39;obj&#39; should remain available after</span>
<span class="co"> * the function returns, the function &#39;json_object_get&#39; shall be used.</span>
<span class="co"> */</span>
<span class="dt">void</span> afb_req_success_f(<span class="kw">struct</span> afb_req req, <span class="kw">struct</span> json_object *obj, <span class="dt">const</span> <span class="dt">char</span> *info, ...);</code></pre></div>
<p>It exists two functions for &quot;failure&quot; replies: <strong>afb_req_fail</strong> and <strong>afb_req_fail_f</strong>.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Sends a reply of kind failure to the request &#39;req&#39;.</span>
<span class="co"> * The status of the reply is set to &#39;status&#39; and an</span>
<span class="co"> * informational comment &#39;info&#39; (can also be NULL) can be added.</span>
<span class="co"> *</span>
<span class="co"> * Note that calling afb_req_fail(&quot;success&quot;, info) is equivalent</span>
<span class="co"> * to call afb_req_success(NULL, info). Thus even if possible it</span>
<span class="co"> * is strongly recommended to NEVER use &quot;success&quot; for status.</span>
<span class="co"> *</span>
<span class="co"> * For convenience, the function calls &#39;json_object_put&#39; for &#39;obj&#39;.</span>
<span class="co"> * Thus, in the case where &#39;obj&#39; should remain available after</span>
<span class="co"> * the function returns, the function &#39;json_object_get&#39; shall be used.</span>
<span class="co"> */</span>
<span class="dt">void</span> afb_req_fail(<span class="kw">struct</span> afb_req req, <span class="dt">const</span> <span class="dt">char</span> *status, <span class="dt">const</span> <span class="dt">char</span> *info);

<span class="co">/*</span>
<span class="co"> * Same as &#39;afb_req_fail&#39; but the &#39;info&#39; is a formatting</span>
<span class="co"> * string followed by arguments.</span>
<span class="co"> *</span>
<span class="co"> * For convenience, the function calls &#39;json_object_put&#39; for &#39;obj&#39;.</span>
<span class="co"> * Thus, in the case where &#39;obj&#39; should remain available after</span>
<span class="co"> * the function returns, the function &#39;json_object_get&#39; shall be used.</span>
<span class="co"> */</span>
<span class="dt">void</span> afb_req_fail_f(<span class="kw">struct</span> afb_req req, <span class="dt">const</span> <span class="dt">char</span> *status, <span class="dt">const</span> <span class="dt">char</span> *info, ...);</code></pre></div>
<blockquote>
<p>For convenience, these functions automatically call <strong>json_object_put</strong> to release <strong>obj</strong>. Because <strong>obj</strong> usage count is null after being passed to a reply function, it SHOULD not be used anymore. If exceptionally <strong>obj</strong> needs to remain usable after reply function then using <strong>json_object_get</strong> on <strong>obj</strong> to increase usage count and cancels the effect the <strong>json_object_put</strong> is possible.</p>
</blockquote>
<h2 id="getting-argument-of-invocation">Getting argument of invocation</h2>
<p>Many methods expect arguments. Afb-daemon's bindings retrieve arguments by name and not by position.</p>
<p>Arguments are passed by requests through either HTTP or WebSockets.</p>
<p>For example, the method <strong>join</strong> of binding <strong>tic-tac-toe</strong> expects one argument: the <em>boardid</em> to join. Here is an extract:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Join a board</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="dt">void</span> join(<span class="kw">struct</span> afb_req req)
{
    <span class="kw">struct</span> board *board, *new_board;
    <span class="dt">const</span> <span class="dt">char</span> *id;

    <span class="co">/* retrieves the context for the session */</span>
    board = board_of_req(req);
    INFO(afbitf, <span class="st">&quot;method &#39;join&#39; called for boardid %d&quot;</span>, board-&gt;id);

    <span class="co">/* retrieves the argument */</span>
    id = afb_req_value(req, <span class="st">&quot;boardid&quot;</span>);
    <span class="kw">if</span> (id == NULL)
        <span class="kw">goto</span> bad_request;
    ...</code></pre></div>
<p>The function <strong>afb_req_value</strong> searches in the request <em>req</em> for argument name passed in the second argument. When argument name is not passed, <strong>afb_req_value</strong> returns NULL.</p>
<blockquote>
<p>The search is case sensitive and <em>boardid</em> is not equivalent to <em>BoardId</em>. Nevertheless having argument names that only differ by name case is not a good idea.</p>
</blockquote>
<h3 id="basic-functions-for-querying-arguments">Basic functions for querying arguments</h3>
<p>The function <strong>afb_req_value</strong> is defined here after:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Gets from the request &#39;req&#39; the string value of the argument of &#39;name&#39;.</span>
<span class="co"> * Returns NULL if when there is no argument of &#39;name&#39;.</span>
<span class="co"> * Returns the value of the argument of &#39;name&#39; otherwise.</span>
<span class="co"> *</span>
<span class="co"> * Shortcut for: afb_req_get(req, name).value</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">const</span> <span class="dt">char</span> *afb_req_value(<span class="kw">struct</span> afb_req req, <span class="dt">const</span> <span class="dt">char</span> *name)
{
    <span class="kw">return</span> afb_req_get(req, name).value;
}</code></pre></div>
<p>It is defined as a shortcut to call the function <strong>afb_req_get</strong>. That function is defined here after:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Gets from the request &#39;req&#39; the argument of &#39;name&#39;.</span>
<span class="co"> * Returns a PLAIN structure of type &#39;struct afb_arg&#39;.</span>
<span class="co"> * When the argument of &#39;name&#39; is not found, all fields of result are set to NULL.</span>
<span class="co"> * When the argument of &#39;name&#39; is found, the fields are filled,</span>
<span class="co"> * in particular, the field &#39;result.name&#39; is set to &#39;name&#39;.</span>
<span class="co"> *</span>
<span class="co"> * There is a special name value: the empty string.</span>
<span class="co"> * The argument of name &quot;&quot; is defined only if the request was made using</span>
<span class="co"> * an HTTP POST of Content-Type &quot;application/json&quot;. In that case, the</span>
<span class="co"> * argument of name &quot;&quot; receives the value of the body of the HTTP request.</span>
<span class="co"> */</span>
<span class="kw">struct</span> afb_arg afb_req_get(<span class="kw">struct</span> afb_req req, <span class="dt">const</span> <span class="dt">char</span> *name);</code></pre></div>
<p>That function takes 2 parameters: the request and the name of the argument to retrieve. It returns a PLAIN structure of type <strong>struct afb_arg</strong>.</p>
<p>There is a special name that is defined when the request is of type HTTP/POST with a Content-Type being application/json. This name is <strong>&quot;&quot;</strong> (the empty string). In that case, the value of this argument of empty name is the string received as a body of the post and is supposed to be a JSON string.</p>
<p>The definition of <strong>struct afb_arg</strong> is:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Describes an argument (or parameter) of a request</span>
<span class="co"> */</span>
<span class="kw">struct</span> afb_arg {
    <span class="dt">const</span> <span class="dt">char</span> *name;   <span class="co">/* name of the argument or NULL if invalid */</span>
    <span class="dt">const</span> <span class="dt">char</span> *value;  <span class="co">/* string representation of the value of the argument */</span>
                <span class="co">/* original filename of the argument if path != NULL */</span>
    <span class="dt">const</span> <span class="dt">char</span> *path;   <span class="co">/* if not NULL, path of the received file for the argument */</span>
                <span class="co">/* when the request is finalized this file is removed */</span>
};</code></pre></div>
<p>The structure returns the data arguments that are known for the request. This data include a field named <strong>path</strong>. This <strong>path</strong> can be accessed using the function <strong>afb_req_path</strong> defined here after:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Gets from the request &#39;req&#39; the path for file attached to the argument of &#39;name&#39;.</span>
<span class="co"> * Returns NULL if when there is no argument of &#39;name&#39; or when there is no file.</span>
<span class="co"> * Returns the path of the argument of &#39;name&#39; otherwise.</span>
<span class="co"> *</span>
<span class="co"> * Shortcut for: afb_req_get(req, name).path</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">const</span> <span class="dt">char</span> *afb_req_path(<span class="kw">struct</span> afb_req req, <span class="dt">const</span> <span class="dt">char</span> *name)
{
    <span class="kw">return</span> afb_req_get(req, name).path;
}</code></pre></div>
<p>The path is only defined for HTTP/POST requests that send file.</p>
<h3 id="arguments-for-received-files">Arguments for received files</h3>
<p>As it is explained above, clients can send files using HTTP/POST requests.</p>
<p>Received files are attached to &quot;file&quot; argument name. For example, the following HTTP fragment (from test/sample-post.html) will send an HTTP/POST request to the method <strong>post/upload-image</strong> with 2 arguments named <em>file</em> and <em>hidden</em>.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h2&gt;</span>Sample Post File<span class="kw">&lt;/h2&gt;</span>
<span class="kw">&lt;form</span><span class="ot"> enctype=</span><span class="st">&quot;multipart/form-data&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;file&quot;</span><span class="ot"> name=</span><span class="st">&quot;file&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;hidden&quot;</span><span class="ot"> name=</span><span class="st">&quot;hidden&quot;</span><span class="ot"> value=</span><span class="st">&quot;bollobollo&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;br&gt;</span>
    <span class="kw">&lt;button</span><span class="ot"> formmethod=</span><span class="st">&quot;POST&quot;</span><span class="ot"> formaction=</span><span class="st">&quot;api/post/upload-image&quot;</span><span class="kw">&gt;</span>Post File<span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/form&gt;</span></code></pre></div>
<p>Argument named <strong>file</strong> should have both its value and path defined.</p>
<p>The value is the name of the file as it was set by the HTTP client. Generally it is the filename on client side.</p>
<p>The path is the effective path of saved file on the temporary local storage area of the application. This is a randomly generated and unique filename. It is not linked with the original filename as used on client side.</p>
<p>After success the binding can use the uploaded file directly from local storage path with no restriction: read, write, remove, copy, rename... Nevertheless when request reply is set and query terminated, the uploaded temporary file at path is destroyed.</p>
<h3 id="arguments-as-a-json-object">Arguments as a JSON object</h3>
<p>Bindings may also request every arguments of a given call as one single object. This feature is provided by the function <strong>afb_req_json</strong> defined here after:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Gets from the request &#39;req&#39; the json object hashing the arguments.</span>
<span class="co"> * The returned object must not be released using &#39;json_object_put&#39;.</span>
<span class="co"> */</span>
<span class="kw">struct</span> json_object *afb_req_json(<span class="kw">struct</span> afb_req req);</code></pre></div>
<p>It returns a json object. This object depends on how the request was built:</p>
<ul>
<li><p>For HTTP requests, this json object uses key names mapped on argument name. Values are either string for common arguments or object ie: { &quot;file&quot;: &quot;...&quot;, &quot;path&quot;: &quot;...&quot; }</p></li>
<li><p>For WebSockets requests, returned directly the object as provided by the client.</p></li>
</ul>
<blockquote>
<p>In fact, for Websockets requests, the function <strong>afb_req_value</strong> can be seen as a shortcut to <strong><em>json_object_get_string(json_object_object_get(afb_req_json(req), name))</em></strong></p>
</blockquote>
<h2 id="initialisation-of-the-binding-and-declaration-of-methods">Initialisation of the binding and declaration of methods</h2>
<p>To be active, binding's methods should be declared to afb-daemon. Furthermore, the binding itself must be recorded.</p>
<p>The registration mechanism is very basic: when afb-need starts, it loads all bindings listed in: command line or configuration file.</p>
<p>Loading a binding follows the following steps:</p>
<ol type="1">
<li><p>Afb-daemon loads the binding with <em>dlopen</em>.</p></li>
<li><p>Afb-daemon searches for a symbol named <strong>afbBindingV1Register</strong> using <em>dlsym</em>. This symbol is assumed to be the exported initialisation function of the binding.</p></li>
<li><p>Afb-daemon builds an interface object for the binding.</p></li>
<li><p>Afb-daemon calls the found function <strong>afbBindingV1Register</strong> with interface pointer as parameter.</p></li>
<li><p>Function <strong>afbBindingV1Register</strong> setups the binding and initialises it.</p></li>
<li><p>Function <strong>afbBindingV1Register</strong> returns the pointer to a structure describing the binding: version, name (prefix or API name), and list of methods.</p></li>
<li><p>Afb-daemon checks that the returned version and name can be managed. If so, binding and its methods are register to become usable as soon as afb-daemon initialisation is finished.</p></li>
</ol>
<p>Here after the code used for <strong>afbBindingV1Register</strong> from binding <em>tic-tac-toe</em>:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * activation function for registering the binding called by afb-daemon</span>
<span class="co"> */</span>
<span class="dt">const</span> <span class="kw">struct</span> afb_binding *afbBindingV1Register(<span class="dt">const</span> <span class="kw">struct</span> afb_binding_interface *itf)
{
   afbitf = itf;         <span class="co">// records the interface for accessing afb-daemon</span>
   <span class="kw">return</span> &amp;binding_description;  <span class="co">// returns the description of the binding</span>
}</code></pre></div>
<p>It is a very minimal initialisation function because <em>tic-tac-toe</em> binding doesn't have any application related initialisation step. It merely record daemon's interface and returns its description.</p>
<p>The variable <strong>afbitf</strong> is a binding global variable. It keeps the interface to afb-daemon that should be used for logging and pushing events. Here is its declaration:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * the interface to afb-daemon</span>
<span class="co"> */</span>
<span class="dt">const</span> <span class="kw">struct</span> afb_binding_interface *afbitf;</code></pre></div>
<p>The description of the binding is defined here after.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * array of the methods exported to afb-daemon</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="dt">const</span> <span class="kw">struct</span> afb_verb_desc_v1 binding_methods[] = {
   <span class="co">/* VERB&#39;S NAME     SESSION MANAGEMENT          FUNCTION TO CALL  SHORT DESCRIPTION */</span>
   { .name= <span class="st">&quot;new&quot;</span>,   .session= AFB_SESSION_NONE, .callback= new,   .info= <span class="st">&quot;Starts a new game&quot;</span> },
   { .name= <span class="st">&quot;play&quot;</span>,  .session= AFB_SESSION_NONE, .callback= play,  .info= <span class="st">&quot;Asks the server to play&quot;</span> },
   { .name= <span class="st">&quot;move&quot;</span>,  .session= AFB_SESSION_NONE, .callback= move,  .info= <span class="st">&quot;Tells the client move&quot;</span> },
   { .name= <span class="st">&quot;board&quot;</span>, .session= AFB_SESSION_NONE, .callback= board, .info= <span class="st">&quot;Get the current board&quot;</span> },
   { .name= <span class="st">&quot;level&quot;</span>, .session= AFB_SESSION_NONE, .callback= level, .info= <span class="st">&quot;Set the server level&quot;</span> },
   { .name= <span class="st">&quot;join&quot;</span>,  .session= AFB_SESSION_CHECK,.callback= join,  .info= <span class="st">&quot;Join a board&quot;</span> },
   { .name= <span class="st">&quot;undo&quot;</span>,  .session= AFB_SESSION_NONE, .callback= undo,  .info= <span class="st">&quot;Undo the last move&quot;</span> },
   { .name= <span class="st">&quot;wait&quot;</span>,  .session= AFB_SESSION_NONE, .callback= wait,  .info= <span class="st">&quot;Wait for a change&quot;</span> },
   { .name= NULL } <span class="co">/* marker for end of the array */</span>
};

<span class="co">/*</span>
<span class="co"> * description of the binding for afb-daemon</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="dt">const</span> <span class="kw">struct</span> afb_binding binding_description =
{
   <span class="co">/* description conforms to VERSION 1 */</span>
   .type= AFB_BINDING_VERSION_1,
   .v1= {               <span class="co">/* fills the v1 field of the union when AFB_BINDING_VERSION_1 */</span>
      .prefix= <span class="st">&quot;tictactoe&quot;</span>,     <span class="co">/* the API name (or binding name or prefix) */</span>
      .info= <span class="st">&quot;Sample tac-tac-toe game&quot;</span>, <span class="co">/* short description of of the binding */</span>
      .methods = binding_methods        <span class="co">/* the array describing the methods of the API */</span>
   }
};</code></pre></div>
<p>The structure <strong>binding_description</strong> describes the binding. It declares the type and version of the binding, its name, a short description and its methods list.</p>
<p>The list of methods is an array of structures describing the methods and terminated by a NULL marker.</p>
<p>In version one of afb-damon binding, a method description contains 4 fields:</p>
<ul>
<li><p>the name of the method,</p></li>
<li><p>the session management flags,</p></li>
<li><p>the implementation function to be call for the method,</p></li>
<li><p>a short description.</p></li>
</ul>
<p>The structure describing methods is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Description of one method of the API provided by the binding</span>
<span class="co"> * This enumeration is valid for bindings of type 1</span>
<span class="co"> */</span>
<span class="kw">struct</span> afb_verb_desc_v1
{
       <span class="dt">const</span> <span class="dt">char</span> *name;                       <span class="co">/* name of the method */</span>
       <span class="kw">enum</span> AFB_session_v1 session;            <span class="co">/* authorisation and session requirements of the method */</span>
       <span class="dt">void</span> (*callback)(<span class="kw">struct</span> afb_req req);   <span class="co">/* callback function implementing the method */</span>
       <span class="dt">const</span> <span class="dt">char</span> *info;                       <span class="co">/* textual description of the method */</span>
};</code></pre></div>
<p>For technical reasons, the enumeration <strong>enum AFB_session_v1</strong> is not exactly an enumeration but the wrapper of constant definitions that can be mixed using bitwise or (the C operator |).</p>
<p>The constants that can bit mixed are:</p>
<table style="width:100%;">
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Constant name</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>AFB_SESSION_CREATE</strong></td>
<td style="text-align: left;">Equals to AFB_SESSION_LOA_EQ_0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>AFB_SESSION_CLOSE</strong></td>
<td style="text-align: left;">Closes the session after the reply and set the LOA to 0</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>AFB_SESSION_RENEW</strong></td>
<td style="text-align: left;">Refreshes the token of authentification</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>AFB_SESSION_CHECK</strong></td>
<td style="text-align: left;">Just requires the token authentification</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>AFB_SESSION_LOA_LE_0</strong></td>
<td style="text-align: left;">Requires the current LOA to be lesser then or equal to 0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>AFB_SESSION_LOA_LE_1</strong></td>
<td style="text-align: left;">Requires the current LOA to be lesser then or equal to 1</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>AFB_SESSION_LOA_LE_2</strong></td>
<td style="text-align: left;">Requires the current LOA to be lesser then or equal to 2</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>AFB_SESSION_LOA_LE_3</strong></td>
<td style="text-align: left;">Requires the current LOA to be lesser then or equal to 3</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>AFB_SESSION_LOA_GE_0</strong></td>
<td style="text-align: left;">Requires the current LOA to be greater then or equal to 0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>AFB_SESSION_LOA_GE_1</strong></td>
<td style="text-align: left;">Requires the current LOA to be greater then or equal to 1</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>AFB_SESSION_LOA_GE_2</strong></td>
<td style="text-align: left;">Requires the current LOA to be greater then or equal to 2</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>AFB_SESSION_LOA_GE_3</strong></td>
<td style="text-align: left;">Requires the current LOA to be greater then or equal to 3</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>AFB_SESSION_LOA_EQ_0</strong></td>
<td style="text-align: left;">Requires the current LOA to be equal to 0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>AFB_SESSION_LOA_EQ_1</strong></td>
<td style="text-align: left;">Requires the current LOA to be equal to 1</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>AFB_SESSION_LOA_EQ_2</strong></td>
<td style="text-align: left;">Requires the current LOA to be equal to 2</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>AFB_SESSION_LOA_EQ_3</strong></td>
<td style="text-align: left;">Requires the current LOA to be equal to 3</td>
</tr>
</tbody>
</table>
<p>If any of this flag is set, afb-daemon requires an authentication token as if <strong>AFB_SESSION_CHECK</strong> flag was also set.</p>
<p>The special value <strong>AFB_SESSION_NONE</strong> is zero and can be used to bypass token check.</p>
<blockquote>
<p>Note that <strong>AFB_SESSION_CREATE</strong> and <strong>AFB_SESSION_CLOSE</strong> might be removed in later versions.</p>
</blockquote>
<h2 id="sending-messages-to-the-log-system">Sending messages to the log system</h2>
<p>Afb-daemon provides 4 levels of verbosity and 5 methods for logging messages.</p>
<p>The verbosity is managed. Options allow the change the verbosity of afb-daemon and the verbosity of the bindings can be set binding by binding.</p>
<p>The methods for logging messages are defined as macros that test the verbosity level and that call the real logging function only if the message must be output. This avoid evaluation of arguments of the formatting messages if the message must not be output.</p>
<h3 id="verbs-for-logging-messages">Verbs for logging messages</h3>
<p>The 5 logging methods are:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Macro</th>
<th style="text-align: center;">Verbosity</th>
<th style="text-align: left;">Meaning</th>
<th style="text-align: center;">syslog level</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">ERROR</td>
<td style="text-align: center;">0</td>
<td style="text-align: left;">Error conditions</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: left;">WARNING</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;">Warning conditions</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NOTICE</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;">Normal but significant condition</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="even">
<td style="text-align: left;">INFO</td>
<td style="text-align: center;">2</td>
<td style="text-align: left;">Informational</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DEBUG</td>
<td style="text-align: center;">3</td>
<td style="text-align: left;">Debug-level messages</td>
<td style="text-align: center;">7</td>
</tr>
</tbody>
</table>
<p>You can note that the 2 methods <strong>WARNING</strong> and <strong>INFO</strong> have the same level of verbosity. But they don't have the same <em>syslog level</em>. It means that they are output with a different level on the logging system.</p>
<p>All of these methods have the same signature:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> ERROR(<span class="dt">const</span> <span class="kw">struct</span> afb_binding_interface *afbitf, <span class="dt">const</span> <span class="dt">char</span> *message, ...);</code></pre></div>
<p>The first argument <strong>afbitf</strong> is the interface to afb daemon that the binding received at initialisation time when <strong>afbBindingV1Register</strong> is called.</p>
<p>The second argument <strong>message</strong> is a formatting string compatible with printf/sprintf.</p>
<p>The remaining arguments are arguments of the formating message like with printf.</p>
<h3 id="managing-verbosity">Managing verbosity</h3>
<p>Depending on the level of verbosity, the messages are output or not. The following table explains what messages will be output depending ont the verbosity level.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Level of verbosity</th>
<th style="text-align: left;">Outputed macro</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: left;">ERROR</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: left;">ERROR + WARNING + NOTICE</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: left;">ERROR + WARNING + NOTICE + INFO</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: left;">ERROR + WARNING + NOTICE + INFO + DEBUG</td>
</tr>
</tbody>
</table>
<h3 id="output-format-and-destination">Output format and destination</h3>
<p>The syslog level is used for forging a prefix to the message. The prefixes are:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">syslog level</th>
<th style="text-align: left;">prefix</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: left;">&lt;0&gt; EMERGENCY</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: left;">&lt;1&gt; ALERT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: left;">&lt;2&gt; CRITICAL</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: left;">&lt;3&gt; ERROR</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: left;">&lt;4&gt; WARNING</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: left;">&lt;5&gt; NOTICE</td>
</tr>
<tr class="odd">
<td style="text-align: center;">6</td>
<td style="text-align: left;">&lt;6&gt; INFO</td>
</tr>
<tr class="even">
<td style="text-align: center;">7</td>
<td style="text-align: left;">&lt;7&gt; DEBUG</td>
</tr>
</tbody>
</table>
<p>The message is pushed to standard error. The final destination of the message depends on how systemd service was configured through its variable <strong>StandardError</strong>. It can be journal, syslog or kmsg. (See man sd-daemon).</p>
<h2 id="sending-events">Sending events</h2>
<p>Since version 0.5, bindings can broadcast events to any potential listener. As today only unattended even are supported. Targeted events are expected for next coming version.</p>
<p>The binding <em>tic-tac-toe</em> broadcasts events when the board changes. This is done in the function <strong>changed</strong>:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * signals a change of the board</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="dt">void</span> changed(<span class="kw">struct</span> board *board, <span class="dt">const</span> <span class="dt">char</span> *reason)
{
    ...
    <span class="kw">struct</span> json_object *description;

    <span class="co">/* get the description */</span>
    description = describe(board);

    ...

    afb_daemon_broadcast_event(afbitf-&gt;daemon, reason, description);
}</code></pre></div>
<p>The description of the changed board is pushed via the daemon interface.</p>
<p>Within binding <em>tic-tac-toe</em>, <em>reason</em> indicates the origin of the change. In function <strong>afb_daemon_broadcast_event</strong> the second parameter is the name of broadcasted event. The third argument is the object that is transmitted with the event.</p>
<p>Function <strong>afb_daemon_broadcast_event</strong> is defined here after:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * Broadcasts widely the event of &#39;name&#39; with the data &#39;object&#39;.</span>
<span class="co"> * &#39;object&#39; can be NULL.</span>
<span class="co"> * &#39;daemon&#39; MUST be the daemon given in interface when activating the binding.</span>
<span class="co"> *</span>
<span class="co"> * For convenience, the function calls &#39;json_object_put&#39; for &#39;object&#39;.</span>
<span class="co"> * Thus, in the case where &#39;object&#39; should remain available after</span>
<span class="co"> * the function returns, the function &#39;json_object_get&#39; shall be used.</span>
<span class="co"> */</span>
<span class="dt">void</span> afb_daemon_broadcast_event(<span class="kw">struct</span> afb_daemon daemon, <span class="dt">const</span> <span class="dt">char</span> *name, <span class="kw">struct</span> json_object *object);</code></pre></div>
<blockquote>
<p>Be aware, as with reply functions <strong>object</strong> is automatically released using <strong>json_object_put</strong> when using this function. Call <strong>json_object_get</strong> before calling <strong>afb_daemon_broadcast_event</strong> to keep <strong>object</strong> available after function returns.</p>
</blockquote>
<p>Event name received by listeners is prefixed with binding name. So when a change occurs after a move, the reason is <strong>move</strong> and every clients receive an event <strong>tictactoe/move</strong>.</p>
<blockquote>
<p>Note that nothing is said about case sensitivity of event names. However, the event is always prefixed with the name that the binding declared, with the same case, followed with a slash /. Thus it is safe to compare event using a case sensitive comparison.</p>
</blockquote>
<h2 id="writing-an-asynchronous-method-implementation">Writing an asynchronous method implementation</h2>
<p>The <em>tic-tac-toe</em> example allows two clients or more to share the same board. This is implemented by the method <strong>join</strong> that illustrated partly how to retrieve arguments.</p>
<p>When two or more clients are sharing a same board, one of them can wait until the state of the board changes, but this could also be implemented using events because an even is generated each time the board changes.</p>
<p>In this case, the reply to the wait is sent only when the board changes. See the diagram below:</p>
<pre><code>CLIENT A       CLIENT B         TIC-TAC-TOE
   |              |                  |
   +--------------|-----------------&gt;| wait . . . . . . . .
   |              |                  |                     .
   :              :                  :                      .
   :              :                  :                      .
   |              |                  |                      .
   |              +-----------------&gt;| move . . .           .
   |              |                  |          V           .
   |              |&lt;-----------------+ success of move      .
   |              |                  |                    .
   |&lt;-------------|------------------+ success of wait  &lt;</code></pre>
<p>Here, this is an invocation of the binding by an other client that unblock the suspended <em>wait</em> call. Nevertheless in most case this should be a timer, a hardware event, a sync with a concurrent process or thread, ...</p>
<p>Common case of an asynchronous implementation.</p>
<p>Here is the listing of the function <strong>wait</strong>:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">void</span> wait(<span class="kw">struct</span> afb_req req)
{
    <span class="kw">struct</span> board *board;
    <span class="kw">struct</span> waiter *waiter;

    <span class="co">/* retrieves the context for the session */</span>
    board = board_of_req(req);
    INFO(afbitf, <span class="st">&quot;method &#39;wait&#39; called for boardid %d&quot;</span>, board-&gt;id);

    <span class="co">/* creates the waiter and enqueues it */</span>
    waiter = calloc(<span class="dv">1</span>, <span class="kw">sizeof</span> *waiter);
    waiter-&gt;req = req;
    waiter-&gt;next = board-&gt;waiters;
    afb_req_addref(req);
    board-&gt;waiters = waiter;
}</code></pre></div>
<p>After retrieving the board, the function adds a new waiter to waiters list and returns without setting a reply.</p>
<p>Before returning, it increases <strong>req</strong> request's reference count using <strong>afb_req_addref</strong> function.</p>
<blockquote>
<p>When a method returns without setting a reply, it <strong>MUST</strong> increment request's reference count using <strong>afb_req_addref</strong>. If unpredictable behaviour may pop up.</p>
</blockquote>
<p>Later, when a board changes, it calls <em>tic-tac-toe</em> <strong>changed</strong> function with reason of change in parameter.</p>
<p>Here is the full listing of the function <strong>changed</strong>:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * signals a change of the board</span>
<span class="co"> */</span>
<span class="dt">static</span> <span class="dt">void</span> changed(<span class="kw">struct</span> board *board, <span class="dt">const</span> <span class="dt">char</span> *reason)
{
    <span class="kw">struct</span> waiter *waiter, *next;
    <span class="kw">struct</span> json_object *description;

    <span class="co">/* get the description */</span>
    description = describe(board);

    waiter = board-&gt;waiters;
    board-&gt;waiters = NULL;
    <span class="kw">while</span> (waiter != NULL) {
        next = waiter-&gt;next;
        afb_req_success(waiter-&gt;req, json_object_get(description), reason);
        afb_req_unref(waiter-&gt;req);
        free(waiter);
        waiter = next;
    }

    afb_event_sender_push(afb_daemon_get_event_sender(afbitf-&gt;daemon), reason, description);
}</code></pre></div>
<p>The list of waiters is walked and a reply is sent to each waiter. After sending the reply, the reference count of the request is decremented using <strong>afb_req_unref</strong> to allow resources to be freed.</p>
<blockquote>
<p>The reference count <strong>MUST</strong> be decremented using <strong>afb_req_unref</strong> to free resources and avoid memory leaks. This usage count decrement should happen <strong>AFTER</strong> setting reply or bad things may happen.</p>
</blockquote>
<h2 id="how-to-build-a-binding">How to build a binding</h2>
<p>Afb-daemon provides a <em>pkg-config</em> configuration file that can be queried by providing <strong>afb-daemon</strong> in command line arguments. This configuration file provides data that should be used for bindings compilation. Examples:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">pkg-config</span> --cflags afb-daemon
$ <span class="kw">pkg-config</span> --libs afb-daemon</code></pre></div>
<h3 id="example-for-cmake-meta-build-system">Example for cmake meta build system</h3>
<p>This example is the extract for building the binding <em>afm-main</em> using <em>CMAKE</em>.</p>
<div class="sourceCode"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span class="fu">pkg_check_modules</span>(afb afb-daemon)
<span class="kw">if</span>(afb_FOUND)
    <span class="kw">message</span>(<span class="ot">STATUS</span> <span class="st">&quot;Creation afm-main-binding for AFB-DAEMON&quot;</span>)
    <span class="kw">add_library</span>(afm-main-binding <span class="ot">MODULE</span> afm-main-binding.c)
    <span class="kw">target_compile_options</span>(afm-main-binding <span class="ot">PRIVATE</span> <span class="dv">${afb_CFLAGS}</span>)
    <span class="kw">target_include_directories</span>(afm-main-binding <span class="ot">PRIVATE</span> <span class="dv">${afb_INCLUDE_DIRS}</span>)
    <span class="kw">target_link_libraries</span>(afm-main-binding utils <span class="dv">${afb_LIBRARIES}</span>)
    <span class="kw">set_target_properties</span>(afm-main-binding <span class="ot">PROPERTIES</span>
        <span class="ot">PREFIX</span> <span class="st">&quot;&quot;</span>
        <span class="ot">LINK_FLAGS</span> <span class="st">&quot;-Wl,--version-script=</span><span class="dv">${CMAKE_CURRENT_SOURCE_DIR}</span><span class="st">/afm-main-binding.export-map&quot;</span>
    )
    <span class="kw">install</span>(<span class="ot">TARGETS</span> afm-main-binding <span class="ot">LIBRARY</span> <span class="ot">DESTINATION</span> <span class="dv">${binding_dir}</span>)
<span class="kw">else</span>()
    <span class="kw">message</span>(<span class="ot">STATUS</span> <span class="st">&quot;Not creating the binding for AFB-DAEMON&quot;</span>)
<span class="kw">endif</span>()</code></pre></div>
<p>Let now describe some of these lines.</p>
<div class="sourceCode"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span class="fu">pkg_check_modules</span>(afb afb-daemon)</code></pre></div>
<p>This first lines searches to the <em>pkg-config</em> configuration file for <strong>afb-daemon</strong>. Resulting data are stored in the following variables:</p>
<table style="width:94%;">
<colgroup>
<col style="width: 26%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Variable</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">afb_FOUND</td>
<td style="text-align: left;">Set to 1 if afb-daemon binding development files exist</td>
</tr>
<tr class="even">
<td style="text-align: left;">afb_LIBRARIES</td>
<td style="text-align: left;">Only the libraries (w/o the '-l') for compiling afb-daemon bindings</td>
</tr>
<tr class="odd">
<td style="text-align: left;">afb_LIBRARY_DIRS</td>
<td style="text-align: left;">The paths of the libraries (w/o the '-L') for compiling afb-daemon bindings</td>
</tr>
<tr class="even">
<td style="text-align: left;">afb_LDFLAGS</td>
<td style="text-align: left;">All required linker flags for compiling afb-daemon bindings</td>
</tr>
<tr class="odd">
<td style="text-align: left;">afb_INCLUDE_DIRS</td>
<td style="text-align: left;">The '-I' preprocessor flags (w/o the '-I') for compiling afb-daemon bindings</td>
</tr>
<tr class="even">
<td style="text-align: left;">afb_CFLAGS</td>
<td style="text-align: left;">All required cflags for compiling afb-daemon bindings</td>
</tr>
</tbody>
</table>
<p>If development files are found, the binding can be added to the set of target to build.</p>
<div class="sourceCode"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span class="kw">add_library</span>(afm-main-binding <span class="ot">MODULE</span> afm-main-binding.c)</code></pre></div>
<p>This line asks to create a shared library having a single source file named afm-main-binding.c to be compiled. The default name of the created shared object is <strong>libafm-main-binding.so</strong>.</p>
<div class="sourceCode"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span class="kw">set_target_properties</span>(afm-main-binding <span class="ot">PROPERTIES</span>
    <span class="ot">PREFIX</span> <span class="st">&quot;&quot;</span>
    <span class="ot">LINK_FLAGS</span> <span class="st">&quot;-Wl,--version-script=</span><span class="dv">${CMAKE_CURRENT_SOURCE_DIR}</span><span class="st">/afm-main-binding.export-map&quot;</span>
)</code></pre></div>
<p>This lines are doing two things:</p>
<ol type="1">
<li><p>It renames the built library from <strong>libafm-main-binding.so</strong> to <strong>afm-main-binding.so</strong> by removing the implicitly added prefix <em>lib</em>. This step is not mandatory because afb-daemon doesn't check names of files at load time. The only filename convention used by afb-daemon relates to <strong>.so</strong> termination. *.so pattern is used when afb-daemon automatically discovers binding from a directory hierarchy.</p></li>
<li><p>It applies a version script at link time to only export the reserved name <strong>afbBindingV1Register</strong> for registration entry point. By default, when building a shared library linker exports all the public symbols (C functions that are not <strong>static</strong>).</p></li>
</ol>
<p>Next line are:</p>
<div class="sourceCode"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span class="kw">target_include_directories</span>(afm-main-binding <span class="ot">PRIVATE</span> <span class="dv">${afb_INCLUDE_DIRS}</span>)
<span class="kw">target_link_libraries</span>(afm-main-binding utils <span class="dv">${afb_LIBRARIES}</span>)</code></pre></div>
<p>As you can see it uses the variables computed by <strong><em>pkg_check_modules(afb afb-daemon)</em></strong> to configure the compiler and the linker.</p>
<h3 id="exporting-the-function-afbbindingv1register">Exporting the function afbBindingV1Register</h3>
<p>The function <strong>afbBindingV1Register</strong> MUST be exported. This can be achieved using a version script at link time. Here after is a version script used for <em>tic-tac-toe</em> (bindings/samples/export.map).</p>
<pre><code>{ global: afbBindingV1Register; local: *; };</code></pre>
<p>This sample <a href="https://sourceware.org/binutils/docs-2.26/ld/VERSION.html#VERSION">version script</a> exports as global the symbol <em>afbBindingV1Register</em> and hides any other symbols.</p>
<p>This version script is added to the link options using the option <strong>--version-script=export.map</strong> is given directly to the linker or using the option <strong>-Wl,--version-script=export.map</strong> when the option is given to the C compiler.</p>
<h3 id="building-within-yocto">Building within yocto</h3>
<p>Adding a dependency to afb-daemon is enough. See below:</p>
<pre><code>DEPENDS += &quot; afb-daemon &quot;</code></pre>
</body>
</html>
