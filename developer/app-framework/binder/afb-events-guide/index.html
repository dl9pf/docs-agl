<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../../img/favicon.ico">
        <title>Afb events guide - AGL Documentation</title>
        <link href="../../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../../../../css/highlight.css">
        <link href="../../../../agl.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
	
	<script src="../../../../js/jquery-1.10.2.min.js"></script>
        <script src="../../../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../../../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../../../..">AGL Documentation</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="../../../..">Home</a>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Developer <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
  <li class="dropdown-submenu">
    <a href="#">App framework</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../">Home</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#">Binder</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../FAQ/">FAQ</a>
</li>
            
<li >
    <a href="../afb-application-writing/">Afb application writing</a>
</li>
            
<li >
    <a href="../afb-bindings-overview/">Afb bindings overview</a>
</li>
            
<li >
    <a href="../afb-bindings-writing/">Afb bindings writing</a>
</li>
            
<li >
    <a href="../afb-daemon-vocabulary/">Afb daemon vocabulary</a>
</li>
            
<li class="active">
    <a href="./">Afb events guide</a>
</li>
            
<li >
    <a href="../afb-overview/">Afb overview</a>
</li>
            
<li >
    <a href="../afb-tests-overview/">Afb tests overview</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#">Main</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../main/afm-system-daemon/">Afm system daemon</a>
</li>
            
<li >
    <a href="../../main/afm-user-daemon/">Afm user daemon</a>
</li>
            
<li >
    <a href="../../main/application-framework/">Application framework</a>
</li>
            
<li >
    <a href="../../main/">Home</a>
</li>
            
<li >
    <a href="../../main/overview/">Overview</a>
</li>
            
<li >
    <a href="../../main/quick-tutorial/">Quick tutorial</a>
</li>
            
<li >
    <a href="../../main/security-framework/">Security framework</a>
</li>
            
<li >
    <a href="../../main/widgets/">Widgets</a>
</li>
            
<li >
    <a href="../../main/writing-config.xml/">Writing config.xml</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                            
  <li class="dropdown-submenu">
    <a href="#">Audio</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../audio/">Home</a>
</li>
    </ul>
  </li>
                            
  <li class="dropdown-submenu">
    <a href="#">Sec blueprint</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../sec-blueprint/01-overview/">01 overview</a>
</li>
            
<li >
    <a href="../../../sec-blueprint/02-plateform-security/">02 plateform security</a>
</li>
            
<li >
    <a href="../../../sec-blueprint/03-security-concepts/">03 security concepts</a>
</li>
            
<li >
    <a href="../../../sec-blueprint/04-adversaries/">04 adversaries</a>
</li>
            
<li >
    <a href="../../../sec-blueprint/04-threat-analysis/">04 threat analysis</a>
</li>
            
<li >
    <a href="../../../sec-blueprint/06-attack-surfaces/">06 attack surfaces</a>
</li>
            
<li >
    <a href="../../../sec-blueprint/">Home</a>
</li>
    </ul>
  </li>
                            
  <li class="dropdown-submenu">
    <a href="#">Signaling</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../signaling/architecture/">Architecture</a>
</li>
            
<li >
    <a href="../../../signaling/">Home</a>
</li>
    </ul>
  </li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">User <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
  <li class="dropdown-submenu">
    <a href="#">Getting started</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../../user/getting-started/source-code/">Source code</a>
</li>
            
<li >
    <a href="../../../../user/getting-started/troubleshooting/">Troubleshooting</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#">Footers</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../../user/getting-started/footers/porter-footer/">Porter footer</a>
</li>
            
<li >
    <a href="../../../../user/getting-started/footers/raspberrypi-footer/">Raspberrypi footer</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#">Machines</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../../user/getting-started/machines/porter/">Porter</a>
</li>
            
<li >
    <a href="../../../../user/getting-started/machines/qemu/">Qemu</a>
</li>
            
<li >
    <a href="../../../../user/getting-started/machines/raspberrypi/">Raspberrypi</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                        </ul>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../afb-daemon-vocabulary/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../afb-overview/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/automotive-grade-linux/docs-agl">
                                <i class="fa fa-github"></i>GitHub
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#guide-for-developing-with-events">Guide for developing with events</a></li>
            <li><a href="#overview-of-events">Overview of events</a></li>
            <li><a href="#reference-of-functions">Reference of functions</a></li>
            <li><a href="#architectural-digressions">Architectural digressions</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="guide-for-developing-with-events">Guide for developing with events</h1>
<p>Signaling agents are services that send events to any clients that
subscribed for receiving it. The sent events carry any data.</p>
<p>To have a good understanding of how to write a signaling agent, the
actions of subscribing, unsubscribing, producing, sending, receiving
events must be described and explained.</p>
<h2 id="overview-of-events">Overview of events</h2>
<p>The basis of a signaling agent is shown on the following figure:</p>
<p><img alt="scenario of using events" src="../signaling-basis.svg" /></p>
<p>This figure shows the main role of the signaling framework for the
propagation of events.</p>
<p>For people not familiar with the framework, a signaling agent and
a “binding” are similar.</p>
<h3 id="subscribing-and-unsubscribing">Subscribing and unsubscribing</h3>
<p>Subscribing and subscription is the action that makes a client able to
receive data from a signaling agent. Subscription must create resources
for generating the data and for delivering the data to the client. These
two aspects are not handled by the same piece of software: generating
the data is the responsibility of the developer of the signaling agent
while delivering the data is handled by the framework.</p>
<p>When a client subscribes for data, the agent must:</p>
<ol>
<li>check that the subscription request is correct;</li>
<li>establish the computation chain of the required data, if not already
    done;</li>
<li>create a named event for the computed data, if not already done;</li>
<li>ask the framework to establish the subscription to the event for the
    request;</li>
<li>optionally give indications about the event in the reply to
    the client.</li>
</ol>
<p>The first two steps are not involving the framework. They are linked to
the business logic of the binding. The request can be any description of
the requested data and the computing stream can be of any nature, this
is specific to the binding.</p>
<p>As said before, the framework uses and integrates “libsystemd” and its event
loop. Within the framework, "libsystemd" is the standard API/library for
bindings expecting to setup and handle I/O, timer or signal events.</p>
<p>Steps 3 and 4 are bound to the framework.</p>
<p>The agent must create an object for handling the propagation of produced
data to its clients. That object is called “event” in the framework. An
event has a name that allows clients to distinguish it from other
events.</p>
<p>Events are created using the <strong><em>afb_daemon_make_event</em></strong> function
that takes the name of the event. Example:</p>
<pre><code class="C">    event = afb_daemon_make_event(afb_daemon, name);
</code></pre>

<p>Once created, the event can be used either to push data to its
subscribers or to broadcast data to any listener.</p>
<p>The event must be used to establish the subscription for the requesting
client. This is done using the <strong><em>afb_req_subscribe</em></strong> function
that takes the current request object and event and associates them
together. Example:</p>
<pre><code class="C">    rc = afb_req_subscribe(afb_req, event);
</code></pre>

<p>When successful, this function make the connection between the event and
the client that emitted the request. The client becomes a subscriber of
the event until it unsubscribes or disconnects. The
<strong><em>afb_req_subscribe</em></strong> function will fail if the client
connection is weak: if the request comes from a HTTP link. To receive
signals, the client must be connected. The AGL framework allows
connections using WebSocket.</p>
<p>The name of the event is either a well known name or an ad hoc name
forged for the usecase.</p>
<p>Let's see a basic example: client A expects to receive the speed in km/h
every second while client B expects the speed in mph twice a second. In
that case, there are two different events because it is not the same
unit and it is not the same frequency. Having two different events
allows to associate clients to the correct event. But this doesn't tell
any word about the name of these events. The designer of the signaling
agent has two options for naming:</p>
<ol>
<li>names can be the same (“speed” for example) with sent data
    self-describing itself or having a specific tag (requiring from
    clients awareness about requesting both kinds of speed isn't safe).</li>
<li>names of the event include the variations (by example:
    “speed-km/h-1Hz” and “speed-mph-2Hz”) and, in that case, sent data
    can self-describe itself or not.</li>
</ol>
<p>In both cases, the signaling agent might have to send the name of the
event and/or an associated tag to its client in the reply of the
subscription. This is part of the step 5 above.</p>
<p>The framework only uses the event (not its name) for subscription,
unsubscription and pushing.</p>
<p>When the requested data is already generated and the event used for
pushing it already exists, the signaling agent must not instantiate a
new processing chain and must not create a new event object for pushing
data. The signaling agent must reuse the existing chain and event.</p>
<p>Unsubscribing is made by the signaling agent on a request of its client.
The <strong><em>afb_req_unsubscribe</em></strong> function tells the framework to
remove the requesting client from the event's list of subscribers.
Example:</p>
<pre><code class="C">    afb_req_unsubscribe(afb_req, event);
</code></pre>

<p>Subscription count does not matter to the framework: subscribing the
same client several times has the same effect that subscribing only one
time. Thus, when unsubscribing is invoked, it becomes immediately
effective.</p>
<h4 id="more-on-naming-events">More on naming events</h4>
<p>Within the AGL framework, a signaling agent is a binding that has an API
prefix. This prefix is meant to be unique and to identify the binding
API. The names of the events that this signaling agent creates are
automatically prefixed by the framework, using the API prefix of the
binding.</p>
<p>Thus, if a signaling agent of API prefix <strong><em>api</em></strong> creates an event
of name <strong><em>event</em></strong> and pushes data to that event, the subscribers
will receive an event of name <strong><em>api/event</em></strong>.</p>
<h3 id="generating-and-pushing-signals-and-data">Generating and pushing signals and data</h3>
<p>This of the responsibility of the designer of the signaling agent to
establish the processing chain for generating events. In many cases,
this can be achieved using I/O or timer or signal events inserted in the
main loop. For this case, the AGL framework uses “libsystemd” and
provide a way to integrates to the main loop of this library using
afb_daemon_get_event_loop. Example:</p>
<pre><code class="C">    sdev = afb_daemon_get_event_loop(af_daemon);
    rc = sd_event_add_io(sdev, &amp;source, fd, EPOLLIN, myfunction, NULL);
</code></pre>

<p>In some other cases, the events are coming from D-Bus. In that case, the
framework also uses “libsystemd” internally to access D-Bus. It provides
two methods to get the available D-Bus objects, already existing and
bound to the main libsystemd event loop. Use either
<strong><em>afb_daemon_get_system_bus</em></strong> or
<strong><em>afb_daemon_get_user_bus</em></strong> to get the required instance. Then
use functions of “libsystemd” to handle D-Bus.</p>
<p>In some rare cases, the generation of the data requires to start a new
thread.</p>
<p>When a data is generated and ready to be pushed, the signaling agent
should call the function <strong><em>afb_event_push</em></strong>. Example:</p>
<pre><code class="C">    rc = afb_event_push(event, json);
    if (rc == 0) {
        stop_generating(event);
        afb_event_drop(event);
    }
</code></pre>

<p>The function <strong><em>afb_event_push</em></strong> pushes json data to all the
subscribers. It then returns the count of subscribers. When the count is
zero, there is no subscriber listening for the event. The example above
shows that in that case, the signaling agent stops to generate data for
the event and delete the event using afb_event_drop. This is one
possible option. Other valuable options are: do nothing and continue to
generate and push the event or just stop to generate and push the data
but keep the event existing.</p>
<h3 id="receiving-the-signals">Receiving the signals</h3>
<p>Understanding what a client expects when it receives signals, events or
data shall be the most important topic of the designer of a signaling
agent. The good point here is that because JSON[^1] is the exchange
format, structured data can be sent in a flexible way.</p>
<p>The good design is to allow as much as possible the client to describe
what is needed with the goal to optimize the processing to the
requirements only.</p>
<h3 id="the-exceptional-case-of-wide-broadcast">The exceptional case of wide broadcast</h3>
<p>Some data or events have so much importance that they can be widely
broadcasted to alert any listening client. Examples of such an alert
are:</p>
<ul>
<li>system is entering/leaving “power safe” mode</li>
<li>system is shutting down</li>
<li>the car starts/stops moving</li>
<li>...</li>
</ul>
<p>An event can be broadcasted using one of the two following methods:
<strong><em>afb_daemon_broadcast_event</em></strong> or
<strong><em>afb_event_broadcast</em></strong>.</p>
<p>Example 1:</p>
<pre><code class="C">    afb_daemon_broadcast_event(afb_daemon, name, json);
</code></pre>

<p>Example 2:</p>
<pre><code class="C">    event = afb_daemon_make_event(afb_daemon, name);
    . . . .
    afb_event_broadcast(event, json);
</code></pre>

<p>As for other events, the name of events broadcasted using
<strong><em>afb_daemon_broadcast_event</em></strong> are automatically prefixed by
the framework with API prefix of the binding (signaling agent).</p>
<h2 id="reference-of-functions">Reference of functions</h2>
<h3 id="function-afb95event-afb95daemon95make95event">Function afb_event afb_daemon_make_event</h3>
<p>The function <strong><em>afb_daemon_make_event</em></strong> that is defined as below:</p>
<pre><code class="C">/*
 * Creates an event of 'name' and returns it.
 * 'daemon' MUST be the daemon given in interface when activating the binding.
 */
struct afb_event afb_daemon_make_event(struct afb_daemon daemon, const char *name);
</code></pre>

<p>The daemon is the handler to the application framework binder daemon
received during initialisation steps of the binding.</p>
<p>Calling the function <strong><em>afb_daemon_make_event</em></strong> within the initialisation
function <strong><em>afbBindingV1Register</em></strong> will <em>fail</em> because the plugin
name is not known at this time.</p>
<p>The correct way to create the event at initialisation is to call the function
<strong><em>afb_daemon_make_event</em></strong> within the initialisation
function <strong><em>afbBindingV1ServiceInit</em></strong>.</p>
<h3 id="function-afb95event95push">Function afb_event_push</h3>
<p>The function <strong><em>afb_event_push</em></strong> is defined as below:</p>
<pre><code class="C">/*
 * Pushes the 'event' with the data 'object' to its observers.
 * 'object' can be NULL.
 *
 * For convenience, the function calls 'json_object_put' for object'.
 * Thus, in the case where 'object' should remain available after
 * the function returns, the function 'json_object_get' shall be used.
 *
 * Returns the count of clients that received the event.
 */
int afb_event_push(struct afb_event event, struct json_object *object);
</code></pre>

<p>As the function <strong><em>afb_event_push</em></strong> returns 0 when there is no
more subscriber, a binding can remove such unexpected event using the
function <strong><em>afb_event_drop</em></strong>.</p>
<h3 id="function-afb95event95drop">Function afb_event_drop</h3>
<p>The function <strong><em>afb_event_drop</em></strong> is defined as below:</p>
<pre><code class="C">/*
 * Drops the data associated to the event
 * After calling this function, the event
 * MUST NOT BE USED ANYMORE.
 */
void afb_event_drop(struct afb_event event);
</code></pre>

<h3 id="function-afb95req95subscribe">Function afb_req_subscribe</h3>
<p>The function <strong><em>afb_req_subscribe</em></strong> is defined as below:</p>
<pre><code class="C">/*
 * Establishes for the client link identified by 'req' a subscription
 * to the 'event'.
 * Returns 0 in case of successful subscription or -1 in case of error.
 */
int afb_req_subscribe(struct afb_req req, struct afb_event event);
</code></pre>

<p>The subscription adds the client of the request to the list of subscribers
to the event.</p>
<h3 id="function-afb95req95unsubscribe">Function afb_req_unsubscribe</h3>
<p>The function <strong><em>afb_req_unsubscribe</em></strong> is defined as
below:</p>
<pre><code class="C">/*
 * Revokes the subscription established to the 'event' for the client
 * link identified by 'req'.
 * Returns 0 in case of successful unsubscription or -1 in case of error.
 */
int afb_req_unsubscribe(struct afb_req req, struct afb_event event);
</code></pre>

<p>The unsubscription removes the client of the request of the list of subscribers
to the event.
When the list of subscribers to the event becomes empty,
the function <strong><em>afb_event_push</em></strong> will return zero.</p>
<h3 id="function-afb95event95broadcast">Function afb_event_broadcast</h3>
<p>The function <strong><em>afb_event_broadcast</em></strong> is defined as below:</p>
<pre><code class="C">/*
 * Broadcasts widely the 'event' with the data 'object'.
 * 'object' can be NULL.
 *
 * For convenience, the function calls 'json_object_put' for 'object'.
 * Thus, in the case where 'object' should remain available after
 * the function returns, the function 'json_object_get' shall be used.
 *
 * Returns the count of clients that received the event.
 */
int afb_event_broadcast(struct afb_event event, struct json_object *object);
</code></pre>

<p>This uses an existing event (created with <strong><em>afb_daemon_make_event</em></strong>)
for broadcasting an event having its name.</p>
<h3 id="function-afb95daemon95broadcast95event">Function afb_daemon_broadcast_event</h3>
<p>The function <strong><em>afb_daemon_broadcast_event</em></strong> is defined as below:</p>
<pre><code class="C">/*
 * Broadcasts widely the event of 'name' with the data 'object'.
 * 'object' can be NULL.
 * 'daemon' MUST be the daemon given in interface when activating the binding.
 *
 * For convenience, the function calls 'json_object_put' for 'object'.
 * Thus, in the case where 'object' should remain available after
 * the function returns, the function 'json_object_get' shall be used.
 *
 * Returns the count of clients that received the event.
 */
int afb_daemon_broadcast_event(struct afb_daemon daemon, const char *name, struct json_object *object);
</code></pre>

<p>The name is given here explicitely. The name is automatically prefixed
with the name of the binding. For example, a binding of prefix "xxx"
would broadcat the event "xxx/name".</p>
<h2 id="architectural-digressions">Architectural digressions</h2>
<p>Based on their dependencies to hardware, signaling agents can be split
into 2 categories: low-level signaling agents and high-level signaling
agents.</p>
<p>Low-level signaling agents are bound to the hardware and focused on
interfacing and driving.</p>
<p>High-level signaling agent are independent of the hardware and ocused on
providing service.</p>
<p>This separation (that may in the corner look artificial) aim to help in
the systems design. The main idea here is that high-level signaling
agents are providing “business logic”, also known as “application
logic”, that is proper to the car industry and that can be reused and
that can evolve as a foundation for the future of the industry.</p>
<p>The implementation of this decomposition may follow 2 paths: strict
separation or soft composition.</p>
<h3 id="strict-separation">Strict separation</h3>
<p>The strict separation implements the modularity composition of signaling
agent through the framework. The high-level signaling agent subscribes
to the low level signaling agent using the standard client API.</p>
<p>Advantages:</p>
<ul>
<li>Modularity</li>
<li>Separation of responsibilities</li>
<li>Possible aggregation of multiple sources</li>
<li>Soft binding of agent good for maintenance</li>
</ul>
<p>Drawbacks:</p>
<ul>
<li>Cost of propagation of data (might serialize)</li>
<li>Difficulties to abstract low-level signaling agent or to find a
    trade-of between abstracting and specializing</li>
</ul>
<p>The key is modularity versus cost of propagation. It can be partly
solved when logical group of signaling agent are launched together in
the same binder process. In that particular case, the cost of
propagation of data between agents is reduced[^2] because there is no
serialization.</p>
<p>This reduction of the propagation cost (and of the resources used)
precludes implementation of strong security between the agents because
they share the same memory.</p>
<h3 id="soft-composition">Soft composition</h3>
<p>The soft composition implements the business logic of high-level
signaling agents as libraries that can then be used directly by the low
level signaling agents.</p>
<p>Advantages:</p>
<ul>
<li>No propagation: same memory, sharing of native structures</li>
</ul>
<p>Drawbacks:</p>
<ul>
<li>Cannot be used for aggregation of several sources</li>
<li>Difficulties to abstract low-level signaling agent or to find a
    trade-of between abstracting and specializing</li>
<li>Source code binding not good for maintenance</li>
</ul>
<p>[^1]: There are two aspect in using JSON: the first is the flexible data
    structure that mixes common types (booleans, numbers, strings,
    arrays, dictionaries, nulls), the second, is the streaming
    specification. Streaming is often seen as the bottleneck of using
    JSON (see http://bjson.org). When the agent share the same process,
    there is no streaming at all.</p>
<p>[^2]: Within the same process, there is not serialization, the
    propagation has the cost of wrapping a json data and calling
    callbacks with the benefit of having a powerful callback manager:
    the event mechanism of the framework.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '../../../..';</script>
        <script data-main="../../../../mkdocs/js/search.js" src="../../../../mkdocs/js/require.js"></script>
        <script src="../../../../js/base.js"></script><div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
