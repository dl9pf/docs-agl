{
    "docs": [
        {
            "location": "/", 
            "text": "The Automotive Grade Linux Documentation\n\n\nUser Documentation\n\n\nYou will find the user documentation in the user folder.\n\n\nDeveloper Documentation\n\n\nYou will find the developer documentation in the developer folder.", 
            "title": "Home"
        }, 
        {
            "location": "/#the-automotive-grade-linux-documentation", 
            "text": "", 
            "title": "The Automotive Grade Linux Documentation"
        }, 
        {
            "location": "/#user-documentation", 
            "text": "You will find the user documentation in the user folder.", 
            "title": "User Documentation"
        }, 
        {
            "location": "/#developer-documentation", 
            "text": "You will find the developer documentation in the developer folder.", 
            "title": "Developer Documentation"
        }, 
        {
            "location": "/developer/app-framework/", 
            "text": "AGL Application Framework\n\n\nThis page summarizes all materials related to AGL Application Framework\n\n\nSource Code\n\n\nThe current code of AGL App-Framework is stored on AGL Code Repository. It's divided in the following projects:\n\n\n\n\nsrc/app-framework-main\n Main services\n\n\nsrc/app-framework-binder\n: Binder Daemon\n\n\nsrc/app-framework-demo\n Demos\n\n\n\n\nBuilding AGL with Application Framework support\n\n\nThe Application Framework can be added easily to an AGL build using the feature 'agl-appfw-smack'.\n\n\nTypically, the following command can be called to initialize AGL build:\n\n\n# meta-agl/scripts/aglsetup.sh -m porter agl-appfw-smack agl-demo agl-devel\n...\n# bitbake agl-demo-platform\n\n\n\nDocumentation\n\n\nTechnical documentation is maintained in the source code and should be browsable with the \nupcoming AGL documentation system\n\n\nTemporarily, a static documentation has been made in PDF format:\n\n\n\n\nIntroduction to Application Framework\n\n\nAppFW Core Documentation\n\n\nPrivileges Management\n\n\n\n\nSome extra guides are also available in PDF format:\n\n\n\n\nBuild your 1st AGL Application\n\n\nApplications Templates are available on \ngithub:iotbzh/app-framework-templates\n\n\n\n\nBindings Examples\n\n\nSome bindings are  available to quickstart new projects:\n\n\n\n\nGPS - see \ngithub:iotbzh/af-gps-binding\n\n\nOpenXC Reader - see \ngithub:iotbzh/txc-demo\n\n\nCPU/Memory stats - see \ngithub:iotbzh/txc-demo\n\n\nRadio - see \ngerrit:src/app-framework-binder\n\n\nAudio - see \ngerrit:src/app-framework-binder\n\n\n\n\nThe list is not exhaustive. \nPlease add other bindings here !\n\n\nDemos\n\n\n\n\nSimple HTML5 Demos apps (ported from Tizen) on \ngithub:iotbzh/afm-widget-examples\n\n\nInstallable package with \nTXC Demo Application\n\n\nApplications available in \ngerrit:app-framework-demo\n\n\n\n\nPresentations\n\n\n\n\nOct 16 - \nApplication Security Model - Status Update\n\n\nSept 16 - \nBuilding Applications with AGL Framework\n - Also visible in \nPDF version\n\n\nFeb 16 - \nHTML5 Apps for Automotive Systems\n\n\nFeb 16 - \nApplication \n Security Framework Proposal AGL 2.0\n\n\nJan 16 - \nSecurity Architecture Proposal\n\n\n\n\nHistory\n\n\nMotivation for rewriting the App. Framework\n\n\nTo get the background and motivation on why Application Framework has been rewritten:\n\n\n\n\nTizen Security: lessons learnt\n\n\nthis discussion\n\n\nLinux Automotive Security\n\n\n\n\nComparison/Relationship with Tizen\n\n\n                          Tizen           AGL\n                          ----------------------------------\nApp/OS isolation           yes            yes\nContainer option           no             possible\nNative App                 partial*       yes\nHTML5 App                  yes            yes\nCloud App                  No             yes\nUnified API (HTLM/Native)  No             yes\nservice as App**           No             yes\nAdding API    ***          core           core or App\nDevel model                bespoke        Standard Web", 
            "title": "Home"
        }, 
        {
            "location": "/developer/app-framework/#agl-application-framework", 
            "text": "This page summarizes all materials related to AGL Application Framework", 
            "title": "AGL Application Framework"
        }, 
        {
            "location": "/developer/app-framework/#source-code", 
            "text": "The current code of AGL App-Framework is stored on AGL Code Repository. It's divided in the following projects:   src/app-framework-main  Main services  src/app-framework-binder : Binder Daemon  src/app-framework-demo  Demos", 
            "title": "Source Code"
        }, 
        {
            "location": "/developer/app-framework/#building-agl-with-application-framework-support", 
            "text": "The Application Framework can be added easily to an AGL build using the feature 'agl-appfw-smack'.  Typically, the following command can be called to initialize AGL build:  # meta-agl/scripts/aglsetup.sh -m porter agl-appfw-smack agl-demo agl-devel\n...\n# bitbake agl-demo-platform", 
            "title": "Building AGL with Application Framework support"
        }, 
        {
            "location": "/developer/app-framework/#documentation", 
            "text": "Technical documentation is maintained in the source code and should be browsable with the  upcoming AGL documentation system  Temporarily, a static documentation has been made in PDF format:   Introduction to Application Framework  AppFW Core Documentation  Privileges Management   Some extra guides are also available in PDF format:   Build your 1st AGL Application  Applications Templates are available on  github:iotbzh/app-framework-templates", 
            "title": "Documentation"
        }, 
        {
            "location": "/developer/app-framework/#bindings-examples", 
            "text": "Some bindings are  available to quickstart new projects:   GPS - see  github:iotbzh/af-gps-binding  OpenXC Reader - see  github:iotbzh/txc-demo  CPU/Memory stats - see  github:iotbzh/txc-demo  Radio - see  gerrit:src/app-framework-binder  Audio - see  gerrit:src/app-framework-binder   The list is not exhaustive.  Please add other bindings here !", 
            "title": "Bindings Examples"
        }, 
        {
            "location": "/developer/app-framework/#demos", 
            "text": "Simple HTML5 Demos apps (ported from Tizen) on  github:iotbzh/afm-widget-examples  Installable package with  TXC Demo Application  Applications available in  gerrit:app-framework-demo", 
            "title": "Demos"
        }, 
        {
            "location": "/developer/app-framework/#presentations", 
            "text": "Oct 16 -  Application Security Model - Status Update  Sept 16 -  Building Applications with AGL Framework  - Also visible in  PDF version  Feb 16 -  HTML5 Apps for Automotive Systems  Feb 16 -  Application   Security Framework Proposal AGL 2.0  Jan 16 -  Security Architecture Proposal", 
            "title": "Presentations"
        }, 
        {
            "location": "/developer/app-framework/#history", 
            "text": "", 
            "title": "History"
        }, 
        {
            "location": "/developer/app-framework/#motivation-for-rewriting-the-app-framework", 
            "text": "To get the background and motivation on why Application Framework has been rewritten:   Tizen Security: lessons learnt  this discussion  Linux Automotive Security", 
            "title": "Motivation for rewriting the App. Framework"
        }, 
        {
            "location": "/developer/app-framework/#comparisonrelationship-with-tizen", 
            "text": "Tizen           AGL\n                          ----------------------------------\nApp/OS isolation           yes            yes\nContainer option           no             possible\nNative App                 partial*       yes\nHTML5 App                  yes            yes\nCloud App                  No             yes\nUnified API (HTLM/Native)  No             yes\nservice as App**           No             yes\nAdding API    ***          core           core or App\nDevel model                bespoke        Standard Web", 
            "title": "Comparison/Relationship with Tizen"
        }, 
        {
            "location": "/developer/app-framework/binder/FAQ/", 
            "text": "Frequently Asked Question about AFB-DAEMON", 
            "title": "FAQ"
        }, 
        {
            "location": "/developer/app-framework/binder/FAQ/#frequently-asked-question-about-afb-daemon", 
            "text": "", 
            "title": "Frequently Asked Question about AFB-DAEMON"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/", 
            "text": "HOWTO WRITE an APPLICATION above AGL FRAMEWORK\n\n\nProgrammation Languages for Applications\n\n\nWriting an HTML5 application\n\n\nDevelopers of HTML5 applications (client side) can easily create\napplications for AGL framework using their preferred\nHTML5 framework.\n\n\nDevelopers may also take advantage of powerful server side plugins to improve\napplication behavior. Server side plugins return an application/json mine-type\nand can be accessed though either HTTP or Websockets.\n\n\nIn a near future, JSON-RPC protocol should be added to complete current x-afb-json1 protocol.\n\n\nTwo examples of HTML5 applications are given:\n\n\n\n\n\n\nafb-client\n a simple \"hello world\" application template\n\n\n\n\n\n\nafm-client\n a simple \"Home screen\" application template\n\n\n\n\n\n\nWriting a Qt application\n\n\nWriting Qt applications is also supported. Qt offers standard API to send request through HTTP or WebSockets.\n\n\nIt is also possible to write QML applications. A sample QML application [token-websock] is avaliable..\n\n\n\n\ntoken-websock\n\na simple \"hello world\" application in QML\n\n\n\n\nWriting \"C\" application\n\n\nC applications can use afb-daemon binder through a websocket connection.\n\n\nThe library \nlibafbwsc\n is provided for C clients that need\nto connect with an afb-daemon binder.\n\n\nThe program \nafb-client-demo\n is the C example that use\n\nlibafbwsc\n library.\nSource code is available here\n\nsrc/afb-client-demo.c\n.\n\n\nCurrent implementation relies on libsystemd and file descriptors.\nThis model might be review in the future to support secure sockets\nand free the dependency with libsystemd.\n\n\nHandling sessions within applications\n\n\nApplications should understand sessions and tokens management when interacting with afb-daemon binder.\n\n\nApplications are communicating with their private binder(afb-daemon) using\na network connection or potentially any other connection channel. While current version\ndoes not yet implement unix domain this feature might be added in a near future.\nDevelopers need to be warn that HTTP protocol is a none connected protocol. This prevents\nfrom using HTTP socket connection to authenticate clients.\n\n\nFor this reason, the binder should authenticate the application\nby using a shared secret. The secret is named \"token\" and the identification\nof client is named \"session\".\n\n\nThe examples \ntoken-websock.qml\n and \nafb-client\n are demonstrating\nhow authentication and sessions are managed.\n\n\nHandling sessions\n\n\nPlugins and other binder feature need to keep track of client\ninstances. This is especially important for plugins running as services\nas they may typically have to keep each client's data separated.\n\n\nFor HTML5 applications, the web runtime handles the cookie of session\nthat the binder afb-daemon automatically sets.\n\n\nSession identifier can be set using the parameter\n\nuuid\n or \nx-afb-uuid\n in URI requests. Within current version of the\nframework session UUID is supported by both HTTP requests and websocket negotiation.\n\n\nExchanging tokens\n\n\nAt application start, AGL framework communicates a shared secret to both binder\nand client application. This initial secret is called the \"initial token\".\n\n\nFor each of its client application, the binder manages a current active\ntoken for session management. This authentication token can be use to restrict\naccess to some plugin's methods.\n\n\nThe token must be included in URI request on HTTP or during websockets\nconnection using parameter \ntoken\n or \nx-afb-token\n.\n\n\nTo ensure security, tokens must be refreshed periodically.\n\n\nExample of session management\n\n\nIn following examples, we suppose that \nafb-daemon\n is launched with something equivalent to:\n\n\n$ afb-daemon --port=1234 --token=123456 [...]\n\n\n\nmaking the expectation that \nAuthLogin\n plugin is requested as default.\n\n\nUsing curl\n\n\nFirst, connects with the initial token, 123456:\n\n\n$ curl http://localhost:1234/api/auth/connect?token=123456\n{\n  \"jtype\": \"afb-reply\",\n  \"request\": {\n     \"status\": \"success\",\n     \"token\": \"0aef6841-2ddd-436d-b961-ae78da3b5c5f\",\n     \"uuid\": \"850c4594-1be1-4e9b-9fcc-38cc3e6ff015\"\n  },\n  \"response\": {\"token\": \"A New Token and Session Context Was Created\"}\n}\n\n\n\nIt returns an answer containing session UUID, 850c4594-1be1-4e9b-9fcc-38cc3e6ff015,\nand a refreshed token, 850c4594-1be1-4e9b-9fcc-38cc3e6ff015.\n\n\nCheck if session and token is valid:\n\n\n$ curl http://localhost:1234/api/auth/check?token=0aef6841-2ddd-436d-b961-ae78da3b5c5f\\\nuuid=850c4594-1be1-4e9b-9fcc-38cc3e6ff015\n{\n  \"jtype\": \"afb-reply\",\n  \"request\": {\"status\":\"success\"},\n  \"response\": {\"isvalid\":true}\n}\n\n\n\nRefresh the token:\n\n\n$ curl http://localhost:1234/api/auth/refresh?token=0aef6841-2ddd-436d-b961-ae78da3b5c5f\\\nuuid=850c4594-1be1-4e9b-9fcc-38cc3e6ff015\n{\n  \"jtype\": \"afb-reply\",\n  \"request\": {\n     \"status\":\"success\",\n     \"token\":\"b8ec3ec3-6ffe-448c-9a6c-efda69ad7bd9\"\n  },\n  \"response\": {\"token\":\"Token was refreshed\"}\n}\n\n\n\nClose the session:\n\n\ncurl http://localhost:1234/api/auth/logout?token=b8ec3ec3-6ffe-448c-9a6c-efda69ad7bd9\\\nuuid=850c4594-1be1-4e9b-9fcc-38cc3e6ff015\n{\n  \"jtype\": \"afb-reply\",\n  \"request\": {\"status\": \"success\"},\n  \"response\": {\"info\":\"Token and all resources are released\"}\n}\n\n\n\nChecking on closed session for uuid should be refused:\n\n\ncurl http://localhost:1234/api/auth/check?token=b8ec3ec3-6ffe-448c-9a6c-efda69ad7bd9\\\nuuid=850c4594-1be1-4e9b-9fcc-38cc3e6ff015\n{\n  \"jtype\": \"afb-reply\",\n  \"request\": {\n     \"status\": \"failed\",\n     \"info\": \"invalid token's identity\"\n  }\n}\n\n\n\nUsing afb-client-demo\n\n\n\n\nThe program is packaged within AGL in the rpm \nlibafbwsc-dev\n\n\n\n\nHere is an example of exchange using \nafb-client-demo\n:\n\n\n$ afb-client-demo ws://localhost:1234/api?token=123456\nauth connect\nON-REPLY 1:auth/connect: {\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\",\n   \"token\":\"63f71a29-8b52-4f9b-829f-b3028ba46b68\",\"uuid\":\"5fcc3f3d-4b84-4fc7-ba66-2d8bd34ae7d1\"},\n   \"response\":{\"token\":\"A New Token and Session Context Was Created\"}}\nauth check\nON-REPLY 2:auth/check: {\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\"},\"response\":{\"isvalid\":true}}\nauth refresh\nON-REPLY 4:auth/refresh: {\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\",\n   \"token\":\"8b8ba8f4-1b0c-48fa-962d-4a00a8c9157e\"},\"response\":{\"token\":\"Token was refreshed\"}}\nauth check\nON-REPLY 5:auth/check: {\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\"},\"response\":{\"isvalid\":true}}\nauth refresh\nON-REPLY 6:auth/refresh: {\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\",\n   \"token\":\"e83b36f8-d945-463d-b983-5d8ed73ba529\"},\"response\":{\"token\":\"Token was refreshed\"}}\n\n\n\nAfter closing connection, reconnect as here after:\n\n\n$ afb-client-demo ws://localhost:1234/api?token=e83b36f8-d945-463d-b983-5d8ed73ba529\\\nuuid=5fcc3f3d-4b84-4fc7-ba66-2d8bd34ae7d1 auth check\nON-REPLY 1:auth/check: {\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\"},\"response\":{\"isvalid\":true}}\n\n\n\nSame connection check using \ncurl\n:\n\n\n$ curl http://localhost:1234/api/auth/check?token=e83b36f8-d945-463d-b983-5d8ed73ba529\\\nuuid=5fcc3f3d-4b84-4fc7-ba66-2d8bd34ae7d1\n{\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\"},\"response\":{\"isvalid\":true}}\n\n\n\nFormat of replies\n\n\nReplies use javascript object returned as serialized JSON.\n\n\nThis object contains at least 2 mandatory fields of name \njtype\n and \nrequest\n\nand one optional field of name \nresponse\n.\n\n\nTemplate\n\n\nThis is a template of replies:\n\n\n{\n   \njtype\n: \nafb-reply\n,\n   \nrequest\n: {\n      \nstatus\n: \nsuccess\n,\n      \ninfo\n: \ninformationnal text\n,\n      \ntoken\n: \ne83b36f8-d945-463d-b983-5d8ed73ba52\n,\n      \nuuid\n: \n5fcc3f3d-4b84-4fc7-ba66-2d8bd34ae7d1\n,\n      \nreqid\n: \napplication-generated-id-23456\n\n   },\n   \nresponse\n: ....any response object....\n}\n\n\n\n\nField jtype\n\n\nThe field \njtype\n must have a value of type string equal to \n\"afb-reply\"\n.\n\n\nField request\n\n\nThe field \nrequest\n must have a value of type object. This request object\nhas at least one field named \nstatus\n and four optional fields named\n\ninfo\n, \ntoken\n, \nuuid\n, \nreqid\n.\n\n\nSubfield request.status\n\n\nstatus\n must have a value of type string. This string is equal to \n\"success\"\n\nonly in case of success.\n\n\nSubfield request.info\n\n\ninfo\n is of type string and represent optional information added to the reply.\n\n\nSubfield request.token\n\n\ntoken\n is of type string. It is sent either at session creation \nor when the token is refreshed.\n\n\nSubfield request.uuid\n\n\nuuid\n is of type string. It is sent at session creation.\n\n\nSubfield request.reqid\n\n\nreqid\n is of type string. It is sent in response to HTTP requests\nthat added a parameter of name \nreqid\n or \nx-afb-reqid\n at request time.\nValue returns in the reply has the exact same value as the one received in the request.\n\n\nField response\n\n\nThis field response optionally contains an object returned when request succeeded.\n\n\nFormat of events\n\n\nEvents are javascript object serialized as JSON.\n\n\nThis object contains at least 2 mandatory fields of name \njtype\n and \nevent\n\nand one optional field of name \ndata\n.\n\n\nTemplate\n\n\nHere is a template of event:\n\n\n{\n   \njtype\n: \nafb-event\n,\n   \nevent\n: \nsample_api_name/sample_event_name\n,\n   \ndata\n: ...any event data...\n}\n\n\n\n\nField jtype\n\n\nThe field \njtype\n must have a value of type string equal to \n\"afb-event\"\n.\n\n\nField event\n\n\nThe field \nevent\n carries the event's name.\n\n\nThe name of the event is made of two parts separated by a slash:\nthe name of the name of the API that generated the event\nand the name of event within the API.\n\n\nField data\n\n\nThis field data if present holds the data carried by the event.", 
            "title": "Afb application writing"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#howto-write-an-application-above-agl-framework", 
            "text": "", 
            "title": "HOWTO WRITE an APPLICATION above AGL FRAMEWORK"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#programmation-languages-for-applications", 
            "text": "", 
            "title": "Programmation Languages for Applications"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#writing-an-html5-application", 
            "text": "Developers of HTML5 applications (client side) can easily create\napplications for AGL framework using their preferred\nHTML5 framework.  Developers may also take advantage of powerful server side plugins to improve\napplication behavior. Server side plugins return an application/json mine-type\nand can be accessed though either HTTP or Websockets.  In a near future, JSON-RPC protocol should be added to complete current x-afb-json1 protocol.  Two examples of HTML5 applications are given:    afb-client  a simple \"hello world\" application template    afm-client  a simple \"Home screen\" application template", 
            "title": "Writing an HTML5 application"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#writing-a-qt-application", 
            "text": "Writing Qt applications is also supported. Qt offers standard API to send request through HTTP or WebSockets.  It is also possible to write QML applications. A sample QML application [token-websock] is avaliable..   token-websock \na simple \"hello world\" application in QML", 
            "title": "Writing a Qt application"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#writing-c-application", 
            "text": "C applications can use afb-daemon binder through a websocket connection.  The library  libafbwsc  is provided for C clients that need\nto connect with an afb-daemon binder.  The program  afb-client-demo  is the C example that use libafbwsc  library.\nSource code is available here src/afb-client-demo.c .  Current implementation relies on libsystemd and file descriptors.\nThis model might be review in the future to support secure sockets\nand free the dependency with libsystemd.", 
            "title": "Writing \"C\" application"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#handling-sessions-within-applications", 
            "text": "Applications should understand sessions and tokens management when interacting with afb-daemon binder.  Applications are communicating with their private binder(afb-daemon) using\na network connection or potentially any other connection channel. While current version\ndoes not yet implement unix domain this feature might be added in a near future.\nDevelopers need to be warn that HTTP protocol is a none connected protocol. This prevents\nfrom using HTTP socket connection to authenticate clients.  For this reason, the binder should authenticate the application\nby using a shared secret. The secret is named \"token\" and the identification\nof client is named \"session\".  The examples  token-websock.qml  and  afb-client  are demonstrating\nhow authentication and sessions are managed.", 
            "title": "Handling sessions within applications"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#handling-sessions", 
            "text": "Plugins and other binder feature need to keep track of client\ninstances. This is especially important for plugins running as services\nas they may typically have to keep each client's data separated.  For HTML5 applications, the web runtime handles the cookie of session\nthat the binder afb-daemon automatically sets.  Session identifier can be set using the parameter uuid  or  x-afb-uuid  in URI requests. Within current version of the\nframework session UUID is supported by both HTTP requests and websocket negotiation.", 
            "title": "Handling sessions"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#exchanging-tokens", 
            "text": "At application start, AGL framework communicates a shared secret to both binder\nand client application. This initial secret is called the \"initial token\".  For each of its client application, the binder manages a current active\ntoken for session management. This authentication token can be use to restrict\naccess to some plugin's methods.  The token must be included in URI request on HTTP or during websockets\nconnection using parameter  token  or  x-afb-token .  To ensure security, tokens must be refreshed periodically.", 
            "title": "Exchanging tokens"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#example-of-session-management", 
            "text": "In following examples, we suppose that  afb-daemon  is launched with something equivalent to:  $ afb-daemon --port=1234 --token=123456 [...]  making the expectation that  AuthLogin  plugin is requested as default.", 
            "title": "Example of session management"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#using-curl", 
            "text": "First, connects with the initial token, 123456:  $ curl http://localhost:1234/api/auth/connect?token=123456\n{\n  \"jtype\": \"afb-reply\",\n  \"request\": {\n     \"status\": \"success\",\n     \"token\": \"0aef6841-2ddd-436d-b961-ae78da3b5c5f\",\n     \"uuid\": \"850c4594-1be1-4e9b-9fcc-38cc3e6ff015\"\n  },\n  \"response\": {\"token\": \"A New Token and Session Context Was Created\"}\n}  It returns an answer containing session UUID, 850c4594-1be1-4e9b-9fcc-38cc3e6ff015,\nand a refreshed token, 850c4594-1be1-4e9b-9fcc-38cc3e6ff015.  Check if session and token is valid:  $ curl http://localhost:1234/api/auth/check?token=0aef6841-2ddd-436d-b961-ae78da3b5c5f\\ uuid=850c4594-1be1-4e9b-9fcc-38cc3e6ff015\n{\n  \"jtype\": \"afb-reply\",\n  \"request\": {\"status\":\"success\"},\n  \"response\": {\"isvalid\":true}\n}  Refresh the token:  $ curl http://localhost:1234/api/auth/refresh?token=0aef6841-2ddd-436d-b961-ae78da3b5c5f\\ uuid=850c4594-1be1-4e9b-9fcc-38cc3e6ff015\n{\n  \"jtype\": \"afb-reply\",\n  \"request\": {\n     \"status\":\"success\",\n     \"token\":\"b8ec3ec3-6ffe-448c-9a6c-efda69ad7bd9\"\n  },\n  \"response\": {\"token\":\"Token was refreshed\"}\n}  Close the session:  curl http://localhost:1234/api/auth/logout?token=b8ec3ec3-6ffe-448c-9a6c-efda69ad7bd9\\ uuid=850c4594-1be1-4e9b-9fcc-38cc3e6ff015\n{\n  \"jtype\": \"afb-reply\",\n  \"request\": {\"status\": \"success\"},\n  \"response\": {\"info\":\"Token and all resources are released\"}\n}  Checking on closed session for uuid should be refused:  curl http://localhost:1234/api/auth/check?token=b8ec3ec3-6ffe-448c-9a6c-efda69ad7bd9\\ uuid=850c4594-1be1-4e9b-9fcc-38cc3e6ff015\n{\n  \"jtype\": \"afb-reply\",\n  \"request\": {\n     \"status\": \"failed\",\n     \"info\": \"invalid token's identity\"\n  }\n}", 
            "title": "Using curl"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#using-afb-client-demo", 
            "text": "The program is packaged within AGL in the rpm  libafbwsc-dev   Here is an example of exchange using  afb-client-demo :  $ afb-client-demo ws://localhost:1234/api?token=123456\nauth connect\nON-REPLY 1:auth/connect: {\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\",\n   \"token\":\"63f71a29-8b52-4f9b-829f-b3028ba46b68\",\"uuid\":\"5fcc3f3d-4b84-4fc7-ba66-2d8bd34ae7d1\"},\n   \"response\":{\"token\":\"A New Token and Session Context Was Created\"}}\nauth check\nON-REPLY 2:auth/check: {\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\"},\"response\":{\"isvalid\":true}}\nauth refresh\nON-REPLY 4:auth/refresh: {\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\",\n   \"token\":\"8b8ba8f4-1b0c-48fa-962d-4a00a8c9157e\"},\"response\":{\"token\":\"Token was refreshed\"}}\nauth check\nON-REPLY 5:auth/check: {\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\"},\"response\":{\"isvalid\":true}}\nauth refresh\nON-REPLY 6:auth/refresh: {\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\",\n   \"token\":\"e83b36f8-d945-463d-b983-5d8ed73ba529\"},\"response\":{\"token\":\"Token was refreshed\"}}  After closing connection, reconnect as here after:  $ afb-client-demo ws://localhost:1234/api?token=e83b36f8-d945-463d-b983-5d8ed73ba529\\ uuid=5fcc3f3d-4b84-4fc7-ba66-2d8bd34ae7d1 auth check\nON-REPLY 1:auth/check: {\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\"},\"response\":{\"isvalid\":true}}  Same connection check using  curl :  $ curl http://localhost:1234/api/auth/check?token=e83b36f8-d945-463d-b983-5d8ed73ba529\\ uuid=5fcc3f3d-4b84-4fc7-ba66-2d8bd34ae7d1\n{\"jtype\":\"afb-reply\",\"request\":{\"status\":\"success\"},\"response\":{\"isvalid\":true}}", 
            "title": "Using afb-client-demo"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#format-of-replies", 
            "text": "Replies use javascript object returned as serialized JSON.  This object contains at least 2 mandatory fields of name  jtype  and  request \nand one optional field of name  response .", 
            "title": "Format of replies"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#template", 
            "text": "This is a template of replies:  {\n    jtype :  afb-reply ,\n    request : {\n       status :  success ,\n       info :  informationnal text ,\n       token :  e83b36f8-d945-463d-b983-5d8ed73ba52 ,\n       uuid :  5fcc3f3d-4b84-4fc7-ba66-2d8bd34ae7d1 ,\n       reqid :  application-generated-id-23456 \n   },\n    response : ....any response object....\n}", 
            "title": "Template"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#field-jtype", 
            "text": "The field  jtype  must have a value of type string equal to  \"afb-reply\" .", 
            "title": "Field jtype"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#field-request", 
            "text": "The field  request  must have a value of type object. This request object\nhas at least one field named  status  and four optional fields named info ,  token ,  uuid ,  reqid .", 
            "title": "Field request"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#subfield-requeststatus", 
            "text": "status  must have a value of type string. This string is equal to  \"success\" \nonly in case of success.", 
            "title": "Subfield request.status"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#subfield-requestinfo", 
            "text": "info  is of type string and represent optional information added to the reply.", 
            "title": "Subfield request.info"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#subfield-requesttoken", 
            "text": "token  is of type string. It is sent either at session creation \nor when the token is refreshed.", 
            "title": "Subfield request.token"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#subfield-requestuuid", 
            "text": "uuid  is of type string. It is sent at session creation.", 
            "title": "Subfield request.uuid"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#subfield-requestreqid", 
            "text": "reqid  is of type string. It is sent in response to HTTP requests\nthat added a parameter of name  reqid  or  x-afb-reqid  at request time.\nValue returns in the reply has the exact same value as the one received in the request.", 
            "title": "Subfield request.reqid"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#field-response", 
            "text": "This field response optionally contains an object returned when request succeeded.", 
            "title": "Field response"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#format-of-events", 
            "text": "Events are javascript object serialized as JSON.  This object contains at least 2 mandatory fields of name  jtype  and  event \nand one optional field of name  data .", 
            "title": "Format of events"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#template_1", 
            "text": "Here is a template of event:  {\n    jtype :  afb-event ,\n    event :  sample_api_name/sample_event_name ,\n    data : ...any event data...\n}", 
            "title": "Template"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#field-jtype_1", 
            "text": "The field  jtype  must have a value of type string equal to  \"afb-event\" .", 
            "title": "Field jtype"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#field-event", 
            "text": "The field  event  carries the event's name.  The name of the event is made of two parts separated by a slash:\nthe name of the name of the API that generated the event\nand the name of event within the API.", 
            "title": "Field event"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-application-writing/#field-data", 
            "text": "This field data if present holds the data carried by the event.", 
            "title": "Field data"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-overview/", 
            "text": "Overview of bindings shipped with AFB-Daemon\n\n\nList of bindings\n\n\nHere are the bindings shipped in the source tree:\n\n\n\n\nHello World\n\n\nAuthentication\n\n\nTic Tac Toe\n\n\nAudio \n(2 backends: ALSA/PulseAudio)\n\n\nRadio \n(1 backend: RTLSDR RTL2832U)\n\n\nMedia \n(1 backend: Rygel UPnP)\n\n\n\n\nAll bindings may not be built, depending on the development libraries present on the system at build time.\n\n\nDetail of bindings\n\n\nHello World\n\n\nA sample Hello World binding for demonstration and learning purposes.\n\n\nThis binding provides a few unauthenticated requests, all beginning with \"ping\", to demonstrate basic binder capabilities.\n\n\nVerbs\n:\n\n\n\n\nping:\n returns a success response\n\n\npingfail:\n returns a failure response\n\n\npingnull:\n returns a success response, with an empty JSON response field\n\n\npingbug:\n does a memory violation (intercepted by the binder)\n\n\npingJson:\n returns a success response, with a complex JSON response field\n\n\npingevent:\n broadcasts a global event\n\n\n\n\n\n\nAuthentication\n\n\nAn sample Authentication binding for demonstration purposes.\n\n\nThis binding provides a few requests to demonstrate the binder's token-based security mechanism.\n\n\nCalling \"\nconnect\n\" with a security token will initiate a session, calling \"\nrefresh\n\" will issue a new token and invalidate the previous one, calling \"\nlogout\n\" will invalidate all tokens and close the session.\n\n\nVerbs\n:\n\n\n\n\nping:\n returns a success response\n\n\nconnect:\n creates a session and returns a new token\n\n\nrefresh:\n returns a new token\n\n\ncheck:\n verifies the passed token is valid\n\n\nlogout:\n closes the session\n\n\n\n\n\n\nTic Tac Toe\n\n\nA sample Tic Tac Toe game binding.\n\n\nThis binding provides an interactive Tic Tac Toe game where the binder returns the grid as a JSON response. \n\n\nVerbs\n:\n\n\n\n\nnew:\n starts a new game\n\n\nplay:\n asks the server to play\n\n\nmove:\n gives a client move\n\n\nboard:\n gets the current board state, as a JSON structure\n\n\nlevel\n: sets the server level\n\n\njoin\n: joins an existing board\n\n\nundo\n: undo the last move\n\n\nwait\n: wait for a move\n\n\n\n\n\n\nAudio\n\n\nA sample Audio binding with 2 backends:\n\n\n\n\nALSA (mandatory)\n\n\nPulseAudio (optional)\n\n\n\n\nThis binding is able to initialize a specific soundcard, define volume levels, channels (mono/stereo...), mute sound, and play a 22,050 Hz PCM stream.\n\n\nVerbs\n:\n\n\n\n\nping:\n returns a success response\n\n\ninit:\n initializes backend, on the \"default\" sound card\n\n\nvolume:\n gets or sets volume, in % (0-100)\n\n\nchannels:\n gets or sets channels count (1-8)\n\n\nmute:\n gets or sets the mute status (on-off)\n\n\nplay\n: gets or sets the playing status (on-off)\n\n\n\n\n(if PulseAudio development libraries are not found at build time, only ALSA will be available)\n\n\n(if a PulseAudio server is not found at runtime, the binding will dynamically fall back to ALSA)\n\n\n(a specifc backend can be forced by using this syntax before running afb-daemon : \n$ export AFB_AUDIO_OUTPUT=Alsa\n)\n\n\n\n\nRadio\n\n\nA sample AM/FM Radio binding with 1 backend:\n\n\n\n\nRTLSDR - Realtek RTL2832U dongles (mandatory)\n\n\n\n\nThis binding is able to initialize specific RTL2832U dongles, switch between AM/FM modes, define frequency, mute sound, and play sound (if combining with the \naudio\n binding).\n\n\nVerbs\n:\n\n\n\n\nping:\n returns a success response\n\n\ninit:\n initializes backend, looking for plugged-in devices\n\n\npower:\n sets device power status (on-off)\n\n\nmode:\n sets device reception mode (AM-FM)\n\n\nfreq:\n sets device frequency (in Hz)\n\n\nmute\n: sets device mute status (on-off)\n\n\nplay\n: sets device playing status (on-off)\n\n\n\n\n(if rtlsdr development libraries are not found at build time, this binding will not be built)\n\n\n\n\nMedia\n\n\nA sample Media Server binding with 1 backend:\n\n\n\n\nRygel\n\n\n\n\nThis binding is able to detect a local Rygel UPnP media server, list audio files, select an audio file for playback, play/pause/seek in this file, upload an audio file to the server.\n\n\nVerbs\n:\n\n\n\n\nping:\n returns a success response\n\n\ninit:\n initializes backend, looking for an active local UPnP server\n\n\nlist:\n returns list of audio files, as a JSON structure\n\n\nselect:\n select an audio files, by index number (001-...)\n\n\nplay:\n plays the currently selected audio file\n\n\nstop:\n stops the currently selected audio file\n\n\npause:\n pauses the currently selected audio file\n\n\nseek:\n seeks in the currently selected audio file, in seconds\n\n\nupload:\n uploads an audio file, with a POST request\n\n\n\n\n(if GUPnP/GSSDP development libraries are not fund at build time, this binding will not be built)\n\n\n\n\n\n\n\n\nSample command-line applications: \nafb-client-demo\n (built by default)\n\n\nSample HTML5 applications: \n\ntest/*.html\n, \n\nafb-client\n, \n\nafb-radio\n\n\nSample Qt/QML applications: \ntest/token-websock.qml", 
            "title": "Afb bindings overview"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-overview/#overview-of-bindings-shipped-with-afb-daemon", 
            "text": "", 
            "title": "Overview of bindings shipped with AFB-Daemon"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-overview/#list-of-bindings", 
            "text": "Here are the bindings shipped in the source tree:   Hello World  Authentication  Tic Tac Toe  Audio  (2 backends: ALSA/PulseAudio)  Radio  (1 backend: RTLSDR RTL2832U)  Media  (1 backend: Rygel UPnP)   All bindings may not be built, depending on the development libraries present on the system at build time.", 
            "title": "List of bindings"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-overview/#detail-of-bindings", 
            "text": "", 
            "title": "Detail of bindings"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-overview/#hello-world", 
            "text": "A sample Hello World binding for demonstration and learning purposes.  This binding provides a few unauthenticated requests, all beginning with \"ping\", to demonstrate basic binder capabilities.  Verbs :   ping:  returns a success response  pingfail:  returns a failure response  pingnull:  returns a success response, with an empty JSON response field  pingbug:  does a memory violation (intercepted by the binder)  pingJson:  returns a success response, with a complex JSON response field  pingevent:  broadcasts a global event", 
            "title": "Hello World"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-overview/#authentication", 
            "text": "An sample Authentication binding for demonstration purposes.  This binding provides a few requests to demonstrate the binder's token-based security mechanism.  Calling \" connect \" with a security token will initiate a session, calling \" refresh \" will issue a new token and invalidate the previous one, calling \" logout \" will invalidate all tokens and close the session.  Verbs :   ping:  returns a success response  connect:  creates a session and returns a new token  refresh:  returns a new token  check:  verifies the passed token is valid  logout:  closes the session", 
            "title": "Authentication"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-overview/#tic-tac-toe", 
            "text": "A sample Tic Tac Toe game binding.  This binding provides an interactive Tic Tac Toe game where the binder returns the grid as a JSON response.   Verbs :   new:  starts a new game  play:  asks the server to play  move:  gives a client move  board:  gets the current board state, as a JSON structure  level : sets the server level  join : joins an existing board  undo : undo the last move  wait : wait for a move", 
            "title": "Tic Tac Toe"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-overview/#audio", 
            "text": "A sample Audio binding with 2 backends:   ALSA (mandatory)  PulseAudio (optional)   This binding is able to initialize a specific soundcard, define volume levels, channels (mono/stereo...), mute sound, and play a 22,050 Hz PCM stream.  Verbs :   ping:  returns a success response  init:  initializes backend, on the \"default\" sound card  volume:  gets or sets volume, in % (0-100)  channels:  gets or sets channels count (1-8)  mute:  gets or sets the mute status (on-off)  play : gets or sets the playing status (on-off)   (if PulseAudio development libraries are not found at build time, only ALSA will be available)  (if a PulseAudio server is not found at runtime, the binding will dynamically fall back to ALSA)  (a specifc backend can be forced by using this syntax before running afb-daemon :  $ export AFB_AUDIO_OUTPUT=Alsa )", 
            "title": "Audio"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-overview/#radio", 
            "text": "A sample AM/FM Radio binding with 1 backend:   RTLSDR - Realtek RTL2832U dongles (mandatory)   This binding is able to initialize specific RTL2832U dongles, switch between AM/FM modes, define frequency, mute sound, and play sound (if combining with the  audio  binding).  Verbs :   ping:  returns a success response  init:  initializes backend, looking for plugged-in devices  power:  sets device power status (on-off)  mode:  sets device reception mode (AM-FM)  freq:  sets device frequency (in Hz)  mute : sets device mute status (on-off)  play : sets device playing status (on-off)   (if rtlsdr development libraries are not found at build time, this binding will not be built)", 
            "title": "Radio"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-overview/#media", 
            "text": "A sample Media Server binding with 1 backend:   Rygel   This binding is able to detect a local Rygel UPnP media server, list audio files, select an audio file for playback, play/pause/seek in this file, upload an audio file to the server.  Verbs :   ping:  returns a success response  init:  initializes backend, looking for an active local UPnP server  list:  returns list of audio files, as a JSON structure  select:  select an audio files, by index number (001-...)  play:  plays the currently selected audio file  stop:  stops the currently selected audio file  pause:  pauses the currently selected audio file  seek:  seeks in the currently selected audio file, in seconds  upload:  uploads an audio file, with a POST request   (if GUPnP/GSSDP development libraries are not fund at build time, this binding will not be built)     Sample command-line applications:  afb-client-demo  (built by default)  Sample HTML5 applications:  test/*.html ,  afb-client ,  afb-radio  Sample Qt/QML applications:  test/token-websock.qml", 
            "title": "Media"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/", 
            "text": "HOWTO WRITE a BINDING for AFB-DAEMON\n\n\nSummary\n\n\nAfb-daemon binders serve files through HTTP protocol\nand offers to developers the capability to expose application API methods through\nHTTP or WebSocket protocol.\n\n\nBinder bindings are used to add API to afb-daemon.\nThis part describes how to write a binding for afb-daemon.\n\n\nExcepting this summary, this document target developers.\n\n\nBefore moving further through an example, here after\na short overview of binder bindings fundamentals.\n\n\nNature of a binding\n\n\nA binding is an independent piece of software. A binding is self contain and exposes application logic as sharable library.\nA binding is intended to be dynamically loaded by afb-daemon to expose application API.\n\n\nTechnically, a binder binding does not reference and is not linked with any afb-daemon library.\n\n\nClass of bindings\n\n\nApplication binder supports two kinds of bindings: application bindings and service bindings.\nTechnically both class of binding are equivalent are use the same coding convention. Only sharing mode and security context diverge.\n\n\nApplication-bindings\n\n\nApplication-bindings implements the glue in between application's UI and services. Every AGL application\nhas a corresponding binder that typically activates one or many bindings to interface the application logic with lower platform services.\nWhen an application is started by the AGL application framework, a dedicate binder is started that loads/activates application binding(s). \nAPI expose by application-binding are executed within corresponding application security context.\n\n\nApplication bindings generally handle a unique context for a unique client. As the application framework start\na dedicated instance of afb_daemon for each AGL application, if a given binding is used within multiple application each of those\napplication get a new and private instance of eventually \"shared\" binding.\n\n\nService-bindings\n\n\nService-bindings enable API activation within corresponding service security context and not within calling application context. \nService-bindings are intended to run as a unique instance. Service-bindings can be shared in between multiple clients.\n\n\nService-bindings can either be stateless or manage client context. When managing context each client get a private context.\n\n\nSharing may either be global to the platform (ie: GPS service) or dedicated to a given user (ie: user preferences)\n\n\nLive cycle of bindings within afb-daemon\n\n\nApplication and service bindings are loaded and activated each time a new afb-daemon is started.\n\n\nAt launch time, every loaded binding initialise itself.\nIf a single binding initialisation fail corresponding instance of afb-daemon self aborts.\n\n\nConversely, when a binding initialisation succeeds, it should register \nits unique name as well as the list of verbs attached to the methods it exposes.\n\n\nWhen initialised, on request from application clients to the right API/verb, binding methods\nare activated by the afb-daemon attached to the application or service.\n\n\nAt exit time, no special action is enforced by afb-daemon. When a specific actions is required at afb-daemon stop,\ndevelopers should use 'atexit/on_exit' during binding initialisation sequence to register a custom exit function.\n\n\nBinding Contend\n\n\nAfb-daemon's binding register two classes of objects: names and functions.\n\n\nBindings declare categories of names:\n - A unique binding name to access all API expose by this binding,\n - One name for each methods/verbs provided by this binding.\n\n\nBindings declare two categories of functions:\n - function use for the initialisation\n - functions implementing exposed API methods\n\n\nAfb-daemon parses URI requests to extract the API(binding name) and the VERB(method to activate).\nAs an example, URI \nfoo/bar\n translates to binding named \nfoo\n and method named \nbar\n.\nTo serve such a request, afb-daemon looks for an active binding named \nfoo\n and then within this binding for a method named \nbar\n.\nWhen find afb-daemon calls corresponding method with attached parameter if any.\n\n\nAfb-daemon ignores letter case when parsing URI. Thus \nTicTacToe/Board\n and \ntictactoe/board\n are equivalent.\n\n\nThe name of the binding\n\n\nThe name of a given binding is also known as the name\nof the API prefix that defines the binding.\n\n\nThe name of a binding SHOULD be unique within a given afb-daemon instance.\n\n\nFor example, when a client of afb-daemon calls a URI named \nfoo/bar\n. Afb-daemon\nextracts the prefix \nfoo\n and the suffix \nbar\n. \nfoo\n must match a binding name and \nbar\n a VERB attached to some method.\n\n\nNames of methods\n\n\nEach binding exposes a set of methods that can be called\nby the clients of a given afb-daemon.\n\n\nVERB's name attached to a given binding (API) MUST be unique within a binding.\n\n\nBindings static declaration link VERBS to corresponding methods. \nWhen clients emit requests on a given API/VERB corresponding method is called by afb-daemon.\n\n\nInitialisation function\n\n\nBinding's initialisation function serves several purposes.\n\n\n\n\n\n\nIt allows afb-daemon to control binding version depending on initialisation function name.\nAs today, the only supported initialisation function is \nafbBindingV1Register\n. This identifies\nversion \"one\" of bindings.\n\n\n\n\n\n\nIt allows bindings to initialise itself.\n\n\n\n\n\n\nIt enables names declarations: descriptions, requirements and implementations of exposed API/VERB.\n\n\n\n\n\n\nFunctions instantiation of API/VERBs\n\n\nWhen an API/VERB is called, afb-daemon constructs a request object. Then it \npasses this request object to the implementation function corresponding to requested method, this\nwithin attached API binding.\n\n\nAn implementation function receives a request object that\nis used to: get arguments of the request, send\nanswer, store session data.\n\n\nA binding MUST set an answer to every received requests.\n\n\nNevertheless it is not mandatory to set the answer\nbefore returning from API/VERB implementing function.\nThis behaviour is important for asynchronous actions.\n\n\nAPI/VERB implementation that set an answer before returning are called \nsynchronous implementations\n.\nThose that do not systematically set an answer before returning are called \nasynchronous implementations\n.\n\n\nAsynchronous implementations typically launch asynchronous actions. They record some context at\nrequest time and provide answer to the request only at completion of asynchronous actions.\n\n\nThe Tic-Tac-Toe example\n\n\nThis part explains how to write an afb-binding.\nFor the sake of being practical it uses many\nexamples based on tic-tac-toe.\nThis binding example is in \nbindings/samples/tic-tac-toe.c\n.\n\n\nThis binding is named \ntictactoe\n.\n\n\nDependencies when compiling\n\n\nAfb-daemon provides a configuration file for \npkg-config\n.\nTyping the command\n\n\npkg-config --cflags afb-daemon\n\n\n\nPrint flags use for compilation:\n\n\n$ pkg-config --cflags afb-daemon\n-I/opt/local/include -I/usr/include/json-c\n\n\n\nFor linking, you should use\n\n\n$ pkg-config --libs afb-daemon\n-ljson-c\n\n\n\nAfb-daemon automatically includes dependency to json-c.\nThis is activated through \nRequires\n keyword in pkg-config.\nWhile almost every binding replies on \njson-c\n this is not a must have dependency.\n\n\nInternally, afb-daemon relies on \nlibsystemd\n for its event loop, as well \nas for its binding to D-Bus.\nBindings developers are encouraged to leverage \nlibsystemd\n when possible.\nNevertheless there is no hard dependency to \nlibsystemd\n if ever\nyou rather not use it, feel free to do so.\n\n\n\n\nAfb-daemon binding are fully self contain. They do not enforce dependency on any libraries from the application framework.\nAfb-daemon dependencies requirer to run AGL bindings are given at runtime through pointers leveraging read-only\nmemory feature.\n\n\n\n\nHeader files to include\n\n\nBinding \ntictactoe\n has following includes:\n\n\n#define _GNU_SOURCE\n#include \nstdio.h\n\n#include \nstring.h\n\n#include \njson-c/json.h\n\n#include \nafb/afb-binding.h\n\n\n\n\n\nHeader \nafb/afb-binding.h\n is the only hard dependency, it includes all features\nthat a binding MUST HAVE. Outside of includes used to support application logic,\ncommon external headers used within bindings are:\n\n\n\n\njson-c/json.h\n: should be include to handle json objects;\n\n\nsystemd/sd-event.h\n: should be include to access event main loop;\n\n\nsystemd/sd-bus.h\n: should be include for dbus connections.\n\n\n\n\nThe \ntictactoe\n binding does not leverage systemd features, also only json.h\nis used on top of mandatory afb/afb-binding.h.\n\n\nWhen including \nafb/afb-binding.h\n, the macro \n_GNU_SOURCE\n MUST be\ndefined.\n\n\nChoosing names\n\n\nDesigners of bindings should define a unique name for every API binding\nas well as for methods VERBs. They should also define names for request\narguments passed as name/value pair in URI.\n\n\nWhile forging names, designers should respect few rules to\nensure that created names are valid and easy to use across platforms.\n\n\nAll names and strings are UTF-8 encoded.\n\n\nNames for API (binding)\n\n\nBinding API name are checked.\nAll characters are authorised except:\n\n\n\n\nthe control characters (\\u0000 .. \\u001f)\n\n\nthe characters of the set { ' ', '\"', '#', '%', '\n',\n  '\\'', '/', '?', '`', '\\x7f' }\n\n\n\n\nIn other words the set of forbidden characters is\n{ \\u0000..\\u0020, \\u0022, \\u0023, \\u0025..\\u0027,\n  \\u002f, \\u003f, \\u0060, \\u007f }.\n\n\nAfb-daemon makes no distinction between lower case\nand upper case when searching for API/VERB.\n\n\nNames for methods\n\n\nThe names of methods VERBs are totally free and not checked.\n\n\nHowever, the validity rules for method's VERB name are the\nsame as for Binding API name except that the dot(.) character\nis forbidden.\n\n\nAfb-daemon makes no case distinction when searching for an API by name.\n\n\nNames for arguments\n\n\nArgument's name are not restricted and can be everything you wish.\n\n\n\n\nWarning arguments search is case sensitive and \"index\" and \"Index\"\nare not two different arguments.\n\n\n\n\nForging names widely available\n\n\nThe key names of javascript object can be almost\nanything using the arrayed notation:\n\n\nobject[key] = value\n\n\n\nNevertheless this is not the case with javascript dot notation:\n\n\nobject.key = value\n\n\n\nUsing the dot notation, the key must be a valid javascript\nidentifier and dash(-) as well as few other reserved characters cannot be used.\n\n\nFor this reason, we advise developper to chose name compatible with both javascript and HTML notation.\n\n\nIt is a good practice, even for arguments not to rely on case sensitivity.\nThis may reduce headache strength at debug time, especially with interpreted language like\njavascript that may not warn you that a variable was not defined.\n\n\nWriting a synchronous method implementation\n\n\nThe method \ntictactoe/board\n is a synchronous implementation.\nHere is its listing:\n\n\n/*\n * get the board\n */\nstatic void board(struct afb_req req)\n{\n    struct board *board;\n    struct json_object *description;\n\n    /* retrieves the context for the session */\n    board = board_of_req(req);\n    INFO(afbitf, \nmethod 'board' called for boardid %d\n, board-\nid);\n\n    /* describe the board */\n    description = describe(board);\n\n    /* send the board's description */\n    afb_req_success(req, description, NULL);\n}\n\n\n\n\nThis example shows many aspects of a synchronous\nmethod implementation. Let summarise it:\n\n\n\n\n\n\nThe function \nboard_of_req\n retrieves the context stored\nfor the binding: the board.\n\n\n\n\n\n\nThe macro \nINFO\n sends a message of kind \nINFO\n\nto the logging system. The global variable named \nafbitf\n\nused represents the interface to afb-daemon.\n\n\n\n\n\n\nThe function \ndescribe\n creates a json_object representing\nthe board.\n\n\n\n\n\n\nThe function \nafb_req_success\n sends the reply, attaching to\nit the object \ndescription\n.\n\n\n\n\n\n\nThe incoming request\n\n\nFor any implementation, the request is received by a structure of type\n\nstruct afb_req\n.\n\n\n\n\nNote that this is a PLAIN structure, not a pointer to a structure.\n\n\n\n\nThe definition of \nstruct afb_req\n is:\n\n\n/*\n * Describes the request by bindings from afb-daemon\n */\nstruct afb_req {\n    const struct afb_req_itf *itf;  /* the interfacing functions */\n    void *closure;          /* the closure for functions */\n};\n\n\n\n\nIt contains two pointers: first one \nitf\n, points to functions used\nto handle internal request. Second one \nclosure\n point onto function closure. \n\n\n\n\nThe structure must never be used directly.\nInstead developer should use the intended functions provided\nby afb-daemon as described here after.\n\n\n\n\nreq\n is used to get arguments of the request, to send\nanswer, to store session data.\n\n\nThis object and its interface is defined and documented\nin the file names \nafb/afb-req-itf.h\n\n\nThe above example uses twice \nreq\n object request.\n\n\nThe first time, to retrieve the board attached to the session of the request.\n\n\nThe second time, to send the reply: an object that describes the current board.\n\n\nAssociating a client context to a session\n\n\nWhen \ntic-tac-toe\n binding receives a request, it musts get\nthe board describing the game associated to the session.\n\n\nFor a binding, having data associated to a session is common.\nThis data is called \"binding context\" for the session.\nWithin \ntic-tac-toe\n binding the context is the board.\n\n\nRequests \nafb_req\n offer four functions for storing and retrieving session associated context.\n\n\nThese functions are:\n\n\n\n\n\n\nafb_req_context_get\n:\n  retrieves context data stored for current binding.\n\n\n\n\n\n\nafb_req_context_set\n:\n  store context data of current binding.\n\n\n\n\n\n\nafb_req_context\n:\n  if exist retrieves context data of current binding.\n  if context does not yet exist, creates a new context and store it.\n\n\n\n\n\n\nafb_req_context_clear\n:\n  reset the stored context data.\n\n\n\n\n\n\nThe binding \ntictactoe\n use a convenient function to retrieve\nits context: the board. This function is \nboard_of_req\n:\n\n\n/*\n * retrieves the board of the request\n */\nstatic inline struct board *board_of_req(struct afb_req req)\n{\n    return afb_req_context(req, (void*)get_new_board, (void*)release_board);\n}\n\n\n\n\nThe function \nafb_req_context\n ensures an existing context\nfor the session of the request.\nIts two last arguments are functions to allocate and free context. \nNote function type casts to avoid compilation warnings.\n\n\nHere is the definition of the function \nafb_req_context\n\n\n/*\n * Gets the pointer stored by the binding for the session of 'req'.\n * If the stored pointer is NULL, indicating that no pointer was\n * already stored, afb_req_context creates a new context by calling\n * the function 'create_context' and stores it with the freeing function\n * 'free_context'.\n */\nstatic inline void *afb_req_context(struct afb_req req, void *(*create_context)(), void (*free_context)(void*))\n{\n    void *result = afb_req_context_get(req);\n    if (result == NULL) {\n        result = create_context();\n        afb_req_context_set(req, result, free_context);\n    }\n    return result;\n}\n\n\n\n\nThe second argument if the function that creates the context.\nFor binding \ntic-tac-toe\n (function \nget_new_board\n).\nThe function \nget_new_board\n creates a new board and set usage its count to 1.\nThe boards are checking usage count to free resources when not used.\n\n\nThe third argument is a function that frees context resources.\nFor binding \ntic-tac-toe\n (function \nrelease_board\n).\nThe function \nrelease_board\n decrease usage count of the board passed in argument.\nWhen usage count falls to zero, data board are freed.\n\n\nDefinition of other functions dealing with contexts:\n\n\n/*\n * Gets the pointer stored by the binding for the session of 'req'.\n * When the binding has not yet recorded a pointer, NULL is returned.\n */\nvoid *afb_req_context_get(struct afb_req req);\n\n/*\n * Stores for the binding the pointer 'context' to the session of 'req'.\n * The function 'free_context' will be called when the session is closed\n * or if binding stores an other pointer.\n */\nvoid afb_req_context_set(struct afb_req req, void *context, void (*free_context)(void*));\n\n/*\n * Frees the pointer stored by the binding for the session of 'req'\n * and sets it to NULL.\n *\n * Shortcut for: afb_req_context_set(req, NULL, NULL)\n */\nstatic inline void afb_req_context_clear(struct afb_req req)\n{\n    afb_req_context_set(req, NULL, NULL);\n}\n\n\n\n\nSending reply to a request\n\n\nTwo kinds of replies: successful or failure.\n\n\n\n\nSending a reply to a request MUST be done once and only once.\n\n\n\n\nIt exists two functions for \"success\" replies: \nafb_req_success\n and \nafb_req_success_f\n.\n\n\n/*\n * Sends a reply of kind success to the request 'req'.\n * The status of the reply is automatically set to \nsuccess\n.\n * Its send the object 'obj' (can be NULL) with an\n * informationnal comment 'info (can also be NULL).\n *\n * For convenience, the function calls 'json_object_put' for 'obj'.\n * Thus, in the case where 'obj' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n */\nvoid afb_req_success(struct afb_req req, struct json_object *obj, const char *info);\n\n/*\n * Same as 'afb_req_success' but the 'info' is a formatting\n * string followed by arguments.\n *\n * For convenience, the function calls 'json_object_put' for 'obj'.\n * Thus, in the case where 'obj' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n */\nvoid afb_req_success_f(struct afb_req req, struct json_object *obj, const char *info, ...);\n\n\n\n\nIt exists two functions for \"failure\" replies: \nafb_req_fail\n and \nafb_req_fail_f\n.\n\n\n/*\n * Sends a reply of kind failure to the request 'req'.\n * The status of the reply is set to 'status' and an\n * informational comment 'info' (can also be NULL) can be added.\n *\n * Note that calling afb_req_fail(\nsuccess\n, info) is equivalent\n * to call afb_req_success(NULL, info). Thus even if possible it\n * is strongly recommended to NEVER use \nsuccess\n for status.\n *\n * For convenience, the function calls 'json_object_put' for 'obj'.\n * Thus, in the case where 'obj' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n */\nvoid afb_req_fail(struct afb_req req, const char *status, const char *info);\n\n/*\n * Same as 'afb_req_fail' but the 'info' is a formatting\n * string followed by arguments.\n *\n * For convenience, the function calls 'json_object_put' for 'obj'.\n * Thus, in the case where 'obj' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n */\nvoid afb_req_fail_f(struct afb_req req, const char *status, const char *info, ...);\n\n\n\n\n\n\nFor convenience, these functions automatically call \njson_object_put\n to release \nobj\n.\nBecause \nobj\n usage count is null after being passed to a reply function, it SHOULD not be used anymore.\nIf exceptionally \nobj\n needs to remain usable after reply function then using \njson_object_get\n on \nobj\n\nto increase usage count and cancels the effect the \njson_object_put\n is possible.\n\n\n\n\nGetting argument of invocation\n\n\nMany methods expect arguments. Afb-daemon's bindings\nretrieve arguments by name and not by position.\n\n\nArguments are passed by requests through either HTTP\nor WebSockets.\n\n\nFor example, the method \njoin\n of binding \ntic-tac-toe\n\nexpects one argument: the \nboardid\n to join. Here is an extract:\n\n\n/*\n * Join a board\n */\nstatic void join(struct afb_req req)\n{\n    struct board *board, *new_board;\n    const char *id;\n\n    /* retrieves the context for the session */\n    board = board_of_req(req);\n    INFO(afbitf, \nmethod 'join' called for boardid %d\n, board-\nid);\n\n    /* retrieves the argument */\n    id = afb_req_value(req, \nboardid\n);\n    if (id == NULL)\n        goto bad_request;\n    ...\n\n\n\n\nThe function \nafb_req_value\n searches in the request \nreq\n\nfor argument name passed in the second argument. When argument name\nis not passed, \nafb_req_value\n returns NULL.\n\n\n\n\nThe search is case sensitive and \nboardid\n is not equivalent to \nBoardId\n.\nNevertheless having argument names that only differ by name case is not a good idea.\n\n\n\n\nBasic functions for querying arguments\n\n\nThe function \nafb_req_value\n is defined here after:\n\n\n/*\n * Gets from the request 'req' the string value of the argument of 'name'.\n * Returns NULL if when there is no argument of 'name'.\n * Returns the value of the argument of 'name' otherwise.\n *\n * Shortcut for: afb_req_get(req, name).value\n */\nstatic inline const char *afb_req_value(struct afb_req req, const char *name)\n{\n    return afb_req_get(req, name).value;\n}\n\n\n\n\nIt is defined as a shortcut to call the function \nafb_req_get\n.\nThat function is defined here after:\n\n\n/*\n * Gets from the request 'req' the argument of 'name'.\n * Returns a PLAIN structure of type 'struct afb_arg'.\n * When the argument of 'name' is not found, all fields of result are set to NULL.\n * When the argument of 'name' is found, the fields are filled,\n * in particular, the field 'result.name' is set to 'name'.\n *\n * There is a special name value: the empty string.\n * The argument of name \n is defined only if the request was made using\n * an HTTP POST of Content-Type \napplication/json\n. In that case, the\n * argument of name \n receives the value of the body of the HTTP request.\n */\nstruct afb_arg afb_req_get(struct afb_req req, const char *name);\n\n\n\n\nThat function takes 2 parameters: the request and the name\nof the argument to retrieve. It returns a PLAIN structure of\ntype \nstruct afb_arg\n.\n\n\nThere is a special name that is defined when the request is\nof type HTTP/POST with a Content-Type being application/json.\nThis name is \n\"\"\n (the empty string). In that case, the value\nof this argument of empty name is the string received as a body\nof the post and is supposed to be a JSON string.\n\n\nThe definition of \nstruct afb_arg\n is:\n\n\n/*\n * Describes an argument (or parameter) of a request\n */\nstruct afb_arg {\n    const char *name;   /* name of the argument or NULL if invalid */\n    const char *value;  /* string representation of the value of the argument */\n                /* original filename of the argument if path != NULL */\n    const char *path;   /* if not NULL, path of the received file for the argument */\n                /* when the request is finalized this file is removed */\n};\n\n\n\n\nThe structure returns the data arguments that are known for the\nrequest. This data include a field named \npath\n. This \npath\n\ncan be accessed using the function \nafb_req_path\n defined here after:\n\n\n/*\n * Gets from the request 'req' the path for file attached to the argument of 'name'.\n * Returns NULL if when there is no argument of 'name' or when there is no file.\n * Returns the path of the argument of 'name' otherwise.\n *\n * Shortcut for: afb_req_get(req, name).path\n */\nstatic inline const char *afb_req_path(struct afb_req req, const char *name)\n{\n    return afb_req_get(req, name).path;\n}\n\n\n\n\nThe path is only defined for HTTP/POST requests that send file.\n\n\nArguments for received files\n\n\nAs it is explained above, clients can send files using HTTP/POST requests.\n\n\nReceived files are attached to \"file\" argument name. For example, the\nfollowing HTTP fragment (from test/sample-post.html)\nwill send an HTTP/POST request to the method\n\npost/upload-image\n with 2 arguments named \nfile\n and\n\nhidden\n.\n\n\nh2\nSample Post File\n/h2\n\n\nform enctype=\nmultipart/form-data\n\n    \ninput type=\nfile\n name=\nfile\n /\n\n    \ninput type=\nhidden\n name=\nhidden\n value=\nbollobollo\n /\n\n    \nbr\n\n    \nbutton formmethod=\nPOST\n formaction=\napi/post/upload-image\nPost File\n/button\n\n\n/form\n\n\n\n\n\nArgument named \nfile\n should have both its value and path defined.\n\n\nThe value is the name of the file as it was set by the HTTP client.\nGenerally it is the filename on client side.\n\n\nThe path is the effective path of saved file on the temporary local storage\narea of the application. This is a randomly generated and unique filename. \nIt is not linked with the original filename as used on client side.\n\n\nAfter success the binding can use the uploaded file directly from local storage path with no restriction:\nread, write, remove, copy, rename...\nNevertheless when request reply is set and query terminated, the uploaded temporary file at\npath is destroyed.\n\n\nArguments as a JSON object\n\n\nBindings may also request every arguments of a given call as one single object.\nThis feature is provided by the function \nafb_req_json\n defined here after:\n\n\n/*\n * Gets from the request 'req' the json object hashing the arguments.\n * The returned object must not be released using 'json_object_put'.\n */\nstruct json_object *afb_req_json(struct afb_req req);\n\n\n\n\nIt returns a json object. This object depends on how the request was built:\n\n\n\n\n\n\nFor HTTP requests, this json object uses key names mapped on argument name. \nValues are either string for common arguments or object ie: { \"file\": \"...\", \"path\": \"...\" }\n\n\n\n\n\n\nFor WebSockets requests, returned directly the object as provided by the client.\n\n\n\n\n\n\n\n\nIn fact, for Websockets requests, the function \nafb_req_value\n\ncan be seen as a shortcut to\n\njson_object_get_string(json_object_object_get(afb_req_json(req), name))\n\n\n\n\nInitialisation of the binding and declaration of methods\n\n\nTo be active, binding's methods should be declared to\nafb-daemon. Furthermore, the binding itself must be recorded.\n\n\nThe registration mechanism is very basic: when afb-need starts,\nit loads all bindings listed in: command line or configuration file.\n\n\nLoading a binding follows the following steps:\n\n\n\n\n\n\nAfb-daemon loads the binding with \ndlopen\n.\n\n\n\n\n\n\nAfb-daemon searches for a symbol named \nafbBindingV1Register\n using \ndlsym\n.\nThis symbol is assumed to be the exported initialisation function of the binding.\n\n\n\n\n\n\nAfb-daemon builds an interface object for the binding.\n\n\n\n\n\n\nAfb-daemon calls the found function \nafbBindingV1Register\n with interface pointer\nas parameter.\n\n\n\n\n\n\nFunction \nafbBindingV1Register\n setups the binding and initialises it.\n\n\n\n\n\n\nFunction \nafbBindingV1Register\n returns the pointer to a structure\ndescribing the binding: version, name (prefix or API name), and list of methods.\n\n\n\n\n\n\nAfb-daemon checks that the returned version and name can be managed.\nIf so, binding and its methods are register to become usable as soon as\nafb-daemon initialisation is finished.\n\n\n\n\n\n\nHere after the code used for \nafbBindingV1Register\n from binding \ntic-tac-toe\n:\n\n\n/*\n * activation function for registering the binding called by afb-daemon\n */\nconst struct afb_binding *afbBindingV1Register(const struct afb_binding_interface *itf)\n{\n   afbitf = itf;         // records the interface for accessing afb-daemon\n   return \nbinding_description;  // returns the description of the binding\n}\n\n\n\n\nIt is a very minimal initialisation function because \ntic-tac-toe\n binding doesn't\nhave any application related initialisation step. It merely record daemon's interface\nand returns its description.\n\n\nThe variable \nafbitf\n is a binding global variable. It keeps the\ninterface to afb-daemon that should be used for logging and pushing events.\nHere is its declaration:\n\n\n/*\n * the interface to afb-daemon\n */\nconst struct afb_binding_interface *afbitf;\n\n\n\n\nThe description of the binding is defined here after.\n\n\n/*\n * array of the methods exported to afb-daemon\n */\nstatic const struct afb_verb_desc_v1 binding_methods[] = {\n   /* VERB'S NAME     SESSION MANAGEMENT          FUNCTION TO CALL  SHORT DESCRIPTION */\n   { .name= \nnew\n,   .session= AFB_SESSION_NONE, .callback= new,   .info= \nStarts a new game\n },\n   { .name= \nplay\n,  .session= AFB_SESSION_NONE, .callback= play,  .info= \nAsks the server to play\n },\n   { .name= \nmove\n,  .session= AFB_SESSION_NONE, .callback= move,  .info= \nTells the client move\n },\n   { .name= \nboard\n, .session= AFB_SESSION_NONE, .callback= board, .info= \nGet the current board\n },\n   { .name= \nlevel\n, .session= AFB_SESSION_NONE, .callback= level, .info= \nSet the server level\n },\n   { .name= \njoin\n,  .session= AFB_SESSION_CHECK,.callback= join,  .info= \nJoin a board\n },\n   { .name= \nundo\n,  .session= AFB_SESSION_NONE, .callback= undo,  .info= \nUndo the last move\n },\n   { .name= \nwait\n,  .session= AFB_SESSION_NONE, .callback= wait,  .info= \nWait for a change\n },\n   { .name= NULL } /* marker for end of the array */\n};\n\n/*\n * description of the binding for afb-daemon\n */\nstatic const struct afb_binding binding_description =\n{\n   /* description conforms to VERSION 1 */\n   .type= AFB_BINDING_VERSION_1,\n   .v1= {               /* fills the v1 field of the union when AFB_BINDING_VERSION_1 */\n      .prefix= \ntictactoe\n,     /* the API name (or binding name or prefix) */\n      .info= \nSample tac-tac-toe game\n, /* short description of of the binding */\n      .methods = binding_methods        /* the array describing the methods of the API */\n   }\n};\n\n\n\n\nThe structure \nbinding_description\n describes the binding.\nIt declares the type and version of the binding, its name, a short description\nand its methods list.\n\n\nThe list of methods is an array of structures describing the methods and terminated by a NULL marker.\n\n\nIn version one of afb-damon binding, a method description contains 4 fields:\n\n\n\n\n\n\nthe name of the method,\n\n\n\n\n\n\nthe session management flags,\n\n\n\n\n\n\nthe implementation function to be call for the method,\n\n\n\n\n\n\na short description.\n\n\n\n\n\n\nThe structure describing methods is defined as follows:\n\n\n/*\n * Description of one method of the API provided by the binding\n * This enumeration is valid for bindings of type 1\n */\nstruct afb_verb_desc_v1\n{\n       const char *name;                       /* name of the method */\n       enum AFB_session_v1 session;            /* authorisation and session requirements of the method */\n       void (*callback)(struct afb_req req);   /* callback function implementing the method */\n       const char *info;                       /* textual description of the method */\n};\n\n\n\n\nFor technical reasons, the enumeration \nenum AFB_session_v1\n is not exactly an\nenumeration but the wrapper of constant definitions that can be mixed using bitwise or\n(the C operator |).\n\n\nThe constants that can bit mixed are:\n\n\n\n\n\n\n\n\nConstant name\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nAFB_SESSION_CREATE\n\n\nEquals to AFB_SESSION_LOA_EQ_0\n\n\n\n\n\n\nAFB_SESSION_CLOSE\n\n\nCloses the session after the reply and set the LOA to 0\n\n\n\n\n\n\nAFB_SESSION_RENEW\n\n\nRefreshes the token of authentification\n\n\n\n\n\n\nAFB_SESSION_CHECK\n\n\nJust requires the token authentification\n\n\n\n\n\n\nAFB_SESSION_LOA_LE_0\n\n\nRequires the current LOA to be lesser then or equal to 0\n\n\n\n\n\n\nAFB_SESSION_LOA_LE_1\n\n\nRequires the current LOA to be lesser then or equal to 1\n\n\n\n\n\n\nAFB_SESSION_LOA_LE_2\n\n\nRequires the current LOA to be lesser then or equal to 2\n\n\n\n\n\n\nAFB_SESSION_LOA_LE_3\n\n\nRequires the current LOA to be lesser then or equal to 3\n\n\n\n\n\n\nAFB_SESSION_LOA_GE_0\n\n\nRequires the current LOA to be greater then or equal to 0\n\n\n\n\n\n\nAFB_SESSION_LOA_GE_1\n\n\nRequires the current LOA to be greater then or equal to 1\n\n\n\n\n\n\nAFB_SESSION_LOA_GE_2\n\n\nRequires the current LOA to be greater then or equal to 2\n\n\n\n\n\n\nAFB_SESSION_LOA_GE_3\n\n\nRequires the current LOA to be greater then or equal to 3\n\n\n\n\n\n\nAFB_SESSION_LOA_EQ_0\n\n\nRequires the current LOA to be equal to 0\n\n\n\n\n\n\nAFB_SESSION_LOA_EQ_1\n\n\nRequires the current LOA to be equal to 1\n\n\n\n\n\n\nAFB_SESSION_LOA_EQ_2\n\n\nRequires the current LOA to be equal to 2\n\n\n\n\n\n\nAFB_SESSION_LOA_EQ_3\n\n\nRequires the current LOA to be equal to 3\n\n\n\n\n\n\n\n\nIf any of this flag is set, afb-daemon requires an authentication token\nas if \nAFB_SESSION_CHECK\n flag was also set.\n\n\nThe special value \nAFB_SESSION_NONE\n is zero and can be used to bypass token check.\n\n\n\n\nNote that \nAFB_SESSION_CREATE\n and \nAFB_SESSION_CLOSE\n might be removed in later versions.\n\n\n\n\nSending messages to the log system\n\n\nAfb-daemon provides 4 levels of verbosity and 5 methods for logging messages.\n\n\nThe verbosity is managed. Options allow the change the verbosity of afb-daemon\nand the verbosity of the bindings can be set binding by binding.\n\n\nThe methods for logging messages are defined as macros that test the\nverbosity level and that call the real logging function only if the\nmessage must be output. This avoid evaluation of arguments of the\nformatting messages if the message must not be output.\n\n\nVerbs for logging messages\n\n\nThe 5 logging methods are:\n\n\n\n\n\n\n\n\nMacro\n\n\nVerbosity\n\n\nMeaning\n\n\nsyslog level\n\n\n\n\n\n\n\n\n\n\nERROR\n\n\n0\n\n\nError conditions\n\n\n3\n\n\n\n\n\n\nWARNING\n\n\n1\n\n\nWarning conditions\n\n\n4\n\n\n\n\n\n\nNOTICE\n\n\n1\n\n\nNormal but significant condition\n\n\n5\n\n\n\n\n\n\nINFO\n\n\n2\n\n\nInformational\n\n\n6\n\n\n\n\n\n\nDEBUG\n\n\n3\n\n\nDebug-level messages\n\n\n7\n\n\n\n\n\n\n\n\nYou can note that the 2 methods \nWARNING\n and \nINFO\n have the same level\nof verbosity. But they don't have the same \nsyslog level\n. It means that\nthey are output with a different level on the logging system.\n\n\nAll of these methods have the same signature:\n\n\nvoid ERROR(const struct afb_binding_interface *afbitf, const char *message, ...);\n\n\n\n\nThe first argument \nafbitf\n is the interface to afb daemon that the\nbinding received at initialisation time when \nafbBindingV1Register\n is called.\n\n\nThe second argument \nmessage\n is a formatting string compatible with printf/sprintf.\n\n\nThe remaining arguments are arguments of the formating message like with printf.\n\n\nManaging verbosity\n\n\nDepending on the level of verbosity, the messages are output or not.\nThe following table explains what messages will be output depending\nont the verbosity level.\n\n\n\n\n\n\n\n\nLevel of verbosity\n\n\nOutputed macro\n\n\n\n\n\n\n\n\n\n\n0\n\n\nERROR\n\n\n\n\n\n\n1\n\n\nERROR + WARNING + NOTICE\n\n\n\n\n\n\n2\n\n\nERROR + WARNING + NOTICE + INFO\n\n\n\n\n\n\n3\n\n\nERROR + WARNING + NOTICE + INFO + DEBUG\n\n\n\n\n\n\n\n\nOutput format and destination\n\n\nThe syslog level is used for forging a prefix to the message.\nThe prefixes are:\n\n\n\n\n\n\n\n\nsyslog level\n\n\nprefix\n\n\n\n\n\n\n\n\n\n\n0\n\n\n0\n EMERGENCY\n\n\n\n\n\n\n1\n\n\n1\n ALERT\n\n\n\n\n\n\n2\n\n\n2\n CRITICAL\n\n\n\n\n\n\n3\n\n\n3\n ERROR\n\n\n\n\n\n\n4\n\n\n4\n WARNING\n\n\n\n\n\n\n5\n\n\n5\n NOTICE\n\n\n\n\n\n\n6\n\n\n6\n INFO\n\n\n\n\n\n\n7\n\n\n7\n DEBUG\n\n\n\n\n\n\n\n\nThe message is pushed to standard error.\nThe final destination of the message depends on how systemd service\nwas configured through its variable \nStandardError\n. It can be\njournal, syslog or kmsg. (See man sd-daemon).\n\n\nSending events\n\n\nSince version 0.5, bindings can broadcast events to any potential listener.\nAs today only unattended even are supported. Targeted events are expected for next\ncoming version.\n\n\nThe binding \ntic-tac-toe\n broadcasts events when the board changes.\nThis is done in the function \nchanged\n:\n\n\n/*\n * signals a change of the board\n */\nstatic void changed(struct board *board, const char *reason)\n{\n    ...\n    struct json_object *description;\n\n    /* get the description */\n    description = describe(board);\n\n    ...\n\n    afb_daemon_broadcast_event(afbitf-\ndaemon, reason, description);\n}\n\n\n\n\nThe description of the changed board is pushed via the daemon interface.\n\n\nWithin binding \ntic-tac-toe\n, \nreason\n indicates the origin of\nthe change. In function \nafb_daemon_broadcast_event\n the second\nparameter is the name of broadcasted event. The third argument is the\nobject that is transmitted with the event.\n\n\nFunction \nafb_daemon_broadcast_event\n is defined here after:\n\n\n/*\n * Broadcasts widely the event of 'name' with the data 'object'.\n * 'object' can be NULL.\n * 'daemon' MUST be the daemon given in interface when activating the binding.\n *\n * For convenience, the function calls 'json_object_put' for 'object'.\n * Thus, in the case where 'object' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n */\nvoid afb_daemon_broadcast_event(struct afb_daemon daemon, const char *name, struct json_object *object);\n\n\n\n\n\n\nBe aware, as with reply functions \nobject\n is automatically released using\n\njson_object_put\n when using this function. Call \njson_object_get\n before\ncalling \nafb_daemon_broadcast_event\n to keep \nobject\n available\nafter function returns.\n\n\n\n\nEvent name received by listeners is prefixed with binding name.\nSo when a change occurs after a move, the reason is \nmove\n and every clients\nreceive an event \ntictactoe/move\n.\n\n\n\n\nNote that nothing is said about case sensitivity of event names.\nHowever, the event is always prefixed with the name that the binding\ndeclared, with the same case, followed with a slash /.\nThus it is safe to compare event using a case sensitive comparison.\n\n\n\n\nWriting an asynchronous method implementation\n\n\nThe \ntic-tac-toe\n example allows two clients or more to share the same board.\nThis is implemented by the method \njoin\n that illustrated partly how to\nretrieve arguments.\n\n\nWhen two or more clients are sharing a same board, one of them can wait\nuntil the state of the board changes, but this could also be implemented using\nevents because an even is generated each time the board changes.\n\n\nIn this case, the reply to the wait is sent only when the board changes.\nSee the diagram below:\n\n\nCLIENT A       CLIENT B         TIC-TAC-TOE\n   |              |                  |\n   +--------------|-----------------\n| wait . . . . . . . .\n   |              |                  |                     .\n   :              :                  :                      .\n   :              :                  :                      .\n   |              |                  |                      .\n   |              +-----------------\n| move . . .           .\n   |              |                  |          V           .\n   |              |\n-----------------+ success of move      .\n   |              |                  |                    .\n   |\n-------------|------------------+ success of wait  \n\n\n\n\nHere, this is an invocation of the binding by an other client that\nunblock the suspended \nwait\n call.\nNevertheless in most case this should be a timer, a hardware event, a sync with\na concurrent process or thread, ...\n\n\nCommon case of an asynchronous implementation.\n\n\nHere is the listing of the function \nwait\n:\n\n\nstatic void wait(struct afb_req req)\n{\n    struct board *board;\n    struct waiter *waiter;\n\n    /* retrieves the context for the session */\n    board = board_of_req(req);\n    INFO(afbitf, \nmethod 'wait' called for boardid %d\n, board-\nid);\n\n    /* creates the waiter and enqueues it */\n    waiter = calloc(1, sizeof *waiter);\n    waiter-\nreq = req;\n    waiter-\nnext = board-\nwaiters;\n    afb_req_addref(req);\n    board-\nwaiters = waiter;\n}\n\n\n\n\nAfter retrieving the board, the function adds a new waiter to\nwaiters list and returns without setting a reply.\n\n\nBefore returning, it increases \nreq\n request's reference count using \nafb_req_addref\n function.\n\n\n\n\nWhen a method returns without setting a reply,\nit \nMUST\n increment request's reference count\nusing \nafb_req_addref\n. If unpredictable behaviour may pop up.\n\n\n\n\nLater, when a board changes, it calls \ntic-tac-toe\n \nchanged\n function\nwith reason of change in parameter.\n\n\nHere is the full listing of the function \nchanged\n:\n\n\n/*\n * signals a change of the board\n */\nstatic void changed(struct board *board, const char *reason)\n{\n    struct waiter *waiter, *next;\n    struct json_object *description;\n\n    /* get the description */\n    description = describe(board);\n\n    waiter = board-\nwaiters;\n    board-\nwaiters = NULL;\n    while (waiter != NULL) {\n        next = waiter-\nnext;\n        afb_req_success(waiter-\nreq, json_object_get(description), reason);\n        afb_req_unref(waiter-\nreq);\n        free(waiter);\n        waiter = next;\n    }\n\n    afb_event_sender_push(afb_daemon_get_event_sender(afbitf-\ndaemon), reason, description);\n}\n\n\n\n\nThe list of waiters is walked and a reply is sent to each waiter.\nAfter sending the reply, the reference count of the request\nis decremented using \nafb_req_unref\n to allow resources to be freed.\n\n\n\n\nThe reference count \nMUST\n be decremented using \nafb_req_unref\n to free\nresources and avoid memory leaks.\nThis usage count decrement should happen \nAFTER\n setting reply or \nbad things may happen.\n\n\n\n\nHow to build a binding\n\n\nAfb-daemon provides a \npkg-config\n configuration file that can be\nqueried by providing \nafb-daemon\n in command line arguments.\nThis configuration file provides data that should be used\nfor bindings compilation. Examples:\n\n\n$ pkg-config --cflags afb-daemon\n$ pkg-config --libs afb-daemon\n\n\n\n\nExample for cmake meta build system\n\n\nThis example is the extract for building the binding \nafm-main\n using \nCMAKE\n.\n\n\npkg_check_modules(afb afb-daemon)\nif(afb_FOUND)\n    message(STATUS \nCreation afm-main-binding for AFB-DAEMON\n)\n    add_library(afm-main-binding MODULE afm-main-binding.c)\n    target_compile_options(afm-main-binding PRIVATE ${afb_CFLAGS})\n    target_include_directories(afm-main-binding PRIVATE ${afb_INCLUDE_DIRS})\n    target_link_libraries(afm-main-binding utils ${afb_LIBRARIES})\n    set_target_properties(afm-main-binding PROPERTIES\n        PREFIX \n\n        LINK_FLAGS \n-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/afm-main-binding.export-map\n\n    )\n    install(TARGETS afm-main-binding LIBRARY DESTINATION ${binding_dir})\nelse()\n    message(STATUS \nNot creating the binding for AFB-DAEMON\n)\nendif()\n\n\n\n\nLet now describe some of these lines.\n\n\npkg_check_modules(afb afb-daemon)\n\n\n\n\nThis first lines searches to the \npkg-config\n configuration file for\n\nafb-daemon\n. Resulting data are stored in the following variables:\n\n\n\n\n\n\n\n\nVariable\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nafb_FOUND\n\n\nSet to 1 if afb-daemon binding development files exist\n\n\n\n\n\n\nafb_LIBRARIES\n\n\nOnly the libraries (w/o the '-l') for compiling afb-daemon bindings\n\n\n\n\n\n\nafb_LIBRARY_DIRS\n\n\nThe paths of the libraries (w/o the '-L') for compiling afb-daemon bindings\n\n\n\n\n\n\nafb_LDFLAGS\n\n\nAll required linker flags for compiling afb-daemon bindings\n\n\n\n\n\n\nafb_INCLUDE_DIRS\n\n\nThe '-I' preprocessor flags (w/o the '-I') for compiling afb-daemon bindings\n\n\n\n\n\n\nafb_CFLAGS\n\n\nAll required cflags for compiling afb-daemon bindings\n\n\n\n\n\n\n\n\nIf development files are found, the binding can be added to the set of\ntarget to build.\n\n\nadd_library(afm-main-binding MODULE afm-main-binding.c)\n\n\n\n\nThis line asks to create a shared library having a single\nsource file named afm-main-binding.c to be compiled.\nThe default name of the created shared object is\n\nlibafm-main-binding.so\n.\n\n\nset_target_properties(afm-main-binding PROPERTIES\n    PREFIX \n\n    LINK_FLAGS \n-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/afm-main-binding.export-map\n\n)\n\n\n\n\nThis lines are doing two things:\n\n\n\n\n\n\nIt renames the built library from \nlibafm-main-binding.so\n to \nafm-main-binding.so\n\nby removing the implicitly added prefix \nlib\n. This step is not mandatory\nbecause afb-daemon doesn't check names of files at load time.\nThe only filename convention used by afb-daemon relates to \n.so\n termination.\n*.so pattern is used when afb-daemon automatically discovers binding from a directory hierarchy.\n\n\n\n\n\n\nIt applies a version script at link time to only export the reserved name\n\nafbBindingV1Register\n for registration entry point. By default, when building \na shared library linker exports all the public symbols (C functions that are not \nstatic\n).\n\n\n\n\n\n\nNext line are:\n\n\ntarget_include_directories(afm-main-binding PRIVATE ${afb_INCLUDE_DIRS})\ntarget_link_libraries(afm-main-binding utils ${afb_LIBRARIES})\n\n\n\n\nAs you can see it uses the variables computed by \npkg_check_modules(afb afb-daemon)\n\nto configure the compiler and the linker.\n\n\nExporting the function afbBindingV1Register\n\n\nThe function \nafbBindingV1Register\n MUST be exported. This can be achieved\nusing a version script at link time. Here after is a version script used for\n\ntic-tac-toe\n (bindings/samples/export.map).\n\n\n{ global: afbBindingV1Register; local: *; };\n\n\n\nThis sample \nversion script\n\nexports as global the symbol \nafbBindingV1Register\n and hides any\nother symbols.\n\n\nThis version script is added to the link options using the\noption \n--version-script=export.map\n is given directly to the\nlinker or using the option \n-Wl,--version-script=export.map\n\nwhen the option is given to the C compiler.\n\n\nBuilding within yocto\n\n\nAdding a dependency to afb-daemon is enough. See below:\n\n\nDEPENDS += \" afb-daemon \"", 
            "title": "Afb bindings writing"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#howto-write-a-binding-for-afb-daemon", 
            "text": "", 
            "title": "HOWTO WRITE a BINDING for AFB-DAEMON"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#summary", 
            "text": "Afb-daemon binders serve files through HTTP protocol\nand offers to developers the capability to expose application API methods through\nHTTP or WebSocket protocol.  Binder bindings are used to add API to afb-daemon.\nThis part describes how to write a binding for afb-daemon.  Excepting this summary, this document target developers.  Before moving further through an example, here after\na short overview of binder bindings fundamentals.", 
            "title": "Summary"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#nature-of-a-binding", 
            "text": "A binding is an independent piece of software. A binding is self contain and exposes application logic as sharable library.\nA binding is intended to be dynamically loaded by afb-daemon to expose application API.  Technically, a binder binding does not reference and is not linked with any afb-daemon library.", 
            "title": "Nature of a binding"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#class-of-bindings", 
            "text": "Application binder supports two kinds of bindings: application bindings and service bindings.\nTechnically both class of binding are equivalent are use the same coding convention. Only sharing mode and security context diverge.", 
            "title": "Class of bindings"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#application-bindings", 
            "text": "Application-bindings implements the glue in between application's UI and services. Every AGL application\nhas a corresponding binder that typically activates one or many bindings to interface the application logic with lower platform services.\nWhen an application is started by the AGL application framework, a dedicate binder is started that loads/activates application binding(s). \nAPI expose by application-binding are executed within corresponding application security context.  Application bindings generally handle a unique context for a unique client. As the application framework start\na dedicated instance of afb_daemon for each AGL application, if a given binding is used within multiple application each of those\napplication get a new and private instance of eventually \"shared\" binding.", 
            "title": "Application-bindings"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#service-bindings", 
            "text": "Service-bindings enable API activation within corresponding service security context and not within calling application context. \nService-bindings are intended to run as a unique instance. Service-bindings can be shared in between multiple clients.  Service-bindings can either be stateless or manage client context. When managing context each client get a private context.  Sharing may either be global to the platform (ie: GPS service) or dedicated to a given user (ie: user preferences)", 
            "title": "Service-bindings"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#live-cycle-of-bindings-within-afb-daemon", 
            "text": "Application and service bindings are loaded and activated each time a new afb-daemon is started.  At launch time, every loaded binding initialise itself.\nIf a single binding initialisation fail corresponding instance of afb-daemon self aborts.  Conversely, when a binding initialisation succeeds, it should register \nits unique name as well as the list of verbs attached to the methods it exposes.  When initialised, on request from application clients to the right API/verb, binding methods\nare activated by the afb-daemon attached to the application or service.  At exit time, no special action is enforced by afb-daemon. When a specific actions is required at afb-daemon stop,\ndevelopers should use 'atexit/on_exit' during binding initialisation sequence to register a custom exit function.", 
            "title": "Live cycle of bindings within afb-daemon"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#binding-contend", 
            "text": "Afb-daemon's binding register two classes of objects: names and functions.  Bindings declare categories of names:\n - A unique binding name to access all API expose by this binding,\n - One name for each methods/verbs provided by this binding.  Bindings declare two categories of functions:\n - function use for the initialisation\n - functions implementing exposed API methods  Afb-daemon parses URI requests to extract the API(binding name) and the VERB(method to activate).\nAs an example, URI  foo/bar  translates to binding named  foo  and method named  bar .\nTo serve such a request, afb-daemon looks for an active binding named  foo  and then within this binding for a method named  bar .\nWhen find afb-daemon calls corresponding method with attached parameter if any.  Afb-daemon ignores letter case when parsing URI. Thus  TicTacToe/Board  and  tictactoe/board  are equivalent.", 
            "title": "Binding Contend"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#the-name-of-the-binding", 
            "text": "The name of a given binding is also known as the name\nof the API prefix that defines the binding.  The name of a binding SHOULD be unique within a given afb-daemon instance.  For example, when a client of afb-daemon calls a URI named  foo/bar . Afb-daemon\nextracts the prefix  foo  and the suffix  bar .  foo  must match a binding name and  bar  a VERB attached to some method.", 
            "title": "The name of the binding"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#names-of-methods", 
            "text": "Each binding exposes a set of methods that can be called\nby the clients of a given afb-daemon.  VERB's name attached to a given binding (API) MUST be unique within a binding.  Bindings static declaration link VERBS to corresponding methods. \nWhen clients emit requests on a given API/VERB corresponding method is called by afb-daemon.", 
            "title": "Names of methods"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#initialisation-function", 
            "text": "Binding's initialisation function serves several purposes.    It allows afb-daemon to control binding version depending on initialisation function name.\nAs today, the only supported initialisation function is  afbBindingV1Register . This identifies\nversion \"one\" of bindings.    It allows bindings to initialise itself.    It enables names declarations: descriptions, requirements and implementations of exposed API/VERB.", 
            "title": "Initialisation function"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#functions-instantiation-of-apiverbs", 
            "text": "When an API/VERB is called, afb-daemon constructs a request object. Then it \npasses this request object to the implementation function corresponding to requested method, this\nwithin attached API binding.  An implementation function receives a request object that\nis used to: get arguments of the request, send\nanswer, store session data.  A binding MUST set an answer to every received requests.  Nevertheless it is not mandatory to set the answer\nbefore returning from API/VERB implementing function.\nThis behaviour is important for asynchronous actions.  API/VERB implementation that set an answer before returning are called  synchronous implementations .\nThose that do not systematically set an answer before returning are called  asynchronous implementations .  Asynchronous implementations typically launch asynchronous actions. They record some context at\nrequest time and provide answer to the request only at completion of asynchronous actions.", 
            "title": "Functions instantiation of API/VERBs"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#the-tic-tac-toe-example", 
            "text": "This part explains how to write an afb-binding.\nFor the sake of being practical it uses many\nexamples based on tic-tac-toe.\nThis binding example is in  bindings/samples/tic-tac-toe.c .  This binding is named  tictactoe .", 
            "title": "The Tic-Tac-Toe example"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#dependencies-when-compiling", 
            "text": "Afb-daemon provides a configuration file for  pkg-config .\nTyping the command  pkg-config --cflags afb-daemon  Print flags use for compilation:  $ pkg-config --cflags afb-daemon\n-I/opt/local/include -I/usr/include/json-c  For linking, you should use  $ pkg-config --libs afb-daemon\n-ljson-c  Afb-daemon automatically includes dependency to json-c.\nThis is activated through  Requires  keyword in pkg-config.\nWhile almost every binding replies on  json-c  this is not a must have dependency.  Internally, afb-daemon relies on  libsystemd  for its event loop, as well \nas for its binding to D-Bus.\nBindings developers are encouraged to leverage  libsystemd  when possible.\nNevertheless there is no hard dependency to  libsystemd  if ever\nyou rather not use it, feel free to do so.   Afb-daemon binding are fully self contain. They do not enforce dependency on any libraries from the application framework.\nAfb-daemon dependencies requirer to run AGL bindings are given at runtime through pointers leveraging read-only\nmemory feature.", 
            "title": "Dependencies when compiling"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#header-files-to-include", 
            "text": "Binding  tictactoe  has following includes:  #define _GNU_SOURCE\n#include  stdio.h \n#include  string.h \n#include  json-c/json.h \n#include  afb/afb-binding.h   Header  afb/afb-binding.h  is the only hard dependency, it includes all features\nthat a binding MUST HAVE. Outside of includes used to support application logic,\ncommon external headers used within bindings are:   json-c/json.h : should be include to handle json objects;  systemd/sd-event.h : should be include to access event main loop;  systemd/sd-bus.h : should be include for dbus connections.   The  tictactoe  binding does not leverage systemd features, also only json.h\nis used on top of mandatory afb/afb-binding.h.  When including  afb/afb-binding.h , the macro  _GNU_SOURCE  MUST be\ndefined.", 
            "title": "Header files to include"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#choosing-names", 
            "text": "Designers of bindings should define a unique name for every API binding\nas well as for methods VERBs. They should also define names for request\narguments passed as name/value pair in URI.  While forging names, designers should respect few rules to\nensure that created names are valid and easy to use across platforms.  All names and strings are UTF-8 encoded.", 
            "title": "Choosing names"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#names-for-api-binding", 
            "text": "Binding API name are checked.\nAll characters are authorised except:   the control characters (\\u0000 .. \\u001f)  the characters of the set { ' ', '\"', '#', '%', ' ',\n  '\\'', '/', '?', '`', '\\x7f' }   In other words the set of forbidden characters is\n{ \\u0000..\\u0020, \\u0022, \\u0023, \\u0025..\\u0027,\n  \\u002f, \\u003f, \\u0060, \\u007f }.  Afb-daemon makes no distinction between lower case\nand upper case when searching for API/VERB.", 
            "title": "Names for API (binding)"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#names-for-methods", 
            "text": "The names of methods VERBs are totally free and not checked.  However, the validity rules for method's VERB name are the\nsame as for Binding API name except that the dot(.) character\nis forbidden.  Afb-daemon makes no case distinction when searching for an API by name.", 
            "title": "Names for methods"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#names-for-arguments", 
            "text": "Argument's name are not restricted and can be everything you wish.   Warning arguments search is case sensitive and \"index\" and \"Index\"\nare not two different arguments.", 
            "title": "Names for arguments"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#forging-names-widely-available", 
            "text": "The key names of javascript object can be almost\nanything using the arrayed notation:  object[key] = value  Nevertheless this is not the case with javascript dot notation:  object.key = value  Using the dot notation, the key must be a valid javascript\nidentifier and dash(-) as well as few other reserved characters cannot be used.  For this reason, we advise developper to chose name compatible with both javascript and HTML notation.  It is a good practice, even for arguments not to rely on case sensitivity.\nThis may reduce headache strength at debug time, especially with interpreted language like\njavascript that may not warn you that a variable was not defined.", 
            "title": "Forging names widely available"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#writing-a-synchronous-method-implementation", 
            "text": "The method  tictactoe/board  is a synchronous implementation.\nHere is its listing:  /*\n * get the board\n */\nstatic void board(struct afb_req req)\n{\n    struct board *board;\n    struct json_object *description;\n\n    /* retrieves the context for the session */\n    board = board_of_req(req);\n    INFO(afbitf,  method 'board' called for boardid %d , board- id);\n\n    /* describe the board */\n    description = describe(board);\n\n    /* send the board's description */\n    afb_req_success(req, description, NULL);\n}  This example shows many aspects of a synchronous\nmethod implementation. Let summarise it:    The function  board_of_req  retrieves the context stored\nfor the binding: the board.    The macro  INFO  sends a message of kind  INFO \nto the logging system. The global variable named  afbitf \nused represents the interface to afb-daemon.    The function  describe  creates a json_object representing\nthe board.    The function  afb_req_success  sends the reply, attaching to\nit the object  description .", 
            "title": "Writing a synchronous method implementation"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#the-incoming-request", 
            "text": "For any implementation, the request is received by a structure of type struct afb_req .   Note that this is a PLAIN structure, not a pointer to a structure.   The definition of  struct afb_req  is:  /*\n * Describes the request by bindings from afb-daemon\n */\nstruct afb_req {\n    const struct afb_req_itf *itf;  /* the interfacing functions */\n    void *closure;          /* the closure for functions */\n};  It contains two pointers: first one  itf , points to functions used\nto handle internal request. Second one  closure  point onto function closure.    The structure must never be used directly.\nInstead developer should use the intended functions provided\nby afb-daemon as described here after.   req  is used to get arguments of the request, to send\nanswer, to store session data.  This object and its interface is defined and documented\nin the file names  afb/afb-req-itf.h  The above example uses twice  req  object request.  The first time, to retrieve the board attached to the session of the request.  The second time, to send the reply: an object that describes the current board.", 
            "title": "The incoming request"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#associating-a-client-context-to-a-session", 
            "text": "When  tic-tac-toe  binding receives a request, it musts get\nthe board describing the game associated to the session.  For a binding, having data associated to a session is common.\nThis data is called \"binding context\" for the session.\nWithin  tic-tac-toe  binding the context is the board.  Requests  afb_req  offer four functions for storing and retrieving session associated context.  These functions are:    afb_req_context_get :\n  retrieves context data stored for current binding.    afb_req_context_set :\n  store context data of current binding.    afb_req_context :\n  if exist retrieves context data of current binding.\n  if context does not yet exist, creates a new context and store it.    afb_req_context_clear :\n  reset the stored context data.    The binding  tictactoe  use a convenient function to retrieve\nits context: the board. This function is  board_of_req :  /*\n * retrieves the board of the request\n */\nstatic inline struct board *board_of_req(struct afb_req req)\n{\n    return afb_req_context(req, (void*)get_new_board, (void*)release_board);\n}  The function  afb_req_context  ensures an existing context\nfor the session of the request.\nIts two last arguments are functions to allocate and free context. \nNote function type casts to avoid compilation warnings.  Here is the definition of the function  afb_req_context  /*\n * Gets the pointer stored by the binding for the session of 'req'.\n * If the stored pointer is NULL, indicating that no pointer was\n * already stored, afb_req_context creates a new context by calling\n * the function 'create_context' and stores it with the freeing function\n * 'free_context'.\n */\nstatic inline void *afb_req_context(struct afb_req req, void *(*create_context)(), void (*free_context)(void*))\n{\n    void *result = afb_req_context_get(req);\n    if (result == NULL) {\n        result = create_context();\n        afb_req_context_set(req, result, free_context);\n    }\n    return result;\n}  The second argument if the function that creates the context.\nFor binding  tic-tac-toe  (function  get_new_board ).\nThe function  get_new_board  creates a new board and set usage its count to 1.\nThe boards are checking usage count to free resources when not used.  The third argument is a function that frees context resources.\nFor binding  tic-tac-toe  (function  release_board ).\nThe function  release_board  decrease usage count of the board passed in argument.\nWhen usage count falls to zero, data board are freed.  Definition of other functions dealing with contexts:  /*\n * Gets the pointer stored by the binding for the session of 'req'.\n * When the binding has not yet recorded a pointer, NULL is returned.\n */\nvoid *afb_req_context_get(struct afb_req req);\n\n/*\n * Stores for the binding the pointer 'context' to the session of 'req'.\n * The function 'free_context' will be called when the session is closed\n * or if binding stores an other pointer.\n */\nvoid afb_req_context_set(struct afb_req req, void *context, void (*free_context)(void*));\n\n/*\n * Frees the pointer stored by the binding for the session of 'req'\n * and sets it to NULL.\n *\n * Shortcut for: afb_req_context_set(req, NULL, NULL)\n */\nstatic inline void afb_req_context_clear(struct afb_req req)\n{\n    afb_req_context_set(req, NULL, NULL);\n}", 
            "title": "Associating a client context to a session"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#sending-reply-to-a-request", 
            "text": "Two kinds of replies: successful or failure.   Sending a reply to a request MUST be done once and only once.   It exists two functions for \"success\" replies:  afb_req_success  and  afb_req_success_f .  /*\n * Sends a reply of kind success to the request 'req'.\n * The status of the reply is automatically set to  success .\n * Its send the object 'obj' (can be NULL) with an\n * informationnal comment 'info (can also be NULL).\n *\n * For convenience, the function calls 'json_object_put' for 'obj'.\n * Thus, in the case where 'obj' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n */\nvoid afb_req_success(struct afb_req req, struct json_object *obj, const char *info);\n\n/*\n * Same as 'afb_req_success' but the 'info' is a formatting\n * string followed by arguments.\n *\n * For convenience, the function calls 'json_object_put' for 'obj'.\n * Thus, in the case where 'obj' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n */\nvoid afb_req_success_f(struct afb_req req, struct json_object *obj, const char *info, ...);  It exists two functions for \"failure\" replies:  afb_req_fail  and  afb_req_fail_f .  /*\n * Sends a reply of kind failure to the request 'req'.\n * The status of the reply is set to 'status' and an\n * informational comment 'info' (can also be NULL) can be added.\n *\n * Note that calling afb_req_fail( success , info) is equivalent\n * to call afb_req_success(NULL, info). Thus even if possible it\n * is strongly recommended to NEVER use  success  for status.\n *\n * For convenience, the function calls 'json_object_put' for 'obj'.\n * Thus, in the case where 'obj' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n */\nvoid afb_req_fail(struct afb_req req, const char *status, const char *info);\n\n/*\n * Same as 'afb_req_fail' but the 'info' is a formatting\n * string followed by arguments.\n *\n * For convenience, the function calls 'json_object_put' for 'obj'.\n * Thus, in the case where 'obj' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n */\nvoid afb_req_fail_f(struct afb_req req, const char *status, const char *info, ...);   For convenience, these functions automatically call  json_object_put  to release  obj .\nBecause  obj  usage count is null after being passed to a reply function, it SHOULD not be used anymore.\nIf exceptionally  obj  needs to remain usable after reply function then using  json_object_get  on  obj \nto increase usage count and cancels the effect the  json_object_put  is possible.", 
            "title": "Sending reply to a request"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#getting-argument-of-invocation", 
            "text": "Many methods expect arguments. Afb-daemon's bindings\nretrieve arguments by name and not by position.  Arguments are passed by requests through either HTTP\nor WebSockets.  For example, the method  join  of binding  tic-tac-toe \nexpects one argument: the  boardid  to join. Here is an extract:  /*\n * Join a board\n */\nstatic void join(struct afb_req req)\n{\n    struct board *board, *new_board;\n    const char *id;\n\n    /* retrieves the context for the session */\n    board = board_of_req(req);\n    INFO(afbitf,  method 'join' called for boardid %d , board- id);\n\n    /* retrieves the argument */\n    id = afb_req_value(req,  boardid );\n    if (id == NULL)\n        goto bad_request;\n    ...  The function  afb_req_value  searches in the request  req \nfor argument name passed in the second argument. When argument name\nis not passed,  afb_req_value  returns NULL.   The search is case sensitive and  boardid  is not equivalent to  BoardId .\nNevertheless having argument names that only differ by name case is not a good idea.", 
            "title": "Getting argument of invocation"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#basic-functions-for-querying-arguments", 
            "text": "The function  afb_req_value  is defined here after:  /*\n * Gets from the request 'req' the string value of the argument of 'name'.\n * Returns NULL if when there is no argument of 'name'.\n * Returns the value of the argument of 'name' otherwise.\n *\n * Shortcut for: afb_req_get(req, name).value\n */\nstatic inline const char *afb_req_value(struct afb_req req, const char *name)\n{\n    return afb_req_get(req, name).value;\n}  It is defined as a shortcut to call the function  afb_req_get .\nThat function is defined here after:  /*\n * Gets from the request 'req' the argument of 'name'.\n * Returns a PLAIN structure of type 'struct afb_arg'.\n * When the argument of 'name' is not found, all fields of result are set to NULL.\n * When the argument of 'name' is found, the fields are filled,\n * in particular, the field 'result.name' is set to 'name'.\n *\n * There is a special name value: the empty string.\n * The argument of name   is defined only if the request was made using\n * an HTTP POST of Content-Type  application/json . In that case, the\n * argument of name   receives the value of the body of the HTTP request.\n */\nstruct afb_arg afb_req_get(struct afb_req req, const char *name);  That function takes 2 parameters: the request and the name\nof the argument to retrieve. It returns a PLAIN structure of\ntype  struct afb_arg .  There is a special name that is defined when the request is\nof type HTTP/POST with a Content-Type being application/json.\nThis name is  \"\"  (the empty string). In that case, the value\nof this argument of empty name is the string received as a body\nof the post and is supposed to be a JSON string.  The definition of  struct afb_arg  is:  /*\n * Describes an argument (or parameter) of a request\n */\nstruct afb_arg {\n    const char *name;   /* name of the argument or NULL if invalid */\n    const char *value;  /* string representation of the value of the argument */\n                /* original filename of the argument if path != NULL */\n    const char *path;   /* if not NULL, path of the received file for the argument */\n                /* when the request is finalized this file is removed */\n};  The structure returns the data arguments that are known for the\nrequest. This data include a field named  path . This  path \ncan be accessed using the function  afb_req_path  defined here after:  /*\n * Gets from the request 'req' the path for file attached to the argument of 'name'.\n * Returns NULL if when there is no argument of 'name' or when there is no file.\n * Returns the path of the argument of 'name' otherwise.\n *\n * Shortcut for: afb_req_get(req, name).path\n */\nstatic inline const char *afb_req_path(struct afb_req req, const char *name)\n{\n    return afb_req_get(req, name).path;\n}  The path is only defined for HTTP/POST requests that send file.", 
            "title": "Basic functions for querying arguments"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#arguments-for-received-files", 
            "text": "As it is explained above, clients can send files using HTTP/POST requests.  Received files are attached to \"file\" argument name. For example, the\nfollowing HTTP fragment (from test/sample-post.html)\nwill send an HTTP/POST request to the method post/upload-image  with 2 arguments named  file  and hidden .  h2 Sample Post File /h2  form enctype= multipart/form-data \n     input type= file  name= file  / \n     input type= hidden  name= hidden  value= bollobollo  / \n     br \n     button formmethod= POST  formaction= api/post/upload-image Post File /button  /form   Argument named  file  should have both its value and path defined.  The value is the name of the file as it was set by the HTTP client.\nGenerally it is the filename on client side.  The path is the effective path of saved file on the temporary local storage\narea of the application. This is a randomly generated and unique filename. \nIt is not linked with the original filename as used on client side.  After success the binding can use the uploaded file directly from local storage path with no restriction:\nread, write, remove, copy, rename...\nNevertheless when request reply is set and query terminated, the uploaded temporary file at\npath is destroyed.", 
            "title": "Arguments for received files"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#arguments-as-a-json-object", 
            "text": "Bindings may also request every arguments of a given call as one single object.\nThis feature is provided by the function  afb_req_json  defined here after:  /*\n * Gets from the request 'req' the json object hashing the arguments.\n * The returned object must not be released using 'json_object_put'.\n */\nstruct json_object *afb_req_json(struct afb_req req);  It returns a json object. This object depends on how the request was built:    For HTTP requests, this json object uses key names mapped on argument name. \nValues are either string for common arguments or object ie: { \"file\": \"...\", \"path\": \"...\" }    For WebSockets requests, returned directly the object as provided by the client.     In fact, for Websockets requests, the function  afb_req_value \ncan be seen as a shortcut to json_object_get_string(json_object_object_get(afb_req_json(req), name))", 
            "title": "Arguments as a JSON object"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#initialisation-of-the-binding-and-declaration-of-methods", 
            "text": "To be active, binding's methods should be declared to\nafb-daemon. Furthermore, the binding itself must be recorded.  The registration mechanism is very basic: when afb-need starts,\nit loads all bindings listed in: command line or configuration file.  Loading a binding follows the following steps:    Afb-daemon loads the binding with  dlopen .    Afb-daemon searches for a symbol named  afbBindingV1Register  using  dlsym .\nThis symbol is assumed to be the exported initialisation function of the binding.    Afb-daemon builds an interface object for the binding.    Afb-daemon calls the found function  afbBindingV1Register  with interface pointer\nas parameter.    Function  afbBindingV1Register  setups the binding and initialises it.    Function  afbBindingV1Register  returns the pointer to a structure\ndescribing the binding: version, name (prefix or API name), and list of methods.    Afb-daemon checks that the returned version and name can be managed.\nIf so, binding and its methods are register to become usable as soon as\nafb-daemon initialisation is finished.    Here after the code used for  afbBindingV1Register  from binding  tic-tac-toe :  /*\n * activation function for registering the binding called by afb-daemon\n */\nconst struct afb_binding *afbBindingV1Register(const struct afb_binding_interface *itf)\n{\n   afbitf = itf;         // records the interface for accessing afb-daemon\n   return  binding_description;  // returns the description of the binding\n}  It is a very minimal initialisation function because  tic-tac-toe  binding doesn't\nhave any application related initialisation step. It merely record daemon's interface\nand returns its description.  The variable  afbitf  is a binding global variable. It keeps the\ninterface to afb-daemon that should be used for logging and pushing events.\nHere is its declaration:  /*\n * the interface to afb-daemon\n */\nconst struct afb_binding_interface *afbitf;  The description of the binding is defined here after.  /*\n * array of the methods exported to afb-daemon\n */\nstatic const struct afb_verb_desc_v1 binding_methods[] = {\n   /* VERB'S NAME     SESSION MANAGEMENT          FUNCTION TO CALL  SHORT DESCRIPTION */\n   { .name=  new ,   .session= AFB_SESSION_NONE, .callback= new,   .info=  Starts a new game  },\n   { .name=  play ,  .session= AFB_SESSION_NONE, .callback= play,  .info=  Asks the server to play  },\n   { .name=  move ,  .session= AFB_SESSION_NONE, .callback= move,  .info=  Tells the client move  },\n   { .name=  board , .session= AFB_SESSION_NONE, .callback= board, .info=  Get the current board  },\n   { .name=  level , .session= AFB_SESSION_NONE, .callback= level, .info=  Set the server level  },\n   { .name=  join ,  .session= AFB_SESSION_CHECK,.callback= join,  .info=  Join a board  },\n   { .name=  undo ,  .session= AFB_SESSION_NONE, .callback= undo,  .info=  Undo the last move  },\n   { .name=  wait ,  .session= AFB_SESSION_NONE, .callback= wait,  .info=  Wait for a change  },\n   { .name= NULL } /* marker for end of the array */\n};\n\n/*\n * description of the binding for afb-daemon\n */\nstatic const struct afb_binding binding_description =\n{\n   /* description conforms to VERSION 1 */\n   .type= AFB_BINDING_VERSION_1,\n   .v1= {               /* fills the v1 field of the union when AFB_BINDING_VERSION_1 */\n      .prefix=  tictactoe ,     /* the API name (or binding name or prefix) */\n      .info=  Sample tac-tac-toe game , /* short description of of the binding */\n      .methods = binding_methods        /* the array describing the methods of the API */\n   }\n};  The structure  binding_description  describes the binding.\nIt declares the type and version of the binding, its name, a short description\nand its methods list.  The list of methods is an array of structures describing the methods and terminated by a NULL marker.  In version one of afb-damon binding, a method description contains 4 fields:    the name of the method,    the session management flags,    the implementation function to be call for the method,    a short description.    The structure describing methods is defined as follows:  /*\n * Description of one method of the API provided by the binding\n * This enumeration is valid for bindings of type 1\n */\nstruct afb_verb_desc_v1\n{\n       const char *name;                       /* name of the method */\n       enum AFB_session_v1 session;            /* authorisation and session requirements of the method */\n       void (*callback)(struct afb_req req);   /* callback function implementing the method */\n       const char *info;                       /* textual description of the method */\n};  For technical reasons, the enumeration  enum AFB_session_v1  is not exactly an\nenumeration but the wrapper of constant definitions that can be mixed using bitwise or\n(the C operator |).  The constants that can bit mixed are:     Constant name  Meaning      AFB_SESSION_CREATE  Equals to AFB_SESSION_LOA_EQ_0    AFB_SESSION_CLOSE  Closes the session after the reply and set the LOA to 0    AFB_SESSION_RENEW  Refreshes the token of authentification    AFB_SESSION_CHECK  Just requires the token authentification    AFB_SESSION_LOA_LE_0  Requires the current LOA to be lesser then or equal to 0    AFB_SESSION_LOA_LE_1  Requires the current LOA to be lesser then or equal to 1    AFB_SESSION_LOA_LE_2  Requires the current LOA to be lesser then or equal to 2    AFB_SESSION_LOA_LE_3  Requires the current LOA to be lesser then or equal to 3    AFB_SESSION_LOA_GE_0  Requires the current LOA to be greater then or equal to 0    AFB_SESSION_LOA_GE_1  Requires the current LOA to be greater then or equal to 1    AFB_SESSION_LOA_GE_2  Requires the current LOA to be greater then or equal to 2    AFB_SESSION_LOA_GE_3  Requires the current LOA to be greater then or equal to 3    AFB_SESSION_LOA_EQ_0  Requires the current LOA to be equal to 0    AFB_SESSION_LOA_EQ_1  Requires the current LOA to be equal to 1    AFB_SESSION_LOA_EQ_2  Requires the current LOA to be equal to 2    AFB_SESSION_LOA_EQ_3  Requires the current LOA to be equal to 3     If any of this flag is set, afb-daemon requires an authentication token\nas if  AFB_SESSION_CHECK  flag was also set.  The special value  AFB_SESSION_NONE  is zero and can be used to bypass token check.   Note that  AFB_SESSION_CREATE  and  AFB_SESSION_CLOSE  might be removed in later versions.", 
            "title": "Initialisation of the binding and declaration of methods"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#sending-messages-to-the-log-system", 
            "text": "Afb-daemon provides 4 levels of verbosity and 5 methods for logging messages.  The verbosity is managed. Options allow the change the verbosity of afb-daemon\nand the verbosity of the bindings can be set binding by binding.  The methods for logging messages are defined as macros that test the\nverbosity level and that call the real logging function only if the\nmessage must be output. This avoid evaluation of arguments of the\nformatting messages if the message must not be output.", 
            "title": "Sending messages to the log system"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#verbs-for-logging-messages", 
            "text": "The 5 logging methods are:     Macro  Verbosity  Meaning  syslog level      ERROR  0  Error conditions  3    WARNING  1  Warning conditions  4    NOTICE  1  Normal but significant condition  5    INFO  2  Informational  6    DEBUG  3  Debug-level messages  7     You can note that the 2 methods  WARNING  and  INFO  have the same level\nof verbosity. But they don't have the same  syslog level . It means that\nthey are output with a different level on the logging system.  All of these methods have the same signature:  void ERROR(const struct afb_binding_interface *afbitf, const char *message, ...);  The first argument  afbitf  is the interface to afb daemon that the\nbinding received at initialisation time when  afbBindingV1Register  is called.  The second argument  message  is a formatting string compatible with printf/sprintf.  The remaining arguments are arguments of the formating message like with printf.", 
            "title": "Verbs for logging messages"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#managing-verbosity", 
            "text": "Depending on the level of verbosity, the messages are output or not.\nThe following table explains what messages will be output depending\nont the verbosity level.     Level of verbosity  Outputed macro      0  ERROR    1  ERROR + WARNING + NOTICE    2  ERROR + WARNING + NOTICE + INFO    3  ERROR + WARNING + NOTICE + INFO + DEBUG", 
            "title": "Managing verbosity"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#output-format-and-destination", 
            "text": "The syslog level is used for forging a prefix to the message.\nThe prefixes are:     syslog level  prefix      0  0  EMERGENCY    1  1  ALERT    2  2  CRITICAL    3  3  ERROR    4  4  WARNING    5  5  NOTICE    6  6  INFO    7  7  DEBUG     The message is pushed to standard error.\nThe final destination of the message depends on how systemd service\nwas configured through its variable  StandardError . It can be\njournal, syslog or kmsg. (See man sd-daemon).", 
            "title": "Output format and destination"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#sending-events", 
            "text": "Since version 0.5, bindings can broadcast events to any potential listener.\nAs today only unattended even are supported. Targeted events are expected for next\ncoming version.  The binding  tic-tac-toe  broadcasts events when the board changes.\nThis is done in the function  changed :  /*\n * signals a change of the board\n */\nstatic void changed(struct board *board, const char *reason)\n{\n    ...\n    struct json_object *description;\n\n    /* get the description */\n    description = describe(board);\n\n    ...\n\n    afb_daemon_broadcast_event(afbitf- daemon, reason, description);\n}  The description of the changed board is pushed via the daemon interface.  Within binding  tic-tac-toe ,  reason  indicates the origin of\nthe change. In function  afb_daemon_broadcast_event  the second\nparameter is the name of broadcasted event. The third argument is the\nobject that is transmitted with the event.  Function  afb_daemon_broadcast_event  is defined here after:  /*\n * Broadcasts widely the event of 'name' with the data 'object'.\n * 'object' can be NULL.\n * 'daemon' MUST be the daemon given in interface when activating the binding.\n *\n * For convenience, the function calls 'json_object_put' for 'object'.\n * Thus, in the case where 'object' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n */\nvoid afb_daemon_broadcast_event(struct afb_daemon daemon, const char *name, struct json_object *object);   Be aware, as with reply functions  object  is automatically released using json_object_put  when using this function. Call  json_object_get  before\ncalling  afb_daemon_broadcast_event  to keep  object  available\nafter function returns.   Event name received by listeners is prefixed with binding name.\nSo when a change occurs after a move, the reason is  move  and every clients\nreceive an event  tictactoe/move .   Note that nothing is said about case sensitivity of event names.\nHowever, the event is always prefixed with the name that the binding\ndeclared, with the same case, followed with a slash /.\nThus it is safe to compare event using a case sensitive comparison.", 
            "title": "Sending events"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#writing-an-asynchronous-method-implementation", 
            "text": "The  tic-tac-toe  example allows two clients or more to share the same board.\nThis is implemented by the method  join  that illustrated partly how to\nretrieve arguments.  When two or more clients are sharing a same board, one of them can wait\nuntil the state of the board changes, but this could also be implemented using\nevents because an even is generated each time the board changes.  In this case, the reply to the wait is sent only when the board changes.\nSee the diagram below:  CLIENT A       CLIENT B         TIC-TAC-TOE\n   |              |                  |\n   +--------------|----------------- | wait . . . . . . . .\n   |              |                  |                     .\n   :              :                  :                      .\n   :              :                  :                      .\n   |              |                  |                      .\n   |              +----------------- | move . . .           .\n   |              |                  |          V           .\n   |              | -----------------+ success of move      .\n   |              |                  |                    .\n   | -------------|------------------+ success of wait     Here, this is an invocation of the binding by an other client that\nunblock the suspended  wait  call.\nNevertheless in most case this should be a timer, a hardware event, a sync with\na concurrent process or thread, ...  Common case of an asynchronous implementation.  Here is the listing of the function  wait :  static void wait(struct afb_req req)\n{\n    struct board *board;\n    struct waiter *waiter;\n\n    /* retrieves the context for the session */\n    board = board_of_req(req);\n    INFO(afbitf,  method 'wait' called for boardid %d , board- id);\n\n    /* creates the waiter and enqueues it */\n    waiter = calloc(1, sizeof *waiter);\n    waiter- req = req;\n    waiter- next = board- waiters;\n    afb_req_addref(req);\n    board- waiters = waiter;\n}  After retrieving the board, the function adds a new waiter to\nwaiters list and returns without setting a reply.  Before returning, it increases  req  request's reference count using  afb_req_addref  function.   When a method returns without setting a reply,\nit  MUST  increment request's reference count\nusing  afb_req_addref . If unpredictable behaviour may pop up.   Later, when a board changes, it calls  tic-tac-toe   changed  function\nwith reason of change in parameter.  Here is the full listing of the function  changed :  /*\n * signals a change of the board\n */\nstatic void changed(struct board *board, const char *reason)\n{\n    struct waiter *waiter, *next;\n    struct json_object *description;\n\n    /* get the description */\n    description = describe(board);\n\n    waiter = board- waiters;\n    board- waiters = NULL;\n    while (waiter != NULL) {\n        next = waiter- next;\n        afb_req_success(waiter- req, json_object_get(description), reason);\n        afb_req_unref(waiter- req);\n        free(waiter);\n        waiter = next;\n    }\n\n    afb_event_sender_push(afb_daemon_get_event_sender(afbitf- daemon), reason, description);\n}  The list of waiters is walked and a reply is sent to each waiter.\nAfter sending the reply, the reference count of the request\nis decremented using  afb_req_unref  to allow resources to be freed.   The reference count  MUST  be decremented using  afb_req_unref  to free\nresources and avoid memory leaks.\nThis usage count decrement should happen  AFTER  setting reply or \nbad things may happen.", 
            "title": "Writing an asynchronous method implementation"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#how-to-build-a-binding", 
            "text": "Afb-daemon provides a  pkg-config  configuration file that can be\nqueried by providing  afb-daemon  in command line arguments.\nThis configuration file provides data that should be used\nfor bindings compilation. Examples:  $ pkg-config --cflags afb-daemon\n$ pkg-config --libs afb-daemon", 
            "title": "How to build a binding"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#example-for-cmake-meta-build-system", 
            "text": "This example is the extract for building the binding  afm-main  using  CMAKE .  pkg_check_modules(afb afb-daemon)\nif(afb_FOUND)\n    message(STATUS  Creation afm-main-binding for AFB-DAEMON )\n    add_library(afm-main-binding MODULE afm-main-binding.c)\n    target_compile_options(afm-main-binding PRIVATE ${afb_CFLAGS})\n    target_include_directories(afm-main-binding PRIVATE ${afb_INCLUDE_DIRS})\n    target_link_libraries(afm-main-binding utils ${afb_LIBRARIES})\n    set_target_properties(afm-main-binding PROPERTIES\n        PREFIX  \n        LINK_FLAGS  -Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/afm-main-binding.export-map \n    )\n    install(TARGETS afm-main-binding LIBRARY DESTINATION ${binding_dir})\nelse()\n    message(STATUS  Not creating the binding for AFB-DAEMON )\nendif()  Let now describe some of these lines.  pkg_check_modules(afb afb-daemon)  This first lines searches to the  pkg-config  configuration file for afb-daemon . Resulting data are stored in the following variables:     Variable  Meaning      afb_FOUND  Set to 1 if afb-daemon binding development files exist    afb_LIBRARIES  Only the libraries (w/o the '-l') for compiling afb-daemon bindings    afb_LIBRARY_DIRS  The paths of the libraries (w/o the '-L') for compiling afb-daemon bindings    afb_LDFLAGS  All required linker flags for compiling afb-daemon bindings    afb_INCLUDE_DIRS  The '-I' preprocessor flags (w/o the '-I') for compiling afb-daemon bindings    afb_CFLAGS  All required cflags for compiling afb-daemon bindings     If development files are found, the binding can be added to the set of\ntarget to build.  add_library(afm-main-binding MODULE afm-main-binding.c)  This line asks to create a shared library having a single\nsource file named afm-main-binding.c to be compiled.\nThe default name of the created shared object is libafm-main-binding.so .  set_target_properties(afm-main-binding PROPERTIES\n    PREFIX  \n    LINK_FLAGS  -Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/afm-main-binding.export-map \n)  This lines are doing two things:    It renames the built library from  libafm-main-binding.so  to  afm-main-binding.so \nby removing the implicitly added prefix  lib . This step is not mandatory\nbecause afb-daemon doesn't check names of files at load time.\nThe only filename convention used by afb-daemon relates to  .so  termination.\n*.so pattern is used when afb-daemon automatically discovers binding from a directory hierarchy.    It applies a version script at link time to only export the reserved name afbBindingV1Register  for registration entry point. By default, when building \na shared library linker exports all the public symbols (C functions that are not  static ).    Next line are:  target_include_directories(afm-main-binding PRIVATE ${afb_INCLUDE_DIRS})\ntarget_link_libraries(afm-main-binding utils ${afb_LIBRARIES})  As you can see it uses the variables computed by  pkg_check_modules(afb afb-daemon) \nto configure the compiler and the linker.", 
            "title": "Example for cmake meta build system"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#exporting-the-function-afbbindingv1register", 
            "text": "The function  afbBindingV1Register  MUST be exported. This can be achieved\nusing a version script at link time. Here after is a version script used for tic-tac-toe  (bindings/samples/export.map).  { global: afbBindingV1Register; local: *; };  This sample  version script \nexports as global the symbol  afbBindingV1Register  and hides any\nother symbols.  This version script is added to the link options using the\noption  --version-script=export.map  is given directly to the\nlinker or using the option  -Wl,--version-script=export.map \nwhen the option is given to the C compiler.", 
            "title": "Exporting the function afbBindingV1Register"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-bindings-writing/#building-within-yocto", 
            "text": "Adding a dependency to afb-daemon is enough. See below:  DEPENDS += \" afb-daemon \"", 
            "title": "Building within yocto"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/", 
            "text": "Vocabulary for AFB-DAEMON\n\n\nBinding\n\n\nA shared library object intended to be add a functionnality to an afb-daemon\ninstance. It implements an API. It may provide a service.\n\n\nBinding made for services can have specific entry point called after\ninitialisation and before serving.\n\n\nEvent\n\n\nMessage with data propagated from the services to the client and not expecting\nany reply.\n\n\nThe current implementation allows to widely broadcast events to all clients.\n\n\nLevel of assurance (LOA)\n\n\nThis level that can be from 0 to 3 represent the level of\nassurance that the services can expect from the session.\n\n\nThe exact definition of the meaning of this levels and of\nhow to use it remains to be achived.\n\n\nPlugin\n\n\nOld name for binding, see binding.\n\n\nRequest\n\n\nA request is an invocation by a client to a method of a binding using a message\ntransfered through some protocol: HTTP, WebSocket, DBUS... served by afb-daemon\n\n\nReply/Response\n\n\nThis is a message sent to client as the result of the request.\n\n\nService\n\n\nService are made of binding runnning by their side on their binder.\nIt can serve many client. Each one being attached to one session.\n\n\nThe framework establishes the connection between the services and\nthe clients. Using DBus currently but other protocols are considered.\n\n\nSession\n\n\nA session is meant to be the unic context of an instance of client, \nidentifying that instance across requests.\n\n\nEach session has an identifier. Session identifier generated by afb-daemon are UUIDs.\n\n\nInternally, afb-daemon offers a mechanism to attach data to sessions.\nWhen the session is closed or disappears, the data attached to that session\nare freed.\n\n\nToken\n\n\nThe token is an identifier that the the client must give to be authentificated.\n\n\nAt start, afb-daemon get an initial token. This initial token must be presented\nincoming client to be authentificated.\n\n\nA token is valid only for a period.\n\n\nThe token must be renewed periodically. When the token is renewed, afb-daemon\nsends the new token to the client.\n\n\nTokens generated by afb-daemon are UUIDs.\n\n\nUUID\n\n\nIt stand for Universal Unic IDentifier.\n\n\nIts is designed to create identifier in a way that avoid has much as possible conflicts.\nIt means that if two differents instance create a UUID, the probability that they create the same UUID is very low, near to zero.\n\n\nx-afb-reqid\n\n\nArgument name that can be used with HTTP request.\nWhen this argument is given, it is automatically added to the \"request\" object of the\nanswer.\n\n\nx-afb-token\n\n\nArgument name for giving the token without ambiguity.\nYou can also use the name \ntoken\n but it may conflicts with other arguments.\n\n\nx-afb-uuid\n\n\nArgument name for giving explicitely the session identifier without ambiguity.\nYou can also use the name \nuuid\n but it may conflicts with other arguments.", 
            "title": "Afb daemon vocabulary"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#vocabulary-for-afb-daemon", 
            "text": "", 
            "title": "Vocabulary for AFB-DAEMON"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#binding", 
            "text": "A shared library object intended to be add a functionnality to an afb-daemon\ninstance. It implements an API. It may provide a service.  Binding made for services can have specific entry point called after\ninitialisation and before serving.", 
            "title": "Binding"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#event", 
            "text": "Message with data propagated from the services to the client and not expecting\nany reply.  The current implementation allows to widely broadcast events to all clients.", 
            "title": "Event"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#level-of-assurance-loa", 
            "text": "This level that can be from 0 to 3 represent the level of\nassurance that the services can expect from the session.  The exact definition of the meaning of this levels and of\nhow to use it remains to be achived.", 
            "title": "Level of assurance (LOA)"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#plugin", 
            "text": "Old name for binding, see binding.", 
            "title": "Plugin"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#request", 
            "text": "A request is an invocation by a client to a method of a binding using a message\ntransfered through some protocol: HTTP, WebSocket, DBUS... served by afb-daemon", 
            "title": "Request"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#replyresponse", 
            "text": "This is a message sent to client as the result of the request.", 
            "title": "Reply/Response"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#service", 
            "text": "Service are made of binding runnning by their side on their binder.\nIt can serve many client. Each one being attached to one session.  The framework establishes the connection between the services and\nthe clients. Using DBus currently but other protocols are considered.", 
            "title": "Service"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#session", 
            "text": "A session is meant to be the unic context of an instance of client, \nidentifying that instance across requests.  Each session has an identifier. Session identifier generated by afb-daemon are UUIDs.  Internally, afb-daemon offers a mechanism to attach data to sessions.\nWhen the session is closed or disappears, the data attached to that session\nare freed.", 
            "title": "Session"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#token", 
            "text": "The token is an identifier that the the client must give to be authentificated.  At start, afb-daemon get an initial token. This initial token must be presented\nincoming client to be authentificated.  A token is valid only for a period.  The token must be renewed periodically. When the token is renewed, afb-daemon\nsends the new token to the client.  Tokens generated by afb-daemon are UUIDs.", 
            "title": "Token"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#uuid", 
            "text": "It stand for Universal Unic IDentifier.  Its is designed to create identifier in a way that avoid has much as possible conflicts.\nIt means that if two differents instance create a UUID, the probability that they create the same UUID is very low, near to zero.", 
            "title": "UUID"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#x-afb-reqid", 
            "text": "Argument name that can be used with HTTP request.\nWhen this argument is given, it is automatically added to the \"request\" object of the\nanswer.", 
            "title": "x-afb-reqid"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#x-afb-token", 
            "text": "Argument name for giving the token without ambiguity.\nYou can also use the name  token  but it may conflicts with other arguments.", 
            "title": "x-afb-token"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-daemon-vocabulary/#x-afb-uuid", 
            "text": "Argument name for giving explicitely the session identifier without ambiguity.\nYou can also use the name  uuid  but it may conflicts with other arguments.", 
            "title": "x-afb-uuid"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/", 
            "text": "Guide for developing with events\n\n\nSignaling agents are services that send events to any clients that\nsubscribed for receiving it. The sent events carry any data.\n\n\nTo have a good understanding of how to write a signaling agent, the\nactions of subscribing, unsubscribing, producing, sending, receiving\nevents must be described and explained.\n\n\nOverview of events\n\n\nThe basis of a signaling agent is shown on the following figure:\n\n\n\n\nThis figure shows the main role of the signaling framework for the\npropagation of events.\n\n\nFor people not familiar with the framework, a signaling agent and\na \u201cbinding\u201d are similar.\n\n\nSubscribing and unsubscribing\n\n\nSubscribing and subscription is the action that makes a client able to\nreceive data from a signaling agent. Subscription must create resources\nfor generating the data and for delivering the data to the client. These\ntwo aspects are not handled by the same piece of software: generating\nthe data is the responsibility of the developer of the signaling agent\nwhile delivering the data is handled by the framework.\n\n\nWhen a client subscribes for data, the agent must:\n\n\n\n\ncheck that the subscription request is correct;\n\n\nestablish the computation chain of the required data, if not already\n    done;\n\n\ncreate a named event for the computed data, if not already done;\n\n\nask the framework to establish the subscription to the event for the\n    request;\n\n\noptionally give indications about the event in the reply to\n    the client.\n\n\n\n\nThe first two steps are not involving the framework. They are linked to\nthe business logic of the binding. The request can be any description of\nthe requested data and the computing stream can be of any nature, this\nis specific to the binding.\n\n\nAs said before, the framework uses and integrates \u201clibsystemd\u201d and its event\nloop. Within the framework, \"libsystemd\" is the standard API/library for\nbindings expecting to setup and handle I/O, timer or signal events.\n\n\nSteps 3 and 4 are bound to the framework.\n\n\nThe agent must create an object for handling the propagation of produced\ndata to its clients. That object is called \u201cevent\u201d in the framework. An\nevent has a name that allows clients to distinguish it from other\nevents.\n\n\nEvents are created using the \nafb_daemon_make_event\n function\nthat takes the name of the event. Example:\n\n\n    event = afb_daemon_make_event(afb_daemon, name);\n\n\n\n\nOnce created, the event can be used either to push data to its\nsubscribers or to broadcast data to any listener.\n\n\nThe event must be used to establish the subscription for the requesting\nclient. This is done using the \nafb_req_subscribe\n function\nthat takes the current request object and event and associates them\ntogether. Example:\n\n\n    rc = afb_req_subscribe(afb_req, event);\n\n\n\n\nWhen successful, this function make the connection between the event and\nthe client that emitted the request. The client becomes a subscriber of\nthe event until it unsubscribes or disconnects. The\n\nafb_req_subscribe\n function will fail if the client\nconnection is weak: if the request comes from a HTTP link. To receive\nsignals, the client must be connected. The AGL framework allows\nconnections using WebSocket.\n\n\nThe name of the event is either a well known name or an ad hoc name\nforged for the usecase.\n\n\nLet's see a basic example: client A expects to receive the speed in km/h\nevery second while client B expects the speed in mph twice a second. In\nthat case, there are two different events because it is not the same\nunit and it is not the same frequency. Having two different events\nallows to associate clients to the correct event. But this doesn't tell\nany word about the name of these events. The designer of the signaling\nagent has two options for naming:\n\n\n\n\nnames can be the same (\u201cspeed\u201d for example) with sent data\n    self-describing itself or having a specific tag (requiring from\n    clients awareness about requesting both kinds of speed isn't safe).\n\n\nnames of the event include the variations (by example:\n    \u201cspeed-km/h-1Hz\u201d and \u201cspeed-mph-2Hz\u201d) and, in that case, sent data\n    can self-describe itself or not.\n\n\n\n\nIn both cases, the signaling agent might have to send the name of the\nevent and/or an associated tag to its client in the reply of the\nsubscription. This is part of the step 5 above.\n\n\nThe framework only uses the event (not its name) for subscription,\nunsubscription and pushing.\n\n\nWhen the requested data is already generated and the event used for\npushing it already exists, the signaling agent must not instantiate a\nnew processing chain and must not create a new event object for pushing\ndata. The signaling agent must reuse the existing chain and event.\n\n\nUnsubscribing is made by the signaling agent on a request of its client.\nThe \nafb_req_unsubscribe\n function tells the framework to\nremove the requesting client from the event's list of subscribers.\nExample:\n\n\n    afb_req_unsubscribe(afb_req, event);\n\n\n\n\nSubscription count does not matter to the framework: subscribing the\nsame client several times has the same effect that subscribing only one\ntime. Thus, when unsubscribing is invoked, it becomes immediately\neffective.\n\n\nMore on naming events\n\n\nWithin the AGL framework, a signaling agent is a binding that has an API\nprefix. This prefix is meant to be unique and to identify the binding\nAPI. The names of the events that this signaling agent creates are\nautomatically prefixed by the framework, using the API prefix of the\nbinding.\n\n\nThus, if a signaling agent of API prefix \napi\n creates an event\nof name \nevent\n and pushes data to that event, the subscribers\nwill receive an event of name \napi/event\n.\n\n\nGenerating and pushing signals and data\n\n\nThis of the responsibility of the designer of the signaling agent to\nestablish the processing chain for generating events. In many cases,\nthis can be achieved using I/O or timer or signal events inserted in the\nmain loop. For this case, the AGL framework uses \u201clibsystemd\u201d and\nprovide a way to integrates to the main loop of this library using\nafb_daemon_get_event_loop. Example:\n\n\n    sdev = afb_daemon_get_event_loop(af_daemon);\n    rc = sd_event_add_io(sdev, \nsource, fd, EPOLLIN, myfunction, NULL);\n\n\n\n\nIn some other cases, the events are coming from D-Bus. In that case, the\nframework also uses \u201clibsystemd\u201d internally to access D-Bus. It provides\ntwo methods to get the available D-Bus objects, already existing and\nbound to the main libsystemd event loop. Use either\n\nafb_daemon_get_system_bus\n or\n\nafb_daemon_get_user_bus\n to get the required instance. Then\nuse functions of \u201clibsystemd\u201d to handle D-Bus.\n\n\nIn some rare cases, the generation of the data requires to start a new\nthread.\n\n\nWhen a data is generated and ready to be pushed, the signaling agent\nshould call the function \nafb_event_push\n. Example:\n\n\n    rc = afb_event_push(event, json);\n    if (rc == 0) {\n        stop_generating(event);\n        afb_event_drop(event);\n    }\n\n\n\n\nThe function \nafb_event_push\n pushes json data to all the\nsubscribers. It then returns the count of subscribers. When the count is\nzero, there is no subscriber listening for the event. The example above\nshows that in that case, the signaling agent stops to generate data for\nthe event and delete the event using afb_event_drop. This is one\npossible option. Other valuable options are: do nothing and continue to\ngenerate and push the event or just stop to generate and push the data\nbut keep the event existing.\n\n\nReceiving the signals\n\n\nUnderstanding what a client expects when it receives signals, events or\ndata shall be the most important topic of the designer of a signaling\nagent. The good point here is that because JSON[^1] is the exchange\nformat, structured data can be sent in a flexible way.\n\n\nThe good design is to allow as much as possible the client to describe\nwhat is needed with the goal to optimize the processing to the\nrequirements only.\n\n\nThe exceptional case of wide broadcast\n\n\nSome data or events have so much importance that they can be widely\nbroadcasted to alert any listening client. Examples of such an alert\nare:\n\n\n\n\nsystem is entering/leaving \u201cpower safe\u201d mode\n\n\nsystem is shutting down\n\n\nthe car starts/stops moving\n\n\n...\n\n\n\n\nAn event can be broadcasted using one of the two following methods:\n\nafb_daemon_broadcast_event\n or\n\nafb_event_broadcast\n.\n\n\nExample 1:\n\n\n    afb_daemon_broadcast_event(afb_daemon, name, json);\n\n\n\n\nExample 2:\n\n\n    event = afb_daemon_make_event(afb_daemon, name);\n    . . . .\n    afb_event_broadcast(event, json);\n\n\n\n\nAs for other events, the name of events broadcasted using\n\nafb_daemon_broadcast_event\n are automatically prefixed by\nthe framework with API prefix of the binding (signaling agent).\n\n\nReference of functions\n\n\nFunction afb_event afb_daemon_make_event\n\n\nThe function \nafb_daemon_make_event\n that is defined as below:\n\n\n/*\n * Creates an event of 'name' and returns it.\n * 'daemon' MUST be the daemon given in interface when activating the binding.\n */\nstruct afb_event afb_daemon_make_event(struct afb_daemon daemon, const char *name);\n\n\n\n\nThe daemon is the handler to the application framework binder daemon\nreceived during initialisation steps of the binding.\n\n\nCalling the function \nafb_daemon_make_event\n within the initialisation\nfunction \nafbBindingV1Register\n will \nfail\n because the plugin\nname is not known at this time.\n\n\nThe correct way to create the event at initialisation is to call the function\n\nafb_daemon_make_event\n within the initialisation\nfunction \nafbBindingV1ServiceInit\n.\n\n\nFunction afb_event_push\n\n\nThe function \nafb_event_push\n is defined as below:\n\n\n/*\n * Pushes the 'event' with the data 'object' to its observers.\n * 'object' can be NULL.\n *\n * For convenience, the function calls 'json_object_put' for object'.\n * Thus, in the case where 'object' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n *\n * Returns the count of clients that received the event.\n */\nint afb_event_push(struct afb_event event, struct json_object *object);\n\n\n\n\nAs the function \nafb_event_push\n returns 0 when there is no\nmore subscriber, a binding can remove such unexpected event using the\nfunction \nafb_event_drop\n.\n\n\nFunction afb_event_drop\n\n\nThe function \nafb_event_drop\n is defined as below:\n\n\n/*\n * Drops the data associated to the event\n * After calling this function, the event\n * MUST NOT BE USED ANYMORE.\n */\nvoid afb_event_drop(struct afb_event event);\n\n\n\n\nFunction afb_req_subscribe\n\n\nThe function \nafb_req_subscribe\n is defined as below:\n\n\n/*\n * Establishes for the client link identified by 'req' a subscription\n * to the 'event'.\n * Returns 0 in case of successful subscription or -1 in case of error.\n */\nint afb_req_subscribe(struct afb_req req, struct afb_event event);\n\n\n\n\nThe subscription adds the client of the request to the list of subscribers\nto the event.\n\n\nFunction afb_req_unsubscribe\n\n\nThe function \nafb_req_unsubscribe\n is defined as\nbelow:\n\n\n/*\n * Revokes the subscription established to the 'event' for the client\n * link identified by 'req'.\n * Returns 0 in case of successful unsubscription or -1 in case of error.\n */\nint afb_req_unsubscribe(struct afb_req req, struct afb_event event);\n\n\n\n\nThe unsubscription removes the client of the request of the list of subscribers\nto the event.\nWhen the list of subscribers to the event becomes empty,\nthe function \nafb_event_push\n will return zero.\n\n\nFunction afb_event_broadcast\n\n\nThe function \nafb_event_broadcast\n is defined as below:\n\n\n/*\n * Broadcasts widely the 'event' with the data 'object'.\n * 'object' can be NULL.\n *\n * For convenience, the function calls 'json_object_put' for 'object'.\n * Thus, in the case where 'object' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n *\n * Returns the count of clients that received the event.\n */\nint afb_event_broadcast(struct afb_event event, struct json_object *object);\n\n\n\n\nThis uses an existing event (created with \nafb_daemon_make_event\n)\nfor broadcasting an event having its name.\n\n\nFunction afb_daemon_broadcast_event\n\n\nThe function \nafb_daemon_broadcast_event\n is defined as below:\n\n\n/*\n * Broadcasts widely the event of 'name' with the data 'object'.\n * 'object' can be NULL.\n * 'daemon' MUST be the daemon given in interface when activating the binding.\n *\n * For convenience, the function calls 'json_object_put' for 'object'.\n * Thus, in the case where 'object' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n *\n * Returns the count of clients that received the event.\n */\nint afb_daemon_broadcast_event(struct afb_daemon daemon, const char *name, struct json_object *object);\n\n\n\n\nThe name is given here explicitely. The name is automatically prefixed\nwith the name of the binding. For example, a binding of prefix \"xxx\"\nwould broadcat the event \"xxx/name\".\n\n\nArchitectural digressions\n\n\nBased on their dependencies to hardware, signaling agents can be split\ninto 2 categories: low-level signaling agents and high-level signaling\nagents.\n\n\nLow-level signaling agents are bound to the hardware and focused on\ninterfacing and driving.\n\n\nHigh-level signaling agent are independent of the hardware and ocused on\nproviding service.\n\n\nThis separation (that may in the corner look artificial) aim to help in\nthe systems design. The main idea here is that high-level signaling\nagents are providing \u201cbusiness logic\u201d, also known as \u201capplication\nlogic\u201d, that is proper to the car industry and that can be reused and\nthat can evolve as a foundation for the future of the industry.\n\n\nThe implementation of this decomposition may follow 2 paths: strict\nseparation or soft composition.\n\n\nStrict separation\n\n\nThe strict separation implements the modularity composition of signaling\nagent through the framework. The high-level signaling agent subscribes\nto the low level signaling agent using the standard client API.\n\n\nAdvantages:\n\n\n\n\nModularity\n\n\nSeparation of responsibilities\n\n\nPossible aggregation of multiple sources\n\n\nSoft binding of agent good for maintenance\n\n\n\n\nDrawbacks:\n\n\n\n\nCost of propagation of data (might serialize)\n\n\nDifficulties to abstract low-level signaling agent or to find a\n    trade-of between abstracting and specializing\n\n\n\n\nThe key is modularity versus cost of propagation. It can be partly\nsolved when logical group of signaling agent are launched together in\nthe same binder process. In that particular case, the cost of\npropagation of data between agents is reduced[^2] because there is no\nserialization.\n\n\nThis reduction of the propagation cost (and of the resources used)\nprecludes implementation of strong security between the agents because\nthey share the same memory.\n\n\nSoft composition\n\n\nThe soft composition implements the business logic of high-level\nsignaling agents as libraries that can then be used directly by the low\nlevel signaling agents.\n\n\nAdvantages:\n\n\n\n\nNo propagation: same memory, sharing of native structures\n\n\n\n\nDrawbacks:\n\n\n\n\nCannot be used for aggregation of several sources\n\n\nDifficulties to abstract low-level signaling agent or to find a\n    trade-of between abstracting and specializing\n\n\nSource code binding not good for maintenance\n\n\n\n\n[^1]: There are two aspect in using JSON: the first is the flexible data\n    structure that mixes common types (booleans, numbers, strings,\n    arrays, dictionaries, nulls), the second, is the streaming\n    specification. Streaming is often seen as the bottleneck of using\n    JSON (see http://bjson.org). When the agent share the same process,\n    there is no streaming at all.\n\n\n[^2]: Within the same process, there is not serialization, the\n    propagation has the cost of wrapping a json data and calling\n    callbacks with the benefit of having a powerful callback manager:\n    the event mechanism of the framework.", 
            "title": "Afb events guide"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#guide-for-developing-with-events", 
            "text": "Signaling agents are services that send events to any clients that\nsubscribed for receiving it. The sent events carry any data.  To have a good understanding of how to write a signaling agent, the\nactions of subscribing, unsubscribing, producing, sending, receiving\nevents must be described and explained.", 
            "title": "Guide for developing with events"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#overview-of-events", 
            "text": "The basis of a signaling agent is shown on the following figure:   This figure shows the main role of the signaling framework for the\npropagation of events.  For people not familiar with the framework, a signaling agent and\na \u201cbinding\u201d are similar.", 
            "title": "Overview of events"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#subscribing-and-unsubscribing", 
            "text": "Subscribing and subscription is the action that makes a client able to\nreceive data from a signaling agent. Subscription must create resources\nfor generating the data and for delivering the data to the client. These\ntwo aspects are not handled by the same piece of software: generating\nthe data is the responsibility of the developer of the signaling agent\nwhile delivering the data is handled by the framework.  When a client subscribes for data, the agent must:   check that the subscription request is correct;  establish the computation chain of the required data, if not already\n    done;  create a named event for the computed data, if not already done;  ask the framework to establish the subscription to the event for the\n    request;  optionally give indications about the event in the reply to\n    the client.   The first two steps are not involving the framework. They are linked to\nthe business logic of the binding. The request can be any description of\nthe requested data and the computing stream can be of any nature, this\nis specific to the binding.  As said before, the framework uses and integrates \u201clibsystemd\u201d and its event\nloop. Within the framework, \"libsystemd\" is the standard API/library for\nbindings expecting to setup and handle I/O, timer or signal events.  Steps 3 and 4 are bound to the framework.  The agent must create an object for handling the propagation of produced\ndata to its clients. That object is called \u201cevent\u201d in the framework. An\nevent has a name that allows clients to distinguish it from other\nevents.  Events are created using the  afb_daemon_make_event  function\nthat takes the name of the event. Example:      event = afb_daemon_make_event(afb_daemon, name);  Once created, the event can be used either to push data to its\nsubscribers or to broadcast data to any listener.  The event must be used to establish the subscription for the requesting\nclient. This is done using the  afb_req_subscribe  function\nthat takes the current request object and event and associates them\ntogether. Example:      rc = afb_req_subscribe(afb_req, event);  When successful, this function make the connection between the event and\nthe client that emitted the request. The client becomes a subscriber of\nthe event until it unsubscribes or disconnects. The afb_req_subscribe  function will fail if the client\nconnection is weak: if the request comes from a HTTP link. To receive\nsignals, the client must be connected. The AGL framework allows\nconnections using WebSocket.  The name of the event is either a well known name or an ad hoc name\nforged for the usecase.  Let's see a basic example: client A expects to receive the speed in km/h\nevery second while client B expects the speed in mph twice a second. In\nthat case, there are two different events because it is not the same\nunit and it is not the same frequency. Having two different events\nallows to associate clients to the correct event. But this doesn't tell\nany word about the name of these events. The designer of the signaling\nagent has two options for naming:   names can be the same (\u201cspeed\u201d for example) with sent data\n    self-describing itself or having a specific tag (requiring from\n    clients awareness about requesting both kinds of speed isn't safe).  names of the event include the variations (by example:\n    \u201cspeed-km/h-1Hz\u201d and \u201cspeed-mph-2Hz\u201d) and, in that case, sent data\n    can self-describe itself or not.   In both cases, the signaling agent might have to send the name of the\nevent and/or an associated tag to its client in the reply of the\nsubscription. This is part of the step 5 above.  The framework only uses the event (not its name) for subscription,\nunsubscription and pushing.  When the requested data is already generated and the event used for\npushing it already exists, the signaling agent must not instantiate a\nnew processing chain and must not create a new event object for pushing\ndata. The signaling agent must reuse the existing chain and event.  Unsubscribing is made by the signaling agent on a request of its client.\nThe  afb_req_unsubscribe  function tells the framework to\nremove the requesting client from the event's list of subscribers.\nExample:      afb_req_unsubscribe(afb_req, event);  Subscription count does not matter to the framework: subscribing the\nsame client several times has the same effect that subscribing only one\ntime. Thus, when unsubscribing is invoked, it becomes immediately\neffective.", 
            "title": "Subscribing and unsubscribing"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#more-on-naming-events", 
            "text": "Within the AGL framework, a signaling agent is a binding that has an API\nprefix. This prefix is meant to be unique and to identify the binding\nAPI. The names of the events that this signaling agent creates are\nautomatically prefixed by the framework, using the API prefix of the\nbinding.  Thus, if a signaling agent of API prefix  api  creates an event\nof name  event  and pushes data to that event, the subscribers\nwill receive an event of name  api/event .", 
            "title": "More on naming events"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#generating-and-pushing-signals-and-data", 
            "text": "This of the responsibility of the designer of the signaling agent to\nestablish the processing chain for generating events. In many cases,\nthis can be achieved using I/O or timer or signal events inserted in the\nmain loop. For this case, the AGL framework uses \u201clibsystemd\u201d and\nprovide a way to integrates to the main loop of this library using\nafb_daemon_get_event_loop. Example:      sdev = afb_daemon_get_event_loop(af_daemon);\n    rc = sd_event_add_io(sdev,  source, fd, EPOLLIN, myfunction, NULL);  In some other cases, the events are coming from D-Bus. In that case, the\nframework also uses \u201clibsystemd\u201d internally to access D-Bus. It provides\ntwo methods to get the available D-Bus objects, already existing and\nbound to the main libsystemd event loop. Use either afb_daemon_get_system_bus  or afb_daemon_get_user_bus  to get the required instance. Then\nuse functions of \u201clibsystemd\u201d to handle D-Bus.  In some rare cases, the generation of the data requires to start a new\nthread.  When a data is generated and ready to be pushed, the signaling agent\nshould call the function  afb_event_push . Example:      rc = afb_event_push(event, json);\n    if (rc == 0) {\n        stop_generating(event);\n        afb_event_drop(event);\n    }  The function  afb_event_push  pushes json data to all the\nsubscribers. It then returns the count of subscribers. When the count is\nzero, there is no subscriber listening for the event. The example above\nshows that in that case, the signaling agent stops to generate data for\nthe event and delete the event using afb_event_drop. This is one\npossible option. Other valuable options are: do nothing and continue to\ngenerate and push the event or just stop to generate and push the data\nbut keep the event existing.", 
            "title": "Generating and pushing signals and data"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#receiving-the-signals", 
            "text": "Understanding what a client expects when it receives signals, events or\ndata shall be the most important topic of the designer of a signaling\nagent. The good point here is that because JSON[^1] is the exchange\nformat, structured data can be sent in a flexible way.  The good design is to allow as much as possible the client to describe\nwhat is needed with the goal to optimize the processing to the\nrequirements only.", 
            "title": "Receiving the signals"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#the-exceptional-case-of-wide-broadcast", 
            "text": "Some data or events have so much importance that they can be widely\nbroadcasted to alert any listening client. Examples of such an alert\nare:   system is entering/leaving \u201cpower safe\u201d mode  system is shutting down  the car starts/stops moving  ...   An event can be broadcasted using one of the two following methods: afb_daemon_broadcast_event  or afb_event_broadcast .  Example 1:      afb_daemon_broadcast_event(afb_daemon, name, json);  Example 2:      event = afb_daemon_make_event(afb_daemon, name);\n    . . . .\n    afb_event_broadcast(event, json);  As for other events, the name of events broadcasted using afb_daemon_broadcast_event  are automatically prefixed by\nthe framework with API prefix of the binding (signaling agent).", 
            "title": "The exceptional case of wide broadcast"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#reference-of-functions", 
            "text": "", 
            "title": "Reference of functions"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#function-afb95event-afb95daemon95make95event", 
            "text": "The function  afb_daemon_make_event  that is defined as below:  /*\n * Creates an event of 'name' and returns it.\n * 'daemon' MUST be the daemon given in interface when activating the binding.\n */\nstruct afb_event afb_daemon_make_event(struct afb_daemon daemon, const char *name);  The daemon is the handler to the application framework binder daemon\nreceived during initialisation steps of the binding.  Calling the function  afb_daemon_make_event  within the initialisation\nfunction  afbBindingV1Register  will  fail  because the plugin\nname is not known at this time.  The correct way to create the event at initialisation is to call the function afb_daemon_make_event  within the initialisation\nfunction  afbBindingV1ServiceInit .", 
            "title": "Function afb_event afb_daemon_make_event"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#function-afb95event95push", 
            "text": "The function  afb_event_push  is defined as below:  /*\n * Pushes the 'event' with the data 'object' to its observers.\n * 'object' can be NULL.\n *\n * For convenience, the function calls 'json_object_put' for object'.\n * Thus, in the case where 'object' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n *\n * Returns the count of clients that received the event.\n */\nint afb_event_push(struct afb_event event, struct json_object *object);  As the function  afb_event_push  returns 0 when there is no\nmore subscriber, a binding can remove such unexpected event using the\nfunction  afb_event_drop .", 
            "title": "Function afb_event_push"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#function-afb95event95drop", 
            "text": "The function  afb_event_drop  is defined as below:  /*\n * Drops the data associated to the event\n * After calling this function, the event\n * MUST NOT BE USED ANYMORE.\n */\nvoid afb_event_drop(struct afb_event event);", 
            "title": "Function afb_event_drop"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#function-afb95req95subscribe", 
            "text": "The function  afb_req_subscribe  is defined as below:  /*\n * Establishes for the client link identified by 'req' a subscription\n * to the 'event'.\n * Returns 0 in case of successful subscription or -1 in case of error.\n */\nint afb_req_subscribe(struct afb_req req, struct afb_event event);  The subscription adds the client of the request to the list of subscribers\nto the event.", 
            "title": "Function afb_req_subscribe"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#function-afb95req95unsubscribe", 
            "text": "The function  afb_req_unsubscribe  is defined as\nbelow:  /*\n * Revokes the subscription established to the 'event' for the client\n * link identified by 'req'.\n * Returns 0 in case of successful unsubscription or -1 in case of error.\n */\nint afb_req_unsubscribe(struct afb_req req, struct afb_event event);  The unsubscription removes the client of the request of the list of subscribers\nto the event.\nWhen the list of subscribers to the event becomes empty,\nthe function  afb_event_push  will return zero.", 
            "title": "Function afb_req_unsubscribe"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#function-afb95event95broadcast", 
            "text": "The function  afb_event_broadcast  is defined as below:  /*\n * Broadcasts widely the 'event' with the data 'object'.\n * 'object' can be NULL.\n *\n * For convenience, the function calls 'json_object_put' for 'object'.\n * Thus, in the case where 'object' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n *\n * Returns the count of clients that received the event.\n */\nint afb_event_broadcast(struct afb_event event, struct json_object *object);  This uses an existing event (created with  afb_daemon_make_event )\nfor broadcasting an event having its name.", 
            "title": "Function afb_event_broadcast"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#function-afb95daemon95broadcast95event", 
            "text": "The function  afb_daemon_broadcast_event  is defined as below:  /*\n * Broadcasts widely the event of 'name' with the data 'object'.\n * 'object' can be NULL.\n * 'daemon' MUST be the daemon given in interface when activating the binding.\n *\n * For convenience, the function calls 'json_object_put' for 'object'.\n * Thus, in the case where 'object' should remain available after\n * the function returns, the function 'json_object_get' shall be used.\n *\n * Returns the count of clients that received the event.\n */\nint afb_daemon_broadcast_event(struct afb_daemon daemon, const char *name, struct json_object *object);  The name is given here explicitely. The name is automatically prefixed\nwith the name of the binding. For example, a binding of prefix \"xxx\"\nwould broadcat the event \"xxx/name\".", 
            "title": "Function afb_daemon_broadcast_event"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#architectural-digressions", 
            "text": "Based on their dependencies to hardware, signaling agents can be split\ninto 2 categories: low-level signaling agents and high-level signaling\nagents.  Low-level signaling agents are bound to the hardware and focused on\ninterfacing and driving.  High-level signaling agent are independent of the hardware and ocused on\nproviding service.  This separation (that may in the corner look artificial) aim to help in\nthe systems design. The main idea here is that high-level signaling\nagents are providing \u201cbusiness logic\u201d, also known as \u201capplication\nlogic\u201d, that is proper to the car industry and that can be reused and\nthat can evolve as a foundation for the future of the industry.  The implementation of this decomposition may follow 2 paths: strict\nseparation or soft composition.", 
            "title": "Architectural digressions"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#strict-separation", 
            "text": "The strict separation implements the modularity composition of signaling\nagent through the framework. The high-level signaling agent subscribes\nto the low level signaling agent using the standard client API.  Advantages:   Modularity  Separation of responsibilities  Possible aggregation of multiple sources  Soft binding of agent good for maintenance   Drawbacks:   Cost of propagation of data (might serialize)  Difficulties to abstract low-level signaling agent or to find a\n    trade-of between abstracting and specializing   The key is modularity versus cost of propagation. It can be partly\nsolved when logical group of signaling agent are launched together in\nthe same binder process. In that particular case, the cost of\npropagation of data between agents is reduced[^2] because there is no\nserialization.  This reduction of the propagation cost (and of the resources used)\nprecludes implementation of strong security between the agents because\nthey share the same memory.", 
            "title": "Strict separation"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-events-guide/#soft-composition", 
            "text": "The soft composition implements the business logic of high-level\nsignaling agents as libraries that can then be used directly by the low\nlevel signaling agents.  Advantages:   No propagation: same memory, sharing of native structures   Drawbacks:   Cannot be used for aggregation of several sources  Difficulties to abstract low-level signaling agent or to find a\n    trade-of between abstracting and specializing  Source code binding not good for maintenance   [^1]: There are two aspect in using JSON: the first is the flexible data\n    structure that mixes common types (booleans, numbers, strings,\n    arrays, dictionaries, nulls), the second, is the streaming\n    specification. Streaming is often seen as the bottleneck of using\n    JSON (see http://bjson.org). When the agent share the same process,\n    there is no streaming at all.  [^2]: Within the same process, there is not serialization, the\n    propagation has the cost of wrapping a json data and calling\n    callbacks with the benefit of having a powerful callback manager:\n    the event mechanism of the framework.", 
            "title": "Soft composition"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-overview/", 
            "text": "Overview of AFB-DAEMON\n\n\nRoles of afb-daemon\n\n\nThe name \nafb-daemon\n stands for \nApplication\nFramework Binder Daemon\n. That is why afb-daemon\nis also named \nthe binder\n.\n\n\nAfb-daemon\n is in charge to bind one instance of\nan application to the AGL framework and AGL system.\n\n\nOn the following figure, you can use a typical use\nof afb-daemon:\n\n\nFigure: binder afb-daemon, basis\n\n\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n.        Isolated security context                .\n.                                                 .\n.        +------------------------------+         .\n.        |                              |         .\n.        |    A P P L I C A T I O N     |         .\n.        |                              |         .\n.        +--------------+---------------+         .\n.                       |                         .\n.                       |                         .\n.   +-------------------+----------------------+  .\n.   |                            :             |  .\n.   |        b i n d e r         :             |  .\n.   |    A F B - D A E M O N     :  BINDINGS   |  .\n.   |                            :             |  .\n.   +-------------------+----------------------+  .\n.                       |                         .\n. . . . . . . . . . . . | . . . . . . . . . . . . .\n                        |\n                        v\n                   AGL SYSTEM\n\n\n\nThe application and its companion binder run in secured and isolated\nenvironment set for them. Applications are intended to access to AGL\nsystem through the binder.\n\n\nThe binder afb-daemon serves multiple purposes:\n\n\n\n\n\n\nIt acts as a gateway for the application to access the system;\n\n\n\n\n\n\nIt acts as an HTTP server for serving files to HTML5 applications;\n\n\n\n\n\n\nIt allows HTML5 applications to have native extensions subject\nto security enforcement for accessing hardware ressources or\nfor speeding parts of algorithm.\n\n\n\n\n\n\nUse cases of the binder afb-daemon\n\n\nThis section tries to give a better understanding of the binder\nusage through several use cases.\n\n\nRemotely running application\n\n\nOne of the most interresting aspect of using the binder afb-daemon\nis the ability to run applications remotely. This feature is\npossible because the binder afb-daemon implements native web\nprotocols.\n\n\nSo the \nfigure binder, basis\n would become\nwhen the application is run remotely:\n\n\nFigure: binder afb-daemon and remotely running application\n\n\n             +------------------------------+\n             |                              |\n             |    A P P L I C A T I O N     |\n             |                              |\n             +--------------+---------------+\n                            |\n                       ~ ~ ~ ~ ~ ~\n                      :  NETWORK  :\n                       ~ ~ ~ ~ ~ ~\n                            |\n. . . . . . . . . . . . . . | . . . . . . . . . . . . . .\n. Isolated security         |                           .\n.   context                 |                           .\n.                           |                           .\n.     . . . . . . . . . . . . . . . . . . . . . . . .   .\n.     .                                             .   .\n.     .               F I R E W A L L               .   .\n.     .                                             .   .\n.     . . . . . . . . . . . . . . . . . . . . . . . .   .\n.                           |                           .\n.       +-------------------+----------------------+    .\n.       |                            :             |    .\n.       |    A F B - D A E M O N     :   BINDINGS  |    .\n.       |                            :             |    .\n.       +-------------------+----------------------+    .\n.                           |                           .\n. . . . . . . . . . . . . . | . . . . . . . . . . . . . .\n                            |\n                            v\n                       AGL SYSTEM\n\n\n\nAdding native features to HTML5/QML applications\n\n\nApplications can provide with their packaged delivery a binding.\nThat binding will be instanciated for each application instance.\nThe methods of the binding will be accessible by applications and\nwill be excuted within the security context.\n\n\nOffering services to the system\n\n\nIt is possible to run the binder afb-daemon as a daemon that provides the\nAPI of its bindings.\n\n\nThis will be used for:\n\n\n\n\n\n\noffering common APIs\n\n\n\n\n\n\nprovide application's services (services provided as application)\n\n\n\n\n\n\nIn that case, the figure showing the whole aspects is\n\n\nFigure: binder afb-daemon for services\n\n\n. . . . . . . . . . . . . . . . . . . . . . \n.  Isolated security context application  . \n.                                         . \n.    +------------------------------+     . \n.    |                              |     . \n.    |    A P P L I C A T I O N     |     . \n.    |                              |     . \n.    +--------------+---------------+     .     . . . . . . . . . . . . . . . . . . . . . .\n.                   |                     .     .        Isolated security context A      .\n.                   |                     .     .                                         .\n. +-----------------+------------------+  .     . +------------------------------------+  .\n. |                        :           |  .     . |                        :           |  .\n. |      b i n d e r       :           |  .     . |      b i n d e r       :  service  |  .\n. |  A F B - D A E M O N   : BINDINGS  |  .     . |  A F B - D A E M O N   : BINDINGS  |  .\n. |                        :           |  .     . |                        :     A     |  .\n. +-----------------+------------------+  .     . +-----------------+------------------+  .\n.                   |                     .     .                   |                     .\n. . . . . . . . . . | . . . . . . . . . . .     . . . . . . . . . . | . . . . . . . . . . .\n                    |                                               |\n                    v                                               v\n         ================================================================================\n                                     D - B U S   \n   C Y N A R A\n         ================================================================================\n                    ^                                               ^\n                    |                                               |\n. . . . . . . . . . | . . . . . . . . . . .     . . . . . . . . . . | . . . . . . . . . . .\n.                   |                     .     .                   |                     .\n. +-----------------+------------------+  .     . +-----------------+------------------+  .\n. |                        :           |  .     . |                        :           |  .\n. |      b i n d e r       :  service  |  .     . |      b i n d e r       :  service  |  .\n. |  A F B - D A E M O N   : BINDINGS  |  .     . |  A F B - D A E M O N   : BINDINGS  |  .\n. |                        :     B     |  .     . |                        :     C     |  .\n. +------------------------------------+  .     . +------------------------------------+  .\n.                                         .     .                                         .\n.        Isolated security context B      .     .        Isolated security context C      .\n. . . . . . . . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . . . . .\n\n\n\nFor this case, the binder afb-daemon takes care to attribute one single session\ncontext to each client instance. It allows bindings to store and retrieve data\nassociated to each of its client.\n\n\nThe bindings of the binder afb-daemon\n\n\nThe binder can instanciate bindings. The primary use of bindings\nis to add native methods that can be accessed by applications\nwritten with any language through web technologies ala JSON RPC.\n\n\nThis simple idea is declined to serves multiple purposes:\n\n\n\n\n\n\nadd native feature to applications\n\n\n\n\n\n\nadd common API available by any applications\n\n\n\n\n\n\nprovide customers services\n\n\n\n\n\n\nA specific document explains how to write an afb-daemon binder binding:\n\nHOWTO WRITE a BINDING for AFB-DAEMON\n\n\nLaunching the binder afb-daemon\n\n\nThe launch options for binder \nafb-daemon\n are:\n\n\n  --help\n\n    Prints help with available options\n\n  --version\n\n    Display version and copyright\n\n  --verbose\n\n    Increases the verbosity, can be repeated\n\n  --port=xxxx\n\n    HTTP listening TCP port  [default 1234]\n\n  --rootdir=xxxx\n\n    HTTP Root Directory [default $AFBDIR or else $HOME/.AFB]\n\n  --rootbase=xxxx\n\n    Angular Base Root URL [default /opa]\n\n    This is used for any application of kind OPA (one page application).\n    When set, any missing document whose url has the form /opa/zzz\n    is translated to /opa/#!zzz\n\n  --rootapi=xxxx\n\n    HTML Root API URL [default /api]\n\n    The bindings are available within that url.\n\n  --alias=xxxx\n\n    Maps a path located anywhere in the file system to the\n    a subdirectory. The syntax for mapping a PATH to the\n    subdirectory NAME is: --alias=/NAME:PATH.\n\n    Example: --alias=/icons:/usr/share/icons maps the\n    content of /usr/share/icons within the subpath /icons.\n\n    This option can be repeated.\n\n  --apitimeout=xxxx\n\n    binding API timeout in seconds [default 20]\n\n    Defines how many seconds maximum a method is allowed to run.\n    0 means no limit.\n\n  --cntxtimeout=xxxx\n\n    Client Session Timeout in seconds [default 3600]\n\n  --cache-eol=xxxx\n\n    Client cache end of live [default 100000 that is 27,7 hours]\n\n  --sessiondir=xxxx\n\n    Sessions file path [default rootdir/sessions]\n\n  --session-max=xxxx\n\n    Maximum count of simultaneous sessions [default 10]\n\n  --ldpaths=xxxx\n\n    Load bindings from given paths separated by colons\n    as for dir1:dir2:binding1.so:... [default = $libdir/afb]\n\n    You can mix path to directories and to bindings.\n    The sub-directories of the given directories are searched\n    recursively.\n\n    The bindings are the files terminated by '.so' (the extension\n    so denotes shared object) that contain the public entry symbol.\n\n  --binding=xxxx\n\n    Load the binding of given path.\n\n  --token=xxxx\n\n    Initial Secret token to authenticate.\n\n    If not set, no client can authenticate.\n\n    If set to the empty string, then any initial token is accepted.\n\n  --mode=xxxx\n\n    Set the mode: either local, remote or global.\n\n    The mode indicate if the application is run locally on the host\n    or remotely through network.\n\n  --readyfd=xxxx\n\n    Set the #fd to signal when ready\n\n    If set, the binder afb-daemon will write \"READY=1\\n\" on the file\n    descriptor whose number if given (/proc/self/fd/xxx).\n\n  --dbus-client=xxxx\n\n    Transparent binding to a binder afb-daemon service through dbus.\n\n    It creates an API of name xxxx that is implemented remotely\n    and queried via DBUS.\n\n  --dbus-server=xxxx\n\n    Provides a binder afb-daemon service through dbus.\n\n    The name xxxx must be the name of an API defined by a binding.\n    This API is exported through DBUS.\n\n  --foreground\n\n    Get all in foreground mode (default)\n\n  --daemon\n\n    Get all in background mode\n\n\n\nFuture development of afb-daemon\n\n\n\n\n\n\nThe binder afb-daemon would launch the applications directly.\n\n\n\n\n\n\nThe current setting of mode (local/remote/global) might be reworked to a\nmechanism for querying configuration variables.\n\n\n\n\n\n\nImplements \"one-shot\" initial token. It means that after its first\nauthenticated use, the initial token is removed and no client can connect\nanymore.\n\n\n\n\n\n\nCreates some intrinsic APIs.\n\n\n\n\n\n\nMake the service connection using WebSocket not DBUS.\n\n\n\n\n\n\nManagement of targetted events.\n\n\n\n\n\n\nSecurisation of LOA.\n\n\n\n\n\n\nIntegration of the protocol JSON-RPC for the websockets.", 
            "title": "Afb overview"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-overview/#overview-of-afb-daemon", 
            "text": "", 
            "title": "Overview of AFB-DAEMON"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-overview/#roles-of-afb-daemon", 
            "text": "The name  afb-daemon  stands for  Application\nFramework Binder Daemon . That is why afb-daemon\nis also named  the binder .  Afb-daemon  is in charge to bind one instance of\nan application to the AGL framework and AGL system.  On the following figure, you can use a typical use\nof afb-daemon:", 
            "title": "Roles of afb-daemon"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-overview/#use-cases-of-the-binder-afb-daemon", 
            "text": "This section tries to give a better understanding of the binder\nusage through several use cases.", 
            "title": "Use cases of the binder afb-daemon"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-overview/#remotely-running-application", 
            "text": "One of the most interresting aspect of using the binder afb-daemon\nis the ability to run applications remotely. This feature is\npossible because the binder afb-daemon implements native web\nprotocols.  So the  figure binder, basis  would become\nwhen the application is run remotely:", 
            "title": "Remotely running application"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-overview/#adding-native-features-to-html5qml-applications", 
            "text": "Applications can provide with their packaged delivery a binding.\nThat binding will be instanciated for each application instance.\nThe methods of the binding will be accessible by applications and\nwill be excuted within the security context.", 
            "title": "Adding native features to HTML5/QML applications"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-overview/#offering-services-to-the-system", 
            "text": "It is possible to run the binder afb-daemon as a daemon that provides the\nAPI of its bindings.  This will be used for:    offering common APIs    provide application's services (services provided as application)    In that case, the figure showing the whole aspects is", 
            "title": "Offering services to the system"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-overview/#the-bindings-of-the-binder-afb-daemon", 
            "text": "The binder can instanciate bindings. The primary use of bindings\nis to add native methods that can be accessed by applications\nwritten with any language through web technologies ala JSON RPC.  This simple idea is declined to serves multiple purposes:    add native feature to applications    add common API available by any applications    provide customers services    A specific document explains how to write an afb-daemon binder binding: HOWTO WRITE a BINDING for AFB-DAEMON", 
            "title": "The bindings of the binder afb-daemon"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-overview/#launching-the-binder-afb-daemon", 
            "text": "The launch options for binder  afb-daemon  are:    --help\n\n    Prints help with available options\n\n  --version\n\n    Display version and copyright\n\n  --verbose\n\n    Increases the verbosity, can be repeated\n\n  --port=xxxx\n\n    HTTP listening TCP port  [default 1234]\n\n  --rootdir=xxxx\n\n    HTTP Root Directory [default $AFBDIR or else $HOME/.AFB]\n\n  --rootbase=xxxx\n\n    Angular Base Root URL [default /opa]\n\n    This is used for any application of kind OPA (one page application).\n    When set, any missing document whose url has the form /opa/zzz\n    is translated to /opa/#!zzz\n\n  --rootapi=xxxx\n\n    HTML Root API URL [default /api]\n\n    The bindings are available within that url.\n\n  --alias=xxxx\n\n    Maps a path located anywhere in the file system to the\n    a subdirectory. The syntax for mapping a PATH to the\n    subdirectory NAME is: --alias=/NAME:PATH.\n\n    Example: --alias=/icons:/usr/share/icons maps the\n    content of /usr/share/icons within the subpath /icons.\n\n    This option can be repeated.\n\n  --apitimeout=xxxx\n\n    binding API timeout in seconds [default 20]\n\n    Defines how many seconds maximum a method is allowed to run.\n    0 means no limit.\n\n  --cntxtimeout=xxxx\n\n    Client Session Timeout in seconds [default 3600]\n\n  --cache-eol=xxxx\n\n    Client cache end of live [default 100000 that is 27,7 hours]\n\n  --sessiondir=xxxx\n\n    Sessions file path [default rootdir/sessions]\n\n  --session-max=xxxx\n\n    Maximum count of simultaneous sessions [default 10]\n\n  --ldpaths=xxxx\n\n    Load bindings from given paths separated by colons\n    as for dir1:dir2:binding1.so:... [default = $libdir/afb]\n\n    You can mix path to directories and to bindings.\n    The sub-directories of the given directories are searched\n    recursively.\n\n    The bindings are the files terminated by '.so' (the extension\n    so denotes shared object) that contain the public entry symbol.\n\n  --binding=xxxx\n\n    Load the binding of given path.\n\n  --token=xxxx\n\n    Initial Secret token to authenticate.\n\n    If not set, no client can authenticate.\n\n    If set to the empty string, then any initial token is accepted.\n\n  --mode=xxxx\n\n    Set the mode: either local, remote or global.\n\n    The mode indicate if the application is run locally on the host\n    or remotely through network.\n\n  --readyfd=xxxx\n\n    Set the #fd to signal when ready\n\n    If set, the binder afb-daemon will write \"READY=1\\n\" on the file\n    descriptor whose number if given (/proc/self/fd/xxx).\n\n  --dbus-client=xxxx\n\n    Transparent binding to a binder afb-daemon service through dbus.\n\n    It creates an API of name xxxx that is implemented remotely\n    and queried via DBUS.\n\n  --dbus-server=xxxx\n\n    Provides a binder afb-daemon service through dbus.\n\n    The name xxxx must be the name of an API defined by a binding.\n    This API is exported through DBUS.\n\n  --foreground\n\n    Get all in foreground mode (default)\n\n  --daemon\n\n    Get all in background mode", 
            "title": "Launching the binder afb-daemon"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-overview/#future-development-of-afb-daemon", 
            "text": "The binder afb-daemon would launch the applications directly.    The current setting of mode (local/remote/global) might be reworked to a\nmechanism for querying configuration variables.    Implements \"one-shot\" initial token. It means that after its first\nauthenticated use, the initial token is removed and no client can connect\nanymore.    Creates some intrinsic APIs.    Make the service connection using WebSocket not DBUS.    Management of targetted events.    Securisation of LOA.    Integration of the protocol JSON-RPC for the websockets.", 
            "title": "Future development of afb-daemon"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-tests-overview/", 
            "text": "Overview of tests shipped with AFB-Daemon\n\n\nList of tests\n\n\nHere are the tests shipped in the source tree:\n\n\n\n\n\n\nafb-client-demo\n (command-line WebSockets)\n\n\n\n\n\n\ntoken-websock.qml\n (Qt/QML WebSockets)\n\n\n\n\n\n\n*.html\n (HTML5/JS HTTP-REST \n WebSockets)\n\n\n\n\n\n\nDetail of tests\n\n\nafb-client-demo (command-line WebSockets)\n\n\nThis clients interactively calls bindings APIs from the command line, using the binder\n\nWebSockets\n facility.\n\n\nIf \nafb-daemon\n has been launched with the following parameters:\n\n\n$ afb-daemon --port=1234 --token=123456 [...]\n\n\n\nThen run the client with :\n\n\nafb-client-demo ws://localhost:1234/api?token=123456 [\napi\n \nverb\n [\njson-data\n]]\n\n\n\nFor instance, to initialize the Audio binding from the command line :\n\n\nafb-client-demo ws://localhost:1234/api?token=123456\n\n\n\nThe command doesn't return. You should type requests of type \n \n [\n].\nSo, try:\n\n\nauth connect\nhello pingjson true\n\n\n\n\n\ntoken-websock.qml (Qt/QML WebSockets)\n\n\nIf \nafb-daemon\n has been launched with the following parameters:\n\n\n$ afb-daemon --port=1234 --token=123456 [...]\n\n\n\nand Qt5 is installed.\n\n\nFor installing Qt5 on \nUbuntu 16.04\n:\n\n\n$ apt-get install qmlscene qml-module-qtwebsockets qml-module-qtquick-controls\n\n\n\nFor installing Qt5 on \nFedora 23\n :\n\n\n$ dnf install qt5-qtdeclarative-devel qt5-qtwebsockets-devel qt5-qtquickcontrols\n\n\n\nThen run the client with :\n\n\nqmlscene test/token-websock.qml\n\n\n\nand interactively press the buttons, \"Connect\", \"Refresh\", \"Logout\".\n\n\n\n\n*.html (HTML5/JS HTTP-REST \n WebSockets)\n\n\nIf \nafb-daemon\n has been launched with the following parameters:\n\n\n$ afb-daemon --port=1234 --rootdir=$PWD/test [...]\n\n\n\n(\"$PWD/test\n\" being the \"test\" subdirectory of the source tree)_\n\n\nThen open your preferred Web browser, connect to the following URL:\n\n\nhttp://localhost:1234\n\n\n\nand interactively run the various tests.", 
            "title": "Afb tests overview"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-tests-overview/#overview-of-tests-shipped-with-afb-daemon", 
            "text": "", 
            "title": "Overview of tests shipped with AFB-Daemon"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-tests-overview/#list-of-tests", 
            "text": "Here are the tests shipped in the source tree:    afb-client-demo  (command-line WebSockets)    token-websock.qml  (Qt/QML WebSockets)    *.html  (HTML5/JS HTTP-REST   WebSockets)", 
            "title": "List of tests"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-tests-overview/#detail-of-tests", 
            "text": "", 
            "title": "Detail of tests"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-tests-overview/#afb-client-demo-command-line-websockets", 
            "text": "This clients interactively calls bindings APIs from the command line, using the binder WebSockets  facility.  If  afb-daemon  has been launched with the following parameters:  $ afb-daemon --port=1234 --token=123456 [...]  Then run the client with :  afb-client-demo ws://localhost:1234/api?token=123456 [ api   verb  [ json-data ]]  For instance, to initialize the Audio binding from the command line :  afb-client-demo ws://localhost:1234/api?token=123456  The command doesn't return. You should type requests of type     [ ].\nSo, try:  auth connect\nhello pingjson true", 
            "title": "afb-client-demo (command-line WebSockets)"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-tests-overview/#token-websockqml-qtqml-websockets", 
            "text": "If  afb-daemon  has been launched with the following parameters:  $ afb-daemon --port=1234 --token=123456 [...]  and Qt5 is installed.  For installing Qt5 on  Ubuntu 16.04 :  $ apt-get install qmlscene qml-module-qtwebsockets qml-module-qtquick-controls  For installing Qt5 on  Fedora 23  :  $ dnf install qt5-qtdeclarative-devel qt5-qtwebsockets-devel qt5-qtquickcontrols  Then run the client with :  qmlscene test/token-websock.qml  and interactively press the buttons, \"Connect\", \"Refresh\", \"Logout\".", 
            "title": "token-websock.qml (Qt/QML WebSockets)"
        }, 
        {
            "location": "/developer/app-framework/binder/afb-tests-overview/#html-html5js-http-rest-websockets", 
            "text": "If  afb-daemon  has been launched with the following parameters:  $ afb-daemon --port=1234 --rootdir=$PWD/test [...]  (\"$PWD/test \" being the \"test\" subdirectory of the source tree)_  Then open your preferred Web browser, connect to the following URL:  http://localhost:1234  and interactively run the various tests.", 
            "title": "*.html (HTML5/JS HTTP-REST &amp; WebSockets)"
        }, 
        {
            "location": "/developer/app-framework/main/afm-system-daemon/", 
            "text": "The afm-system-daemon\n\n\nForeword\n\n\nThis document describes application framework system daemon fundamentals. \nFCF (Fully Conform to Specification) implementation is still under development.\nIt may happen that current implementation somehow diverges with specifications.\n\n\nIntroduction\n\n\nThe daemon \nafm-system-daemon\n is in charge of installing\napplications on AGL system. Its main tasks are:\n\n\n\n\n\n\ninstalls applications and setup security framework\n   for newly installed application.\n\n\n\n\n\n\nuninstall applications\n\n\n\n\n\n\nThe \nafm-system-daemon\n takes its orders from system\ninstance of D-Bus.\n\n\nThe figure below summarizes the situation of \nafm-system-daemon\n in the system.\n\n\n+------------------------------------------------------------+\n|                          User                              |\n|                                                            |\n|     +-------------------------------------------------+    |\n|     |                                                 |    |\n|     |                  afm-user-daemon                |    |\n|     |                                                 |    |\n|     +----------+----------------------+----------+----+    |\n|                |                      |          :         |\n|                |                      |          :         |\n:================|======================|==========:=========:\n|                |                      |          :         |\n|     +----------+----------+     +-----+-----+    :         |\n|     |   D-Bus   system    +-----+  CYNARA   |    :         |\n|     +----------+----------+     +-----+-----+    :         |\n|                |                      |          :         |\n|     +----------+---------+    +-------+----------+----+    |\n|     | afm-system-daemon  +----+   SECURITY-MANAGER    |    |\n|     +--------------------+    +-----------------------+    |\n|                                                            |\n|                          System                            |\n+------------------------------------------------------------+\n\n\n\nStarting \nafm-system-daemon\n\n\nafm-system-daemon\n is launched as a \nsystemd\n service\nattached to system. Normally, the service file is\nlocated at /lib/systemd/system/afm-system-daemon.service.\n\n\nThe options for launching \nafm-system-daemon\n are:\n\n\n-r\n--root directory\n\n     Set the root application directory.\n\n     Note that the default root directory is defined\n     to be /usr/share/afm/applications (may change).\n\n-d\n--daemon\n\n     Daemonizes the process. It is not needed by sytemd.\n\n-q\n--quiet\n\n     Reduces the verbosity (can be repeated).\n\n-v\n--verbose\n\n     Increases the verbosity (can be repeated).\n\n-h\n--help\n\n     Prints a short help.\n\n\n\nThe D-Bus interface\n\n\nOverview of the dbus interface\n\n\nafm-system-daemon\n takes its orders from the session instance\nof D-Bus. The use of D-Bus is great because it allows to implement\ndiscovery and signaling.\n\n\nThe \nafm-system-daemon\n is listening with the destination name\n\norg.AGL.afm.system\n at the object of path \n/org/AGL/afm/system\n\non the interface \norg.AGL.afm.system\n for the below detailed\nmembers \ninstall\n and \nuninstall\n.\n\n\nD-Bus is mainly used for signaling and discovery. Its optimized\ntyped protocol is not used except for transmitting only one string\nin both directions.\n\n\nThe client and the service are using JSON serialization to\nexchange data. \n\n\nThe D-Bus interface is defined by:\n\n\n\n\n\n\nDESTINATION: \norg.AGL.afm.system\n\n\n\n\n\n\nPATH: \n/org/AGL/afm/system\n\n\n\n\n\n\nINTERFACE: \norg.AGL.afm.system\n\n\n\n\n\n\nThe signature of any member of the interface is \nstring -\n string\n\nfor \nJSON -\n JSON\n.\n\n\nThis is the normal case. In case of error, the current implementation\nreturns a dbus error that is a string.\n\n\nHere is an example using \ndbus-send\n to query data on\ninstalled applications.\n\n\ndbus-send --session --print-reply \\\n    --dest=org.AGL.afm.system \\\n    /org/AGL/afm/system \\\n    org.AGL.afm.system.install 'string:\"/tmp/appli.wgt\"'\n\n\n\nThe protocol over D-Bus\n\n\n\n\nMethod org.AGL.afm.system.install\n\n\nDescription\n: Install an application from a widget file.\n\n\nWhen an application with the same \nid\n and \nversion\n already exists. Outside of\nusing \nforce=true\n the application is not reinstalled.\n\n\nApplications are installed the subdirectories of applications common directory.\nIf \nroot\n is specified, the application is installed under the\nsub-directories of the \nroot\n defined.\n\n\nNote that this methods is a simple accessor method of\n\norg.AGL.afm.system.install\n from \nafm-system-daemon\n.\n\n\nAfter the installation and before returning to the sender,\n\nafm-system-daemon\n sends a signal \norg.AGL.afm.system.changed\n.\n\n\nInput\n: The \npath\n of the widget file to install and, optionally,\na flag to \nforce\n reinstallation, and, optionally, a \nroot\n directory.\n\n\nEither just a string being the absolute path of the widget file:\n\n\n\"/a/path/driving/to/the/widget\"\n\n\n\nOr an object:\n\n\n{\n  \"wgt\": \"/a/path/to/the/widget\",\n  \"force\": false,\n  \"root\": \"/a/path/to/the/root\"\n}\n\n\n\n\"wgt\" and \"root\" must be absolute paths.\n\n\noutput\n: An object with the field \"added\" being the string for\nthe id of the added application.\n\n\n{\"added\":\"appli@x.y\"}\n\n\n\n\n\nMethod org.AGL.afm.system.uninstall\n\n\nDescription\n: Uninstall an application from its id.\n\n\nNote that this methods is a simple method accessor of \n\norg.AGL.afm.system.uninstall\n from \nafm-system-daemon\n.\n\n\nAfter the uninstallation and before returning to the sender,\n\nafm-system-daemon\n sends a signal \norg.AGL.afm.system.changed\n.\n\n\nInput\n: the \nid\n of the application and optionally the application \nroot\n path.\n\n\nEither a string:\n\n\n\"appli@x.y\"\n\n\n\nOr an object:\n\n\n{\n  \"id\": \"appli@x.y\",\n  \"root\": \"/a/path/to/the/root\"\n}\n\n\n\noutput\n: the value 'true'.", 
            "title": "Afm system daemon"
        }, 
        {
            "location": "/developer/app-framework/main/afm-system-daemon/#the-afm-system-daemon", 
            "text": "", 
            "title": "The afm-system-daemon"
        }, 
        {
            "location": "/developer/app-framework/main/afm-system-daemon/#foreword", 
            "text": "This document describes application framework system daemon fundamentals. \nFCF (Fully Conform to Specification) implementation is still under development.\nIt may happen that current implementation somehow diverges with specifications.", 
            "title": "Foreword"
        }, 
        {
            "location": "/developer/app-framework/main/afm-system-daemon/#introduction", 
            "text": "The daemon  afm-system-daemon  is in charge of installing\napplications on AGL system. Its main tasks are:    installs applications and setup security framework\n   for newly installed application.    uninstall applications    The  afm-system-daemon  takes its orders from system\ninstance of D-Bus.  The figure below summarizes the situation of  afm-system-daemon  in the system.  +------------------------------------------------------------+\n|                          User                              |\n|                                                            |\n|     +-------------------------------------------------+    |\n|     |                                                 |    |\n|     |                  afm-user-daemon                |    |\n|     |                                                 |    |\n|     +----------+----------------------+----------+----+    |\n|                |                      |          :         |\n|                |                      |          :         |\n:================|======================|==========:=========:\n|                |                      |          :         |\n|     +----------+----------+     +-----+-----+    :         |\n|     |   D-Bus   system    +-----+  CYNARA   |    :         |\n|     +----------+----------+     +-----+-----+    :         |\n|                |                      |          :         |\n|     +----------+---------+    +-------+----------+----+    |\n|     | afm-system-daemon  +----+   SECURITY-MANAGER    |    |\n|     +--------------------+    +-----------------------+    |\n|                                                            |\n|                          System                            |\n+------------------------------------------------------------+", 
            "title": "Introduction"
        }, 
        {
            "location": "/developer/app-framework/main/afm-system-daemon/#starting-afm-system-daemon", 
            "text": "afm-system-daemon  is launched as a  systemd  service\nattached to system. Normally, the service file is\nlocated at /lib/systemd/system/afm-system-daemon.service.  The options for launching  afm-system-daemon  are:  -r\n--root directory\n\n     Set the root application directory.\n\n     Note that the default root directory is defined\n     to be /usr/share/afm/applications (may change).\n\n-d\n--daemon\n\n     Daemonizes the process. It is not needed by sytemd.\n\n-q\n--quiet\n\n     Reduces the verbosity (can be repeated).\n\n-v\n--verbose\n\n     Increases the verbosity (can be repeated).\n\n-h\n--help\n\n     Prints a short help.", 
            "title": "Starting afm-system-daemon"
        }, 
        {
            "location": "/developer/app-framework/main/afm-system-daemon/#the-d-bus-interface", 
            "text": "", 
            "title": "The D-Bus interface"
        }, 
        {
            "location": "/developer/app-framework/main/afm-system-daemon/#overview-of-the-dbus-interface", 
            "text": "afm-system-daemon  takes its orders from the session instance\nof D-Bus. The use of D-Bus is great because it allows to implement\ndiscovery and signaling.  The  afm-system-daemon  is listening with the destination name org.AGL.afm.system  at the object of path  /org/AGL/afm/system \non the interface  org.AGL.afm.system  for the below detailed\nmembers  install  and  uninstall .  D-Bus is mainly used for signaling and discovery. Its optimized\ntyped protocol is not used except for transmitting only one string\nin both directions.  The client and the service are using JSON serialization to\nexchange data.   The D-Bus interface is defined by:    DESTINATION:  org.AGL.afm.system    PATH:  /org/AGL/afm/system    INTERFACE:  org.AGL.afm.system    The signature of any member of the interface is  string -  string \nfor  JSON -  JSON .  This is the normal case. In case of error, the current implementation\nreturns a dbus error that is a string.  Here is an example using  dbus-send  to query data on\ninstalled applications.  dbus-send --session --print-reply \\\n    --dest=org.AGL.afm.system \\\n    /org/AGL/afm/system \\\n    org.AGL.afm.system.install 'string:\"/tmp/appli.wgt\"'", 
            "title": "Overview of the dbus interface"
        }, 
        {
            "location": "/developer/app-framework/main/afm-system-daemon/#the-protocol-over-d-bus", 
            "text": "", 
            "title": "The protocol over D-Bus"
        }, 
        {
            "location": "/developer/app-framework/main/afm-system-daemon/#method-orgaglafmsysteminstall", 
            "text": "Description : Install an application from a widget file.  When an application with the same  id  and  version  already exists. Outside of\nusing  force=true  the application is not reinstalled.  Applications are installed the subdirectories of applications common directory.\nIf  root  is specified, the application is installed under the\nsub-directories of the  root  defined.  Note that this methods is a simple accessor method of org.AGL.afm.system.install  from  afm-system-daemon .  After the installation and before returning to the sender, afm-system-daemon  sends a signal  org.AGL.afm.system.changed .  Input : The  path  of the widget file to install and, optionally,\na flag to  force  reinstallation, and, optionally, a  root  directory.  Either just a string being the absolute path of the widget file:  \"/a/path/driving/to/the/widget\"  Or an object:  {\n  \"wgt\": \"/a/path/to/the/widget\",\n  \"force\": false,\n  \"root\": \"/a/path/to/the/root\"\n}  \"wgt\" and \"root\" must be absolute paths.  output : An object with the field \"added\" being the string for\nthe id of the added application.  {\"added\":\"appli@x.y\"}", 
            "title": "Method org.AGL.afm.system.install"
        }, 
        {
            "location": "/developer/app-framework/main/afm-system-daemon/#method-orgaglafmsystemuninstall", 
            "text": "Description : Uninstall an application from its id.  Note that this methods is a simple method accessor of  org.AGL.afm.system.uninstall  from  afm-system-daemon .  After the uninstallation and before returning to the sender, afm-system-daemon  sends a signal  org.AGL.afm.system.changed .  Input : the  id  of the application and optionally the application  root  path.  Either a string:  \"appli@x.y\"  Or an object:  {\n  \"id\": \"appli@x.y\",\n  \"root\": \"/a/path/to/the/root\"\n}  output : the value 'true'.", 
            "title": "Method org.AGL.afm.system.uninstall"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/", 
            "text": "The afm-user-daemon\n\n\nForeword\n\n\nThis document describes application framework user daemon fundamentals. \nFCF (Fully Conform to Specification) implementation is still under development.\nIt may happen that current implementation somehow diverges with specifications.\n\n\nIntroduction\n\n\nThe daemon \nafm-user-daemon\n is in charge of handling\napplications on behalf of a user. Its main tasks are:\n\n\n\n\n\n\nenumerate applications that end user can run\n   and keep this list available on demand\n\n\n\n\n\n\nstart applications on behalf of end user, set user running\n   environment, set user security context\n\n\n\n\n\n\nlist current runnable or running applications\n\n\n\n\n\n\nstop (aka pause), continue (aka resume), terminate\n   a running instance of a given application\n\n\n\n\n\n\ntransfer requests for installation/uninstallation\n   of applications to the corresponding system daemon\n   \nafm-system-daemon\n\n\n\n\n\n\nThe \nafm-user-daemon\n takes its orders from the session\ninstance of D-Bus.\n\n\nThe figure below summarizes the situation of \nafm-user-daemon\n in the system.\n\n\n+------------------------------------------------------------+\n|                          User                              |\n|                                 +---------------------+    |\n|     +---------------------+     |   Smack isolated    |    |\n|     |   D-Bus   session   +     |    APPLICATIONS     |    |\n|     +----------+----------+     +---------+-----------+    |\n|                |                          |                |\n|                |                          |                |\n|     +----------+--------------------------+-----------+    |\n|     |                                                 |    |\n|     |                  afm-user-daemon                |    |\n|     |                                                 |    |\n|     +----------+----------------------+----------+----+    |\n|                |                      |          :         |\n|                |                      |          :         |\n:================|======================|==========:=========:\n|                |                      |          :         |\n|     +----------+----------+     +-----+-----+    :         |\n|     |   D-Bus   system    +-----+  CYNARA   |    :         |\n|     +----------+----------+     +-----+-----+    :         |\n|                |                      |          :         |\n|     +----------+---------+    +-------+----------+----+    |\n|     | afm-system-daemon  +----+   SECURITY-MANAGER    |    |\n|     +--------------------+    +-----------------------+    |\n|                                                            |\n|                          System                            |\n+------------------------------------------------------------+\n\n\n\nTasks of \nafm-user-daemon\n\n\nMaintaining list of applications\n\n\nAt start \nafm-user-daemon\n scans the directories containing\napplications and load in memory a list of avaliable applications\naccessible by current user.\n\n\nWhen \nafm-system-daemon\n installs or removes an application.\nOn success it sends the signal \norg.AGL.afm.system.changed\n.\nWhen receiving such a signal, \nafm-user-daemon\n rebuilds its\napplications list.\n\n\nafm-user-daemon\n provides the data it collects about\napplications to its clients. Clients may either request the full list\nof avaliable applications or a more specific information about a\ngiven application.\n\n\nLaunching application\n\n\nafm-user-daemon\n launches application. Its builds a secure\nenvironment for the application before starting it within a\nsecured environment.\n\n\nDifferent kind of applications can be launched.\n\n\nThis is set using a configuration file that describes\nhow to launch an application of a given kind within a given\nmode.\n\n\nThere is two launching modes: local or remote.\n\n\nLaunching an application locally means that\nthe application and its binder are launched together.\n\n\nLaunching application remotely translates in only launching \nthe application binder. The UI by itself has to be activated\nremotely by the requested (ie: HTML5 homescreen in a browser)\n\n\nOnce launched, running instances of application receive\na runid that identify them.\n\n\nManaging instances of running applications\n\n\nafm-user-daemon\n manages the list of applications\nthat it launched.\n\n\nWhen owning the right permissions, a client can get the list\nof running instances and details about a specific\nrunning instance. It can also terminates, stops or\ncontinues a given application.\n\n\nInstalling and uninstalling applications\n\n\nIf the client own the right permissions,\n\nafm-user-daemon\n delegates that task\nto \nafm-system-daemon\n.\n\n\nStarting \nafm-user-daemon\n\n\nafm-user-daemon\n is launched as a \nsystemd\n service\nattached to user sessions. Normally, the service file is\nlocated at /usr/lib/systemd/user/afm-user-daemon.service.\n\n\nThe options for launching \nafm-user-daemon\n are:\n\n\n-a\n--application directory\n\n     Includes the given application directory to\n     the database base of applications.\n\n     Can be repeated.\n\n-r\n--root directory\n\n     Includes root application directory or directories when\n     passing multiple rootdir to\n     applications database.\n\n     Note that default root directory for\n     applications is always added. In current version\n     /usr/share/afm/applications is used as default.\n\n-m\n--mode (local|remote)\n\n     Set the default launch mode.\n     The default value is 'local'\n\n-d\n--daemon\n\n     Daemonizes the process. It is not needed by sytemd.\n\n-q\n--quiet\n\n     Reduces the verbosity (can be repeated).\n\n-v\n--verbose\n\n     Increases the verbosity (can be repeated).\n\n-h\n--help\n\n     Prints a short help.\n\n\n\nLauncher Configuration\n\n\nIt contains rules for launching applications.\nWhen \nafm-user-daemon\n has to launch an application,\nit looks for launch mode (local or remote), as well as\nfor the type of application describe in \nconfig.xml\n\nwidget configuration file.\n\n\nThis tuple mode+type allows to select the adequate rule.\n\n\nConfiguration file is \n/etc/afm/afm-launch.conf\n.\n\n\nIt contains sections and rules. It can also contain comments\nand empty lines to improve readability.\n\n\nThe separators are space and tabulation, any other character\nshould have a meaning.\n\n\nThe format is line oriented.\nThe new line character separate the lines.\n\n\nLines having only separators are blank lines and ignored.\nLine having character #(sharp) at first position are comment\nlines and ignored.\n\n\nLines not starting with a separator are different\nfrom lines starting with a separator character.\n\n\nThe grammar of the configuration file is defined below:\n\n\nCONF: *COMMENT *SECTION\n\nSECTION: MODE *RULE\n\nRULE: +TYPE VECTOR ?VECTOR\n\nMODE: 'mode' +SEP ('local' | 'remote') *SEP EOL\n\nTYPE: DATA *SEP EOL\n\nVECTOR: +SEP DATA *(+SEP NDATA) *SEP EOL\n\nDATA: CHAR *NCHAR\nNDATA: +NCHAR\n\nEOL: NL *COMMENT\nCOMMENT: *SEP CMT *(SEP | NCHAR) NL\n\nNL: '\\x0a'\nSEP: '\\x20' | '\\x09'\nCMT: '#'\nCHAR: '\\x00'..'\\x08' | '\\x0b'..'\\x1f' | '\\x21' | '\\x22' | '\\x24'..'\\xff'\nNCHAR: CMT | CHAR\n\n\n\nHere is a sample of configuration file for defining how\nto launch an application of types \napplication/x-executable\n,\n\ntext/x-shellscript\n and \ntext/html\n in local mode:\n\n\nmode local\n\napplication/x-executable\ntext/x-shellscript\n    %r/%c\n\ntext/html\n    /usr/bin/afb-daemon --mode=local --readyfd=%R --alias=/icons:%I --port=%P --rootdir=%r --token=%S --sessiondir=%D/.afb-daemon\n    /usr/bin/web-runtime http://localhost:%P/%c?token=%S\n\n\n\nThis shows that:\n\n\n\n\nwithin a section, several rules can be defined\n\n\nwithin a rule, several types can be defined\n\n\nwithin a rule, one or two vectors can be defined\n\n\nvectors are using %substitution\n\n\nlaunched binaries must be defined with their full path\n\n\n\n\nmode local\n\n\nWithin this mode, the launchers have either one or two description vectors.\nAll of those vectors are treated as programs\nand are executed with 'execve' system call.\n\n\nThe first vector is the leader vector and it defines the process\ngroup. The second vector (if any) is attached to the group\ndefined by this first vector.\n\n\nmode remote\n\n\nWithin this mode, the launchers have either one or two vectors\ndescribing them.\n\n\nThe first vector is process as a program and is executed with\nsystem call 'execve'.\n\n\nThe second vector (if any) defines a text that is returned\nto the caller. This mechanism can be used to return a uri\nfor remote UI to connect on the newly launched application.\n\n\nThe daemon \nafm-user-daemon\n allocates a port for each\nnew remote application.\nThe current implementation port allocation is incremental.\nA smarter (cacheable and discoverable) allocation should be defined.\n\n\n%substitutions\n\n\nVectors can include sequences of 2 characters that have a special\nmeaning. These sequences are named \n%substitution\n because their\nfirst character is the percent sign (%) and because each occurrence\nof the sequence is replaced, at launch time, by the value associated\nto sequences.\n\n\nHere is the list of \n%substitutions\n:\n\n\n\n\n%%\n: %.\n\n\n\n\nThis simply emits the percent sign %\n\n\n\n\n%a\n: appid\n\n\n\n\nHolds application Id of launched application.\n\n\nDefined by the attribute \nid\n of the element \n\n   of \nconfig.xml\n.\n\n\n\n\n%b\n: bindings\n\n\n\n\nIn the future should represent the list of bindings and bindings directory separated by ','.\n   Warning: not supported in current version.\n\n\n\n\n%c\n: content\n\n\n\n\nThe file within the widget directory that is the entry point.\n\n\nFor HTML applications, it represents the relative path to main\n   page (aka index.html).\n\n\nDefined by attribute \nsrc\n of the element \n within \nconfig.xml\n.\n\n\n\n\n%D\n: datadir\n\n\n\n\nPath of the directory where the application runs (cwd)\n   and stores its data.\n\n\nIt is equal to %h/%a.\n\n\n\n\n%H\n: height\n\n\n\n\nRequested height for the widget.\n\n\nDefined by the attribute \nheight\n of the element \n\n   of \nconfig.xml\n.\n\n\n\n\n%h\n: homedir\n\n\n\n\nPath of the home directory for all applications.\n\n\nIt is generally equal to $HOME/app-data\n\n\n\n\n%I\n: icondir\n\n\n\n\nPath of the directory were the icons of the applications can be found.\n\n\n\n\n%m\n: mime-type\n\n\n\n\nMime type of the launched application.\n\n\nDefined by the attribute \ntype\n of the element \n\n   of \nconfig.xml\n.\n\n\n\n\n%n\n: name\n\n\n\n\nName of the application as defined by the content of the\n   element \n of \nconfig.xml\n.\n\n\n\n\n%P\n: port\n\n\n\n\nA port to use. It is currently a kind of random port. The precise\n   model is to be defined later.\n\n\n\n\n%R\n: readyfd\n\n\n\n\nNumber of file descriptor to use for signaling\n   readiness of launched process.\n\n\n\n\n%r\n: rootdir\n\n\n\n\nPath of directory containing the widget and its data.\n\n\n\n\n%S\n: secret\n\n\n\n\nAn hexadecimal number that can be used to initialize pairing of client\n   and application binder.\n\n\n\n\n%W\n: width\n\n\n\n\nRequested width for the widget.\n\n\nDefined by the attribute \nwidth\n of the element \n\n   of \nconfig.xml\n.\n\n\nThe D-Bus interface\n\n\nOverview of the dbus interface\n\n\nafm-user-daemon\n takes its orders from the session instance\nof D-Bus. D-Bus is nice to use in this context because it allows\ndiscovery and signaling.\n\n\nThe dbus session is by default addressed by environment\nvariable \nDBUS_SESSION_BUS_ADDRESS\n. Using \nsystemd\n \nvariable \nDBUS_SESSION_BUS_ADDRESS\n is automatically set for\nuser sessions.\n\n\nThe \nafm-user-daemon\n is listening on destination name\n\norg.AGL.afm.user\n at object path \n/org/AGL/afm/user\n\non interface \norg.AGL.afm.user\n for following members:\n \nrunnables\n, \ndetail\n, \nstart\n, \nterminate\n,\n\nstop\n, \ncontinue\n, \nrunners\n, \nstate\n,\n\ninstall\n and \nuninstall\n.\n\n\nD-Bus is mainly used for signaling and discovery. Its optimized\ntyped protocol is not used except for transmission of standalone strings.\n\n\nClients and Services are using JSON serialisation to exchange data. \n\n\nThe D-Bus interface is defined by:\n\n\n\n\n\n\nDESTINATION: \norg.AGL.afm.user\n\n\n\n\n\n\nPATH: \n/org/AGL/afm/user\n\n\n\n\n\n\nINTERFACE: \norg.AGL.afm.user\n\n\n\n\n\n\nThe signature of any member of the interface is \nstring -\n string\n\nfor \nJSON -\n JSON\n.\n\n\nThis is the normal case. In case of error, the current implementation\nreturns a dbus error as a string.\n\n\nHere an example using \ndbus-send\n to query data on\ninstalled applications.\n\n\ndbus-send --session --print-reply \\\n    --dest=org.AGL.afm.user \\\n    /org/AGL/afm/user \\\n    org.AGL.afm.user.runnables string:true\n\n\n\nUsing \nafm-util\n\n\nThe command line tool \nafm-util\n uses dbus-send to send\norders to \nafm-user-daemon\n. This small scripts allows to\nsend command to \nafm-user-daemon\n either interactively\nat shell prompt or scriptically.\n\n\nThe syntax is simple: it accept a command and when requires attached arguments.\n\n\nHere is the summary of \nafm-util\n:\n\n\n\n\nafm-util runnables      \n:\n\n\n\n\nlist the runnable widgets installed\n\n\n\n\nafm-util install    wgt \n:\n\n\n\n\ninstall the wgt file\n\n\n\n\nafm-util uninstall  id  \n:\n\n\n\n\nremove the installed widget of id\n\n\n\n\nafm-util detail     id  \n:\n\n\n\n\nprint detail about the installed widget of id\n\n\n\n\nafm-util runners        \n:\n\n\n\n\nlist the running instance\n\n\n\n\nafm-util start      id  \n:\n\n\n\n\nstart an instance of the widget of id\n\n\n\n\nafm-util terminate  rid \n:\n\n\n\n\nterminate the running instance rid\n\n\n\n\nafm-util stop       rid \n:\n\n\n\n\nstop the running instance rid\n\n\n\n\nafm-util continue   rid \n:\n\n\n\n\ncontinue the previously rid\n\n\n\n\nafm-util state      rid \n:\n\n\n\n\nget status of the running instance rid\n\n\nHere is how to list applications using \nafm-util\n:\n\n\nafm-util runnables\n\n\n\n\n\nThe protocol over D-Bus\n\n\nRecall:\n\n\n\n\n\n\nDESTINATION\n: org.AGL.afm.user\n\n\n\n\n\n\nPATH\n: /org/AGL/afm/user\n\n\n\n\n\n\nINTERFACE\n: org.AGL.afm.user\n\n\n\n\n\n\n\n\nMethod org.AGL.afm.user.detail\n\n\nDescription\n: Get details about an application from its id.\n\n\nInput\n: the id of the application as below.\n\n\nEither just a string:\n\n\n\"appli@x.y\"\n\n\n\nOr an object having the field \"id\" of type string:\n\n\n{\"id\":\"appli@x.y\"}\n\n\n\nOutput\n: A JSON object describing the application containing\nthe fields described below.\n\n\n{\n  \"id\":          string, the application id (id@version)\n  \"version\":     string, the version of the application\n  \"width\":       integer, requested width of the application\n  \"height\":      integer, resqueted height of the application\n  \"name\":        string, the name of the application\n  \"description\": string, the description of the application\n  \"shortname\":   string, the short name of the application\n  \"author\":      string, the author of the application\n}\n\n\n\n\n\nMethod org.AGL.afm.user.runnables\n\n\nDescription\n: Get the list of applications that can be run.\n\n\nInput\n: any valid json entry, can be anything except null.\n\n\noutput\n: An array of description of the runnable applications.\nEach item of the array contains an object containing the detail of\nan application as described above for the method\n\norg.AGL.afm.user.detail\n.\n\n\n\n\nMethod org.AGL.afm.user.install\n\n\nDescription\n: Install an application from its widget file.\n\n\nIf an application of the same \nid\n and \nversion\n exists, it is not\nreinstalled except when \nforce=true\n.\n\n\nApplications are installed in the subdirectories of the common directory\nreserved for applications.\nIf \nroot\n is specified, the application is installed under\nsub-directories of defined \nroot\n.\n\n\nNote that this methods is a simple accessor to the method\n\norg.AGL.afm.system.install\n of \nafm-system-daemon\n.\n\n\nAfter the installation and before returning to the sender,\n\nafm-user-daemon\n sends the signal \norg.AGL.afm.user.changed\n.\n\n\nInput\n: The \npath\n of widget file to be installed. Optionally,\na flag to \nforce\n reinstallation and/or a \nroot\n directory.\n\n\nSimple form a simple string containing the absolute widget path:\n\n\n\"/a/path/driving/to/the/widget\"\n\n\n\nOr an object:\n\n\n{\n  \"wgt\": \"/a/path/to/the/widget\",\n  \"force\": false,\n  \"root\": \"/a/path/to/the/root\"\n}\n\n\n\n\"wgt\" and \"root\" MUST be absolute paths.\n\n\noutput\n: An object containing field \"added\" to use as application ID.\n\n\n{\"added\":\"appli@x.y\"}\n\n\n\n\n\nMethod org.AGL.afm.user.uninstall\n\n\nDescription\n: Uninstall an application from its id.\n\n\nNote that this methods is a simple accessor to\n\norg.AGL.afm.system.uninstall\n method from \nafm-system-daemon\n.\n\n\nAfter the uninstallation and before returning to the sender,\n\nafm-user-daemon\n sends the signal \norg.AGL.afm.user.changed\n.\n\n\nInput\n: the \nid\n of the application and, optionally, the path to\napplication \nroot\n.\n\n\nEither a string:\n\n\n\"appli@x.y\"\n\n\n\nOr an object:\n\n\n{\n  \"id\": \"appli@x.y\",\n  \"root\": \"/a/path/to/the/root\"\n}\n\n\n\noutput\n: the value 'true'.\n\n\n\n\nMethod org.AGL.afm.user.start\n\n\nDescription\n:\n\n\nInput\n: the \nid\n of the application and, optionally, the\nstart \nmode\n as below.\n\n\nEither just a string:\n\n\n\"appli@x.y\"\n\n\n\nOr an object containing field \"id\" of type string and\noptionally a field mode:\n\n\n{\"id\":\"appli@x.y\",\"mode\":\"local\"}\n\n\n\nThe field \"mode\" is a string equal to either \"local\" or \"remote\".\n\n\noutput\n: The \nrunid\n of the application launched. \nrunid\n is an integer.\n\n\n\n\nMethod org.AGL.afm.user.terminate\n\n\nDescription\n: Terminates the application attached to \nrunid\n.\n\n\nInput\n: The \nrunid\n (an integer) of running instance to terminate.\n\n\noutput\n: the value 'true'.\n\n\n\n\nMethod org.AGL.afm.user.stop\n\n\nDescription\n: Stops the application attached to \nrunid\n until terminate or continue.\n\n\nInput\n: The \nrunid\n (integer) of the running instance to stop.\n\n\noutput\n: the value 'true'.\n\n\n\n\nMethod org.AGL.afm.user.continue\n\n\nDescription\n: Continues the application attached to \nrunid\n previously stopped.\n\n\nInput\n: The \nrunid\n (integer) of the running instance to continue.\n\n\noutput\n: the value 'true'.\n\n\n\n\nMethod org.AGL.afm.user.state\n\n\nDescription\n: Get informations about a running instance of \nrunid\n.\n\n\nInput\n: The \nrunid\n (integer) of the running instance inspected.\n\n\noutput\n: An object describing instance state. It contains:\nthe runid (integer), the id of the running application (string),\nthe state of the application (string either: \"starting\", \"running\", \"stopped\").\n\n\nExample of returned state:\n\n\n{\n  \"runid\": 2,\n  \"state\": \"running\",\n  \"id\": \"appli@x.y\"\n}\n\n\n\n\n\nMethod org.AGL.afm.user.runners\n\n\nDescription\n: Get the list of currently running instances.\n\n\nInput\n: anything.\n\n\noutput\n: An array of states, one per running instance, as returned by\nthe methodd \norg.AGL.afm.user.state\n.", 
            "title": "Afm user daemon"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#the-afm-user-daemon", 
            "text": "", 
            "title": "The afm-user-daemon"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#foreword", 
            "text": "This document describes application framework user daemon fundamentals. \nFCF (Fully Conform to Specification) implementation is still under development.\nIt may happen that current implementation somehow diverges with specifications.", 
            "title": "Foreword"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#introduction", 
            "text": "The daemon  afm-user-daemon  is in charge of handling\napplications on behalf of a user. Its main tasks are:    enumerate applications that end user can run\n   and keep this list available on demand    start applications on behalf of end user, set user running\n   environment, set user security context    list current runnable or running applications    stop (aka pause), continue (aka resume), terminate\n   a running instance of a given application    transfer requests for installation/uninstallation\n   of applications to the corresponding system daemon\n    afm-system-daemon    The  afm-user-daemon  takes its orders from the session\ninstance of D-Bus.  The figure below summarizes the situation of  afm-user-daemon  in the system.  +------------------------------------------------------------+\n|                          User                              |\n|                                 +---------------------+    |\n|     +---------------------+     |   Smack isolated    |    |\n|     |   D-Bus   session   +     |    APPLICATIONS     |    |\n|     +----------+----------+     +---------+-----------+    |\n|                |                          |                |\n|                |                          |                |\n|     +----------+--------------------------+-----------+    |\n|     |                                                 |    |\n|     |                  afm-user-daemon                |    |\n|     |                                                 |    |\n|     +----------+----------------------+----------+----+    |\n|                |                      |          :         |\n|                |                      |          :         |\n:================|======================|==========:=========:\n|                |                      |          :         |\n|     +----------+----------+     +-----+-----+    :         |\n|     |   D-Bus   system    +-----+  CYNARA   |    :         |\n|     +----------+----------+     +-----+-----+    :         |\n|                |                      |          :         |\n|     +----------+---------+    +-------+----------+----+    |\n|     | afm-system-daemon  +----+   SECURITY-MANAGER    |    |\n|     +--------------------+    +-----------------------+    |\n|                                                            |\n|                          System                            |\n+------------------------------------------------------------+", 
            "title": "Introduction"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#tasks-of-afm-user-daemon", 
            "text": "", 
            "title": "Tasks of afm-user-daemon"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#maintaining-list-of-applications", 
            "text": "At start  afm-user-daemon  scans the directories containing\napplications and load in memory a list of avaliable applications\naccessible by current user.  When  afm-system-daemon  installs or removes an application.\nOn success it sends the signal  org.AGL.afm.system.changed .\nWhen receiving such a signal,  afm-user-daemon  rebuilds its\napplications list.  afm-user-daemon  provides the data it collects about\napplications to its clients. Clients may either request the full list\nof avaliable applications or a more specific information about a\ngiven application.", 
            "title": "Maintaining list of applications"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#launching-application", 
            "text": "afm-user-daemon  launches application. Its builds a secure\nenvironment for the application before starting it within a\nsecured environment.  Different kind of applications can be launched.  This is set using a configuration file that describes\nhow to launch an application of a given kind within a given\nmode.  There is two launching modes: local or remote.  Launching an application locally means that\nthe application and its binder are launched together.  Launching application remotely translates in only launching \nthe application binder. The UI by itself has to be activated\nremotely by the requested (ie: HTML5 homescreen in a browser)  Once launched, running instances of application receive\na runid that identify them.", 
            "title": "Launching application"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#managing-instances-of-running-applications", 
            "text": "afm-user-daemon  manages the list of applications\nthat it launched.  When owning the right permissions, a client can get the list\nof running instances and details about a specific\nrunning instance. It can also terminates, stops or\ncontinues a given application.", 
            "title": "Managing instances of running applications"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#installing-and-uninstalling-applications", 
            "text": "If the client own the right permissions, afm-user-daemon  delegates that task\nto  afm-system-daemon .", 
            "title": "Installing and uninstalling applications"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#starting-afm-user-daemon", 
            "text": "afm-user-daemon  is launched as a  systemd  service\nattached to user sessions. Normally, the service file is\nlocated at /usr/lib/systemd/user/afm-user-daemon.service.  The options for launching  afm-user-daemon  are:  -a\n--application directory\n\n     Includes the given application directory to\n     the database base of applications.\n\n     Can be repeated.\n\n-r\n--root directory\n\n     Includes root application directory or directories when\n     passing multiple rootdir to\n     applications database.\n\n     Note that default root directory for\n     applications is always added. In current version\n     /usr/share/afm/applications is used as default.\n\n-m\n--mode (local|remote)\n\n     Set the default launch mode.\n     The default value is 'local'\n\n-d\n--daemon\n\n     Daemonizes the process. It is not needed by sytemd.\n\n-q\n--quiet\n\n     Reduces the verbosity (can be repeated).\n\n-v\n--verbose\n\n     Increases the verbosity (can be repeated).\n\n-h\n--help\n\n     Prints a short help.", 
            "title": "Starting afm-user-daemon"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#launcher-configuration", 
            "text": "It contains rules for launching applications.\nWhen  afm-user-daemon  has to launch an application,\nit looks for launch mode (local or remote), as well as\nfor the type of application describe in  config.xml \nwidget configuration file.  This tuple mode+type allows to select the adequate rule.  Configuration file is  /etc/afm/afm-launch.conf .  It contains sections and rules. It can also contain comments\nand empty lines to improve readability.  The separators are space and tabulation, any other character\nshould have a meaning.  The format is line oriented.\nThe new line character separate the lines.  Lines having only separators are blank lines and ignored.\nLine having character #(sharp) at first position are comment\nlines and ignored.  Lines not starting with a separator are different\nfrom lines starting with a separator character.  The grammar of the configuration file is defined below:  CONF: *COMMENT *SECTION\n\nSECTION: MODE *RULE\n\nRULE: +TYPE VECTOR ?VECTOR\n\nMODE: 'mode' +SEP ('local' | 'remote') *SEP EOL\n\nTYPE: DATA *SEP EOL\n\nVECTOR: +SEP DATA *(+SEP NDATA) *SEP EOL\n\nDATA: CHAR *NCHAR\nNDATA: +NCHAR\n\nEOL: NL *COMMENT\nCOMMENT: *SEP CMT *(SEP | NCHAR) NL\n\nNL: '\\x0a'\nSEP: '\\x20' | '\\x09'\nCMT: '#'\nCHAR: '\\x00'..'\\x08' | '\\x0b'..'\\x1f' | '\\x21' | '\\x22' | '\\x24'..'\\xff'\nNCHAR: CMT | CHAR  Here is a sample of configuration file for defining how\nto launch an application of types  application/x-executable , text/x-shellscript  and  text/html  in local mode:  mode local\n\napplication/x-executable\ntext/x-shellscript\n    %r/%c\n\ntext/html\n    /usr/bin/afb-daemon --mode=local --readyfd=%R --alias=/icons:%I --port=%P --rootdir=%r --token=%S --sessiondir=%D/.afb-daemon\n    /usr/bin/web-runtime http://localhost:%P/%c?token=%S  This shows that:   within a section, several rules can be defined  within a rule, several types can be defined  within a rule, one or two vectors can be defined  vectors are using %substitution  launched binaries must be defined with their full path", 
            "title": "Launcher Configuration"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#mode-local", 
            "text": "Within this mode, the launchers have either one or two description vectors.\nAll of those vectors are treated as programs\nand are executed with 'execve' system call.  The first vector is the leader vector and it defines the process\ngroup. The second vector (if any) is attached to the group\ndefined by this first vector.", 
            "title": "mode local"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#mode-remote", 
            "text": "Within this mode, the launchers have either one or two vectors\ndescribing them.  The first vector is process as a program and is executed with\nsystem call 'execve'.  The second vector (if any) defines a text that is returned\nto the caller. This mechanism can be used to return a uri\nfor remote UI to connect on the newly launched application.  The daemon  afm-user-daemon  allocates a port for each\nnew remote application.\nThe current implementation port allocation is incremental.\nA smarter (cacheable and discoverable) allocation should be defined.", 
            "title": "mode remote"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#substitutions", 
            "text": "Vectors can include sequences of 2 characters that have a special\nmeaning. These sequences are named  %substitution  because their\nfirst character is the percent sign (%) and because each occurrence\nof the sequence is replaced, at launch time, by the value associated\nto sequences.  Here is the list of  %substitutions :   %% : %.   This simply emits the percent sign %   %a : appid   Holds application Id of launched application.  Defined by the attribute  id  of the element  \n   of  config.xml .   %b : bindings   In the future should represent the list of bindings and bindings directory separated by ','.\n   Warning: not supported in current version.   %c : content   The file within the widget directory that is the entry point.  For HTML applications, it represents the relative path to main\n   page (aka index.html).  Defined by attribute  src  of the element   within  config.xml .   %D : datadir   Path of the directory where the application runs (cwd)\n   and stores its data.  It is equal to %h/%a.   %H : height   Requested height for the widget.  Defined by the attribute  height  of the element  \n   of  config.xml .   %h : homedir   Path of the home directory for all applications.  It is generally equal to $HOME/app-data   %I : icondir   Path of the directory were the icons of the applications can be found.   %m : mime-type   Mime type of the launched application.  Defined by the attribute  type  of the element  \n   of  config.xml .   %n : name   Name of the application as defined by the content of the\n   element   of  config.xml .   %P : port   A port to use. It is currently a kind of random port. The precise\n   model is to be defined later.   %R : readyfd   Number of file descriptor to use for signaling\n   readiness of launched process.   %r : rootdir   Path of directory containing the widget and its data.   %S : secret   An hexadecimal number that can be used to initialize pairing of client\n   and application binder.   %W : width   Requested width for the widget.  Defined by the attribute  width  of the element  \n   of  config.xml .", 
            "title": "%substitutions"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#the-d-bus-interface", 
            "text": "", 
            "title": "The D-Bus interface"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#overview-of-the-dbus-interface", 
            "text": "afm-user-daemon  takes its orders from the session instance\nof D-Bus. D-Bus is nice to use in this context because it allows\ndiscovery and signaling.  The dbus session is by default addressed by environment\nvariable  DBUS_SESSION_BUS_ADDRESS . Using  systemd  \nvariable  DBUS_SESSION_BUS_ADDRESS  is automatically set for\nuser sessions.  The  afm-user-daemon  is listening on destination name org.AGL.afm.user  at object path  /org/AGL/afm/user \non interface  org.AGL.afm.user  for following members:\n  runnables ,  detail ,  start ,  terminate , stop ,  continue ,  runners ,  state , install  and  uninstall .  D-Bus is mainly used for signaling and discovery. Its optimized\ntyped protocol is not used except for transmission of standalone strings.  Clients and Services are using JSON serialisation to exchange data.   The D-Bus interface is defined by:    DESTINATION:  org.AGL.afm.user    PATH:  /org/AGL/afm/user    INTERFACE:  org.AGL.afm.user    The signature of any member of the interface is  string -  string \nfor  JSON -  JSON .  This is the normal case. In case of error, the current implementation\nreturns a dbus error as a string.  Here an example using  dbus-send  to query data on\ninstalled applications.  dbus-send --session --print-reply \\\n    --dest=org.AGL.afm.user \\\n    /org/AGL/afm/user \\\n    org.AGL.afm.user.runnables string:true", 
            "title": "Overview of the dbus interface"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#using-afm-util", 
            "text": "The command line tool  afm-util  uses dbus-send to send\norders to  afm-user-daemon . This small scripts allows to\nsend command to  afm-user-daemon  either interactively\nat shell prompt or scriptically.  The syntax is simple: it accept a command and when requires attached arguments.  Here is the summary of  afm-util :   afm-util runnables       :   list the runnable widgets installed   afm-util install    wgt  :   install the wgt file   afm-util uninstall  id   :   remove the installed widget of id   afm-util detail     id   :   print detail about the installed widget of id   afm-util runners         :   list the running instance   afm-util start      id   :   start an instance of the widget of id   afm-util terminate  rid  :   terminate the running instance rid   afm-util stop       rid  :   stop the running instance rid   afm-util continue   rid  :   continue the previously rid   afm-util state      rid  :   get status of the running instance rid  Here is how to list applications using  afm-util :  afm-util runnables", 
            "title": "Using afm-util"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#the-protocol-over-d-bus", 
            "text": "Recall:    DESTINATION : org.AGL.afm.user    PATH : /org/AGL/afm/user    INTERFACE : org.AGL.afm.user", 
            "title": "The protocol over D-Bus"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#method-orgaglafmuserdetail", 
            "text": "Description : Get details about an application from its id.  Input : the id of the application as below.  Either just a string:  \"appli@x.y\"  Or an object having the field \"id\" of type string:  {\"id\":\"appli@x.y\"}  Output : A JSON object describing the application containing\nthe fields described below.  {\n  \"id\":          string, the application id (id@version)\n  \"version\":     string, the version of the application\n  \"width\":       integer, requested width of the application\n  \"height\":      integer, resqueted height of the application\n  \"name\":        string, the name of the application\n  \"description\": string, the description of the application\n  \"shortname\":   string, the short name of the application\n  \"author\":      string, the author of the application\n}", 
            "title": "Method org.AGL.afm.user.detail"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#method-orgaglafmuserrunnables", 
            "text": "Description : Get the list of applications that can be run.  Input : any valid json entry, can be anything except null.  output : An array of description of the runnable applications.\nEach item of the array contains an object containing the detail of\nan application as described above for the method org.AGL.afm.user.detail .", 
            "title": "Method org.AGL.afm.user.runnables"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#method-orgaglafmuserinstall", 
            "text": "Description : Install an application from its widget file.  If an application of the same  id  and  version  exists, it is not\nreinstalled except when  force=true .  Applications are installed in the subdirectories of the common directory\nreserved for applications.\nIf  root  is specified, the application is installed under\nsub-directories of defined  root .  Note that this methods is a simple accessor to the method org.AGL.afm.system.install  of  afm-system-daemon .  After the installation and before returning to the sender, afm-user-daemon  sends the signal  org.AGL.afm.user.changed .  Input : The  path  of widget file to be installed. Optionally,\na flag to  force  reinstallation and/or a  root  directory.  Simple form a simple string containing the absolute widget path:  \"/a/path/driving/to/the/widget\"  Or an object:  {\n  \"wgt\": \"/a/path/to/the/widget\",\n  \"force\": false,\n  \"root\": \"/a/path/to/the/root\"\n}  \"wgt\" and \"root\" MUST be absolute paths.  output : An object containing field \"added\" to use as application ID.  {\"added\":\"appli@x.y\"}", 
            "title": "Method org.AGL.afm.user.install"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#method-orgaglafmuseruninstall", 
            "text": "Description : Uninstall an application from its id.  Note that this methods is a simple accessor to org.AGL.afm.system.uninstall  method from  afm-system-daemon .  After the uninstallation and before returning to the sender, afm-user-daemon  sends the signal  org.AGL.afm.user.changed .  Input : the  id  of the application and, optionally, the path to\napplication  root .  Either a string:  \"appli@x.y\"  Or an object:  {\n  \"id\": \"appli@x.y\",\n  \"root\": \"/a/path/to/the/root\"\n}  output : the value 'true'.", 
            "title": "Method org.AGL.afm.user.uninstall"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#method-orgaglafmuserstart", 
            "text": "Description :  Input : the  id  of the application and, optionally, the\nstart  mode  as below.  Either just a string:  \"appli@x.y\"  Or an object containing field \"id\" of type string and\noptionally a field mode:  {\"id\":\"appli@x.y\",\"mode\":\"local\"}  The field \"mode\" is a string equal to either \"local\" or \"remote\".  output : The  runid  of the application launched.  runid  is an integer.", 
            "title": "Method org.AGL.afm.user.start"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#method-orgaglafmuserterminate", 
            "text": "Description : Terminates the application attached to  runid .  Input : The  runid  (an integer) of running instance to terminate.  output : the value 'true'.", 
            "title": "Method org.AGL.afm.user.terminate"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#method-orgaglafmuserstop", 
            "text": "Description : Stops the application attached to  runid  until terminate or continue.  Input : The  runid  (integer) of the running instance to stop.  output : the value 'true'.", 
            "title": "Method org.AGL.afm.user.stop"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#method-orgaglafmusercontinue", 
            "text": "Description : Continues the application attached to  runid  previously stopped.  Input : The  runid  (integer) of the running instance to continue.  output : the value 'true'.", 
            "title": "Method org.AGL.afm.user.continue"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#method-orgaglafmuserstate", 
            "text": "Description : Get informations about a running instance of  runid .  Input : The  runid  (integer) of the running instance inspected.  output : An object describing instance state. It contains:\nthe runid (integer), the id of the running application (string),\nthe state of the application (string either: \"starting\", \"running\", \"stopped\").  Example of returned state:  {\n  \"runid\": 2,\n  \"state\": \"running\",\n  \"id\": \"appli@x.y\"\n}", 
            "title": "Method org.AGL.afm.user.state"
        }, 
        {
            "location": "/developer/app-framework/main/afm-user-daemon/#method-orgaglafmuserrunners", 
            "text": "Description : Get the list of currently running instances.  Input : anything.  output : An array of states, one per running instance, as returned by\nthe methodd  org.AGL.afm.user.state .", 
            "title": "Method org.AGL.afm.user.runners"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/", 
            "text": "Application framework\n\n\nForeword\n\n\nThis document describes application framework fundamentals. \nFCF (Fully Conform to Specification) implementation is still under development.\nIt may happen that current implementation somehow diverges with specifications.\n\n\nOverview\n\n\nThe application framework on top of the security framework\nprovides components to install and uninstall applications\nas well as to run them in a secured environment.\n\n\nThe goal of the framework is to manage applications and hide security details\nto applications.\n\n\nFor the reasons explained in introduction, it was choose not to reuse Tizen\napplication framework directly, but to rework a new framework inspired from Tizen.\n\n\nfundamentals remain identical: the applications are distributed\nin a digitally signed container that should match widget specifications\nnormalized by the W3C. This is described by the technical\nrecommendations \nwidgets\n and \nwidgets-digsig\n of the W3 consortium.\n\n\nAs today this model allows the distribution of HTML, QML and binary applications\nbut it could be extended to any other class of applications.\n\n\nThe management of widget package signatures.\nCurrent model is only an initial step, it might be extended in the\nfuture to include new feature (ie: incremental delivery).\n\n\nComparison to other frameworks\n\n\nTizen framework\n\n\nxdg-app\n\n\nostro\n\n\norganization of directory of applications\n\n\nThe main path for applications are: APPDIR/PKGID/VER.\n\n\nWhere:\n\n\n\n\nAPPDIR is as defined above\n\n\nPKGID is a directory whose name is the package identifier\n\n\nVER is the version of the package MAJOR.MINOR\n\n\n\n\nThe advantage of such an organization is to allow several versions to live together.\nThis is required for multiple reasons (ie: roll back) and to comply with developers habits.\n\n\nIdentity of installed files\n\n\nAll the files are installed as user \"userapp\" and group \"userapp\".\nAll files have rw(x) for user and r-(x) for group and others.\n\n\nThis allows any user to read files.\n\n\nlabeling the directories of applications\n\n\norganization of data\n\n\nThe data of a user are contain within its directory and are labeled using the application labels\n\n\nSetting Smack rules for the application\n\n\nFor Tizen, the following rules are set by the security manager for each application.\n\n\nSystem ~APP~             rwx\nSystem ~PKG~             rwxat\nSystem ~PKG~::RO         rwxat\n~APP~  System            wx\n~APP~  System::Shared    rxl\n~APP~  System::Run       rwxat\n~APP~  System::Log       rwxa\n~APP~  _                 l\nUser   ~APP~             rwx\nUser   ~PKG~             rwxat\nUser   ~PKG~::RO         rwxat\n~APP~  User              wx\n~APP~  User::Home        rxl\n~APP~  User::App::Shared rwxat\n~APP~  ~PKG~             rwxat\n~APP~  ~PKG~::RO         rxl\n\n\n\nHere, ~PKG~ is the identifier of the package and ~APP~ is the identifier of the application.\n\n\nWhat user can run an application?\n\n\nNot all user are able to run all applications.\nHow to manage that?", 
            "title": "Application framework"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/#application-framework", 
            "text": "", 
            "title": "Application framework"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/#foreword", 
            "text": "This document describes application framework fundamentals. \nFCF (Fully Conform to Specification) implementation is still under development.\nIt may happen that current implementation somehow diverges with specifications.", 
            "title": "Foreword"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/#overview", 
            "text": "The application framework on top of the security framework\nprovides components to install and uninstall applications\nas well as to run them in a secured environment.  The goal of the framework is to manage applications and hide security details\nto applications.  For the reasons explained in introduction, it was choose not to reuse Tizen\napplication framework directly, but to rework a new framework inspired from Tizen.  fundamentals remain identical: the applications are distributed\nin a digitally signed container that should match widget specifications\nnormalized by the W3C. This is described by the technical\nrecommendations  widgets  and  widgets-digsig  of the W3 consortium.  As today this model allows the distribution of HTML, QML and binary applications\nbut it could be extended to any other class of applications.  The management of widget package signatures.\nCurrent model is only an initial step, it might be extended in the\nfuture to include new feature (ie: incremental delivery).", 
            "title": "Overview"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/#comparison-to-other-frameworks", 
            "text": "", 
            "title": "Comparison to other frameworks"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/#tizen-framework", 
            "text": "", 
            "title": "Tizen framework"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/#xdg-app", 
            "text": "", 
            "title": "xdg-app"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/#ostro", 
            "text": "", 
            "title": "ostro"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/#organization-of-directory-of-applications", 
            "text": "The main path for applications are: APPDIR/PKGID/VER.  Where:   APPDIR is as defined above  PKGID is a directory whose name is the package identifier  VER is the version of the package MAJOR.MINOR   The advantage of such an organization is to allow several versions to live together.\nThis is required for multiple reasons (ie: roll back) and to comply with developers habits.", 
            "title": "organization of directory of applications"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/#identity-of-installed-files", 
            "text": "All the files are installed as user \"userapp\" and group \"userapp\".\nAll files have rw(x) for user and r-(x) for group and others.  This allows any user to read files.", 
            "title": "Identity of installed files"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/#labeling-the-directories-of-applications", 
            "text": "", 
            "title": "labeling the directories of applications"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/#organization-of-data", 
            "text": "The data of a user are contain within its directory and are labeled using the application labels", 
            "title": "organization of data"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/#setting-smack-rules-for-the-application", 
            "text": "For Tizen, the following rules are set by the security manager for each application.  System ~APP~             rwx\nSystem ~PKG~             rwxat\nSystem ~PKG~::RO         rwxat\n~APP~  System            wx\n~APP~  System::Shared    rxl\n~APP~  System::Run       rwxat\n~APP~  System::Log       rwxa\n~APP~  _                 l\nUser   ~APP~             rwx\nUser   ~PKG~             rwxat\nUser   ~PKG~::RO         rwxat\n~APP~  User              wx\n~APP~  User::Home        rxl\n~APP~  User::App::Shared rwxat\n~APP~  ~PKG~             rwxat\n~APP~  ~PKG~::RO         rxl  Here, ~PKG~ is the identifier of the package and ~APP~ is the identifier of the application.", 
            "title": "Setting Smack rules for the application"
        }, 
        {
            "location": "/developer/app-framework/main/application-framework/#what-user-can-run-an-application", 
            "text": "Not all user are able to run all applications.\nHow to manage that?", 
            "title": "What user can run an application?"
        }, 
        {
            "location": "/developer/app-framework/main/", 
            "text": "AGL framework, overview of the proposal of IoT.bzh\n\n\nForeword\n\n\nThis document describes what we intend to do. It may happen that our\ncurrent implementation and the content of this document differ.\n\n\nIn case of differences, it is assumed that this document is right\nand the implementation is wrong.\n\n\nIntroduction\n\n\nDuring the first works in having the security model of Tizen\nintegrated in AGL (Automotive Grade Linux) distribution, it became\nquickly obvious that the count of components specific to Tizen\nto integrate was huge.\n\n\nHere is a minimal list of what was needed:\n\n\n\n\nplatform/appfw/app-installers\n\n\nplatform/core/security/cert-svc\n\n\nplatform/core/appfw/ail\n\n\nplatform/core/appfw/aul-1\n\n\nplatform/core/appfw/libslp-db-util\n\n\nplatform/core/appfw/pkgmgr-info\n\n\nplatform/core/appfw/slp-pkgmgr\n\n\n\n\nBut this list is complete because many dependencies are hidden.\nThose hidden dependencies are including some common libraries but also many\ntizen specific sub-components (iniparser, bundle, dlog, libtzplatform-config,\ndb-util, vconf-buxton, ...).\n\n\nThis is an issue because AGL is not expected to be Tizen. Taking it would\neither need to patch it for removing unwanted components or to take all\nof them.\n\n\nHowever, a careful study of the core components of the security framework\nof Tizen showed that their dependencies to Tizen are light (and since some\nof our work, there is no more dependency to tizen).\nThose components are \ncynara\n, \nsecurity-manager\n, \nD-Bus aware of cynara\n.\n\n\nLuckyly, these core security components of Tizen are provided\nby \nmeta-intel-iot-security\n, a set of yocto layers.\nThese layers were created by Intel to isolate Tizen specific security\ncomponents from the initial port of Tizen to Yocto.\nThe 3 layers are providing components for:\n\n\n\n\nImplementing Smack LSM\n\n\nImplementing Integrity Measurement Architecture\n\n\nImplementing Tizen Security Framework\n\n\n\n\nThe figure below shows the history of these layers.\n\n\n                  2014         2015\nTizen OBS ----------+---------------------------\n\n                     \\\n                      \\\n     Tizen Yocto       +---------+--------------\n\n                                  \\\n                                   \\\n       meta-intel-iot-security      +-----------\n\n\n\n\nWe took the decision to use these security layers that provides the\nbasis of the Tizen security, the security framework.\n\n\nFor the components of the application framework, built top of\nthe security framework, instead of pulling the huge set of packages\nfrom Tizen, we decided to refit it by developping a tiny set of\ncomponents that would implement the same behaviour but without all\nthe dependencies and with minor architectural improvements for AGL.\n\n\nThese components are \nafm-system-daemon\n and \nafm-user-daemon\n.\nThey provides infrastructure for installing, uninstalling,\nlaunching, terminating, stopping and resuming applications in\na multi user secure environment.\n\n\nA third component exists in the framework, the binder \nafb-daemon\n.\nThe binder provides the easiest way to provide secured API for\nany tier. Currently, the use of the binder is not absolutely mandatory.\n\n\nThis documentation explains the framework created by IoT.bzh\nby rewriting the Tizen Application Framework. Be aware of the\nprevious foreword.\n\n\nOverview\n\n\nThe figure below shows the major components of the framework\nand their interactions going through the following scenario:\nAPPLICATION installs an other application and then launch it.\n\n\n+-----------------------------------------------------------------------+\n|                                 User                                  |\n|  ................................                                     |\n|  :   Smack isolation context    :                                     |\n|  :                              :      ...........................    |\n|  :  +-----------------------+   :      : Smack isolation context :    |\n|  :  |                       |   :      :                         :    |\n|  :  |      APPLICATION      |   :      :     OTHER application   :    |\n|  :  |                       |   :      :.........................:    |\n|  :  +-----------+-----------+   :                ^                    |\n|  :              |               :                |                    |\n|  :              |(1),(7)        :                |(13)                |\n|  :              |               :                |                    |\n|  :  +-----------v-----------+   :      +---------+---------------+    |\n|  :  |   binder afb-daemon   |   :      |                         |    |\n|  :  +-----------------------+   :      |      afm-user-daemon    |    |\n|  :  |    afm-main-binding   |   :      |                         |    |\n|  :  +-----+--------------+--+   :      +------^-------+------+---+    |\n|  :........|..............|......:             |       |      :        |\n|           |(2)           |(8)                 |(10)   |      :        |\n|           |              |                    |       |      :        |\n|           |         +----v--------------------+---+   |      :        |\n|           |         |        D-Bus   session      |   |(11)  :(12)    |\n|           |         +-------------------------+---+   |      :        |\n|           |                                   |       |      :        |\n|           |                                   |(9)    |      :        |\n|           |                                   |       |      :        |\n:===========|===================================|=======|======:========:\n|           |                                   |       |      :        |\n|           |                               +---v-------v--+   :        |\n|    +------v-------------+     (3)         |              |   :        |\n|    |  D-Bus   system    +-----------------\n    CYNARA    |   :        |\n|    +------+-------------+                 |              |   :        |\n|           |                               +------^-------+   :        |\n|           |(4)                                   |           :        |\n|           |                                      |(6)        v        |\n|    +------v--------------+             +---------+---------------+    |\n|    |                     |    (5)      |                         |    |\n|    |  afm-system-daemon  +-------------\n     SECURITY-MANAGER    |    |\n|    |                     |             |                         |    |\n|    +---------------------+             +-------------------------+    |\n|                                                                       |\n|                              System                                   |\n+-----------------------------------------------------------------------+\n\n\n\nLet follow the sequence of calls:\n\n\n\n\n\n\nAPPLICATION calls its \nbinder\n to install the OTHER application.\n\n\n\n\n\n\nThe binding \nafm-main-binding\n of the \nbinder\n calls, through\n   \nD-Bus\n system, the system daemon to install the OTHER application.\n\n\n\n\n\n\nThe system \nD-Bus\n checks wether APPLICATION has the permission\n   or not to install applications by calling \nCYNARA\n.\n\n\n\n\n\n\nThe system \nD-Bus\n transmits the request to \nafm-system-daemon\n.\n\n\n\n\n\n\nafm-system-daemon\n checks the application to install, its\n   signatures and rights and install it.\n\n\n\n\n\n\nafm-system-daemon\n calls \nSECURITY-MANAGER\n for fullfilling\n   security context of the installed application.\n\n\n\n\n\n\nSECURITY-MANAGER\n calls \nCYNARA\n to install initial permissions\n   for the application.\n\n\n\n\n\n\nAPPLICATION call its binder to start the nearly installed OTHER application.\n\n\n\n\n\n\nThe binding \nafm-main-binding\n of the \nbinder\n calls, through\n   \nD-Bus\n session, the user daemon to launch the OTHER application.\n\n\n\n\n\n\nThe session \nD-Bus\n checks wether APPLICATION has the permission\n   or not to start an application by calling \nCYNARA\n.\n\n\n\n\n\n\nThe session \nD-Bus\n transmits the request to \nafm-user-daemon\n.\n\n\n\n\n\n\nafm-user-daemon\n checks wether APPLICATION has the permission\n    or not to start the OTHER application \nCYNARA\n.\n\n\n\n\n\n\nafm-user-daemon\n uses \nSECURITY-MANAGER\n features to set\n    the seciruty context for the OTHER application.\n\n\n\n\n\n\nafm-user-daemon\n launches the OTHER application.\n\n\n\n\n\n\nThis scenario does not cover all the features of the frameworks.\nShortly because details will be revealed in the next chapters,\nthe components are:\n\n\n\n\n\n\nSECURITY-MANAGER\n: in charge of setting Smack contexts and rules,\n  of setting groups, and, of creating initial content of \nCYNARA\n rules\n  for applications.\n\n\n\n\n\n\nCYNARA\n: in charge of handling API access permissions by users and by\n  applications.\n\n\n\n\n\n\nD-Bus\n: in charge of checking security of messaging. The usual D-Bus\n  security rules are enhanced by \nCYNARA\n checking rules.\n\n\n\n\n\n\nafm-system-daemon\n: in charge of installing and uninstalling applications.\n\n\n\n\n\n\nafm-user-daemon\n: in charge of listing applications, querying application details,\n  starting, terminating, stopping, resuming applications and their instances\n  for a given user context.\n\n\n\n\n\n\nafb-binder\n: in charge of serving resources and features through an\n  HTTP interface.\n\n\n\n\n\n\nafm-main-binding\n: This binding allows applications to use the API\n  of the AGL framework.\n\n\n\n\n\n\nLinks between the \"Security framework\" and the \"Application framework\"\n\n\nThe security framework refers to the security model used to ensure\nsecurity and to the tools that are provided for implementing that model.\n\n\nThe security model refers to how DAC (Discretionnary Access Control),\nMAC (Mandatory Access Control) and Capabilities are used by the system\nto ensure security and privacy. It also includes features of reporting\nusing audit features and by managing logs and alerts.\n\n\nThe application framework manages the applications:\ninstalling, uninstalling, starting, stopping, listing ...\n\n\nThe application framework uses the security model/framework\nto ensure the security and the privacy of the applications that\nit manages.\n\n\nThe application framework must be compliant with the underlyiong\nsecurity model/framework. But it should hide it to the applications.\n\n\nThe security framework\n\n\nThe implemented security model is the security model of Tizen 3.\nThis model is described \nhere\n.\n\n\nThe security framework then comes from Tizen 3 but through\nthe \nmeta-intel\n.\nIt includes: \nSecurity-Manager\n, \nCynara\n\nand \nD-Bus\n compliant to Cynara.\n\n\nTwo patches are applied to the security-manager. These patches are removing\ndependencies to packages specific of Tizen but that are not needed by AGL.\nNone of these patches adds or removes any behaviour.\n\n\nTheoritically, the security framework/model is an implementation details\nthat should not impact the layers above the application framework\n.\n\n\nThe security framework of Tizen provides \"nice lad\" a valuable component to\nscan log files and analyse auditing. This component is still in developement.\n\n\nThe application framework\n\n\nThe application framework on top of the security framework\nprovides the components to install and uninstall applications\nand to run it in a secured environment.\n\n\nThe goal is to manage applications and to hide the details of\nthe security framework to the applications.\n\n\nFor the reasons explained in introduction, we did not used the\napplication framework of Tizen as is but used an adaptation of it.\n\n\nThe basis is kept identical: the applications are distributed\nin a digitally signed container that must match the specifications\nof widgets (web applications). This is described by the technical\nrecomendations \nwidgets\n and \nwidgets-digsig\n of the W3 consortium.\n\n\nThis model allows the distribution of HTML, QML and binary applications.\n\n\nThe management of signatures of the widget packages \nThis basis is not meant as being rigid and it can be extended in the\nfutur to include for example incremental delivery.", 
            "title": "Home"
        }, 
        {
            "location": "/developer/app-framework/main/#agl-framework-overview-of-the-proposal-of-iotbzh", 
            "text": "", 
            "title": "AGL framework, overview of the proposal of IoT.bzh"
        }, 
        {
            "location": "/developer/app-framework/main/#foreword", 
            "text": "This document describes what we intend to do. It may happen that our\ncurrent implementation and the content of this document differ.  In case of differences, it is assumed that this document is right\nand the implementation is wrong.", 
            "title": "Foreword"
        }, 
        {
            "location": "/developer/app-framework/main/#introduction", 
            "text": "During the first works in having the security model of Tizen\nintegrated in AGL (Automotive Grade Linux) distribution, it became\nquickly obvious that the count of components specific to Tizen\nto integrate was huge.  Here is a minimal list of what was needed:   platform/appfw/app-installers  platform/core/security/cert-svc  platform/core/appfw/ail  platform/core/appfw/aul-1  platform/core/appfw/libslp-db-util  platform/core/appfw/pkgmgr-info  platform/core/appfw/slp-pkgmgr   But this list is complete because many dependencies are hidden.\nThose hidden dependencies are including some common libraries but also many\ntizen specific sub-components (iniparser, bundle, dlog, libtzplatform-config,\ndb-util, vconf-buxton, ...).  This is an issue because AGL is not expected to be Tizen. Taking it would\neither need to patch it for removing unwanted components or to take all\nof them.  However, a careful study of the core components of the security framework\nof Tizen showed that their dependencies to Tizen are light (and since some\nof our work, there is no more dependency to tizen).\nThose components are  cynara ,  security-manager ,  D-Bus aware of cynara .  Luckyly, these core security components of Tizen are provided\nby  meta-intel-iot-security , a set of yocto layers.\nThese layers were created by Intel to isolate Tizen specific security\ncomponents from the initial port of Tizen to Yocto.\nThe 3 layers are providing components for:   Implementing Smack LSM  Implementing Integrity Measurement Architecture  Implementing Tizen Security Framework   The figure below shows the history of these layers.                    2014         2015\nTizen OBS ----------+--------------------------- \n                     \\\n                      \\\n     Tizen Yocto       +---------+-------------- \n                                  \\\n                                   \\\n       meta-intel-iot-security      +-----------   We took the decision to use these security layers that provides the\nbasis of the Tizen security, the security framework.  For the components of the application framework, built top of\nthe security framework, instead of pulling the huge set of packages\nfrom Tizen, we decided to refit it by developping a tiny set of\ncomponents that would implement the same behaviour but without all\nthe dependencies and with minor architectural improvements for AGL.  These components are  afm-system-daemon  and  afm-user-daemon .\nThey provides infrastructure for installing, uninstalling,\nlaunching, terminating, stopping and resuming applications in\na multi user secure environment.  A third component exists in the framework, the binder  afb-daemon .\nThe binder provides the easiest way to provide secured API for\nany tier. Currently, the use of the binder is not absolutely mandatory.  This documentation explains the framework created by IoT.bzh\nby rewriting the Tizen Application Framework. Be aware of the\nprevious foreword.", 
            "title": "Introduction"
        }, 
        {
            "location": "/developer/app-framework/main/#overview", 
            "text": "The figure below shows the major components of the framework\nand their interactions going through the following scenario:\nAPPLICATION installs an other application and then launch it.  +-----------------------------------------------------------------------+\n|                                 User                                  |\n|  ................................                                     |\n|  :   Smack isolation context    :                                     |\n|  :                              :      ...........................    |\n|  :  +-----------------------+   :      : Smack isolation context :    |\n|  :  |                       |   :      :                         :    |\n|  :  |      APPLICATION      |   :      :     OTHER application   :    |\n|  :  |                       |   :      :.........................:    |\n|  :  +-----------+-----------+   :                ^                    |\n|  :              |               :                |                    |\n|  :              |(1),(7)        :                |(13)                |\n|  :              |               :                |                    |\n|  :  +-----------v-----------+   :      +---------+---------------+    |\n|  :  |   binder afb-daemon   |   :      |                         |    |\n|  :  +-----------------------+   :      |      afm-user-daemon    |    |\n|  :  |    afm-main-binding   |   :      |                         |    |\n|  :  +-----+--------------+--+   :      +------^-------+------+---+    |\n|  :........|..............|......:             |       |      :        |\n|           |(2)           |(8)                 |(10)   |      :        |\n|           |              |                    |       |      :        |\n|           |         +----v--------------------+---+   |      :        |\n|           |         |        D-Bus   session      |   |(11)  :(12)    |\n|           |         +-------------------------+---+   |      :        |\n|           |                                   |       |      :        |\n|           |                                   |(9)    |      :        |\n|           |                                   |       |      :        |\n:===========|===================================|=======|======:========:\n|           |                                   |       |      :        |\n|           |                               +---v-------v--+   :        |\n|    +------v-------------+     (3)         |              |   :        |\n|    |  D-Bus   system    +-----------------     CYNARA    |   :        |\n|    +------+-------------+                 |              |   :        |\n|           |                               +------^-------+   :        |\n|           |(4)                                   |           :        |\n|           |                                      |(6)        v        |\n|    +------v--------------+             +---------+---------------+    |\n|    |                     |    (5)      |                         |    |\n|    |  afm-system-daemon  +-------------      SECURITY-MANAGER    |    |\n|    |                     |             |                         |    |\n|    +---------------------+             +-------------------------+    |\n|                                                                       |\n|                              System                                   |\n+-----------------------------------------------------------------------+  Let follow the sequence of calls:    APPLICATION calls its  binder  to install the OTHER application.    The binding  afm-main-binding  of the  binder  calls, through\n    D-Bus  system, the system daemon to install the OTHER application.    The system  D-Bus  checks wether APPLICATION has the permission\n   or not to install applications by calling  CYNARA .    The system  D-Bus  transmits the request to  afm-system-daemon .    afm-system-daemon  checks the application to install, its\n   signatures and rights and install it.    afm-system-daemon  calls  SECURITY-MANAGER  for fullfilling\n   security context of the installed application.    SECURITY-MANAGER  calls  CYNARA  to install initial permissions\n   for the application.    APPLICATION call its binder to start the nearly installed OTHER application.    The binding  afm-main-binding  of the  binder  calls, through\n    D-Bus  session, the user daemon to launch the OTHER application.    The session  D-Bus  checks wether APPLICATION has the permission\n   or not to start an application by calling  CYNARA .    The session  D-Bus  transmits the request to  afm-user-daemon .    afm-user-daemon  checks wether APPLICATION has the permission\n    or not to start the OTHER application  CYNARA .    afm-user-daemon  uses  SECURITY-MANAGER  features to set\n    the seciruty context for the OTHER application.    afm-user-daemon  launches the OTHER application.    This scenario does not cover all the features of the frameworks.\nShortly because details will be revealed in the next chapters,\nthe components are:    SECURITY-MANAGER : in charge of setting Smack contexts and rules,\n  of setting groups, and, of creating initial content of  CYNARA  rules\n  for applications.    CYNARA : in charge of handling API access permissions by users and by\n  applications.    D-Bus : in charge of checking security of messaging. The usual D-Bus\n  security rules are enhanced by  CYNARA  checking rules.    afm-system-daemon : in charge of installing and uninstalling applications.    afm-user-daemon : in charge of listing applications, querying application details,\n  starting, terminating, stopping, resuming applications and their instances\n  for a given user context.    afb-binder : in charge of serving resources and features through an\n  HTTP interface.    afm-main-binding : This binding allows applications to use the API\n  of the AGL framework.", 
            "title": "Overview"
        }, 
        {
            "location": "/developer/app-framework/main/#links-between-the-security-framework-and-the-application-framework", 
            "text": "The security framework refers to the security model used to ensure\nsecurity and to the tools that are provided for implementing that model.  The security model refers to how DAC (Discretionnary Access Control),\nMAC (Mandatory Access Control) and Capabilities are used by the system\nto ensure security and privacy. It also includes features of reporting\nusing audit features and by managing logs and alerts.  The application framework manages the applications:\ninstalling, uninstalling, starting, stopping, listing ...  The application framework uses the security model/framework\nto ensure the security and the privacy of the applications that\nit manages.  The application framework must be compliant with the underlyiong\nsecurity model/framework. But it should hide it to the applications.", 
            "title": "Links between the \"Security framework\" and the \"Application framework\""
        }, 
        {
            "location": "/developer/app-framework/main/#the-security-framework", 
            "text": "The implemented security model is the security model of Tizen 3.\nThis model is described  here .  The security framework then comes from Tizen 3 but through\nthe  meta-intel .\nIt includes:  Security-Manager ,  Cynara \nand  D-Bus  compliant to Cynara.  Two patches are applied to the security-manager. These patches are removing\ndependencies to packages specific of Tizen but that are not needed by AGL.\nNone of these patches adds or removes any behaviour.  Theoritically, the security framework/model is an implementation details\nthat should not impact the layers above the application framework .  The security framework of Tizen provides \"nice lad\" a valuable component to\nscan log files and analyse auditing. This component is still in developement.", 
            "title": "The security framework"
        }, 
        {
            "location": "/developer/app-framework/main/#the-application-framework", 
            "text": "The application framework on top of the security framework\nprovides the components to install and uninstall applications\nand to run it in a secured environment.  The goal is to manage applications and to hide the details of\nthe security framework to the applications.  For the reasons explained in introduction, we did not used the\napplication framework of Tizen as is but used an adaptation of it.  The basis is kept identical: the applications are distributed\nin a digitally signed container that must match the specifications\nof widgets (web applications). This is described by the technical\nrecomendations  widgets  and  widgets-digsig  of the W3 consortium.  This model allows the distribution of HTML, QML and binary applications.  The management of signatures of the widget packages \nThis basis is not meant as being rigid and it can be extended in the\nfutur to include for example incremental delivery.", 
            "title": "The application framework"
        }, 
        {
            "location": "/developer/app-framework/main/overview/", 
            "text": "AGL framework, overview of the proposal of IoT.bzh\n\n\nForeword\n\n\nThis document describes what we intend to do. It may happen that our\ncurrent implementation and the content of this document differ.\n\n\nIn case of differences, it is assumed that this document is right\nand the implementation is wrong.\n\n\nIntroduction\n\n\nDuring the first works in having the security model of Tizen\nintegrated in AGL (Automotive Grade Linux) distribution, it became\nquickly obvious that the count of components specific to Tizen\nto integrate was huge.\n\n\nHere is a minimal list of what was needed:\n\n\n\n\nplatform/appfw/app-installers\n\n\nplatform/core/security/cert-svc\n\n\nplatform/core/appfw/ail\n\n\nplatform/core/appfw/aul-1\n\n\nplatform/core/appfw/libslp-db-util\n\n\nplatform/core/appfw/pkgmgr-info\n\n\nplatform/core/appfw/slp-pkgmgr\n\n\n\n\nBut this list is complete because many dependencies are hidden.\nThose hidden dependencies are including some common libraries but also many\ntizen specific sub-components (iniparser, bundle, dlog, libtzplatform-config,\ndb-util, vconf-buxton, ...).\n\n\nThis is an issue because AGL is not expected to be Tizen. Taking it would\neither need to patch it for removing unwanted components or to take all\nof them.\n\n\nHowever, a careful study of the core components of the security framework\nof Tizen showed that their dependencies to Tizen are light (and since some\nof our work, there is no more dependency to tizen).\nThose components are \ncynara\n, \nsecurity-manager\n, \nD-Bus aware of cynara\n.\n\n\nLuckyly, these core security components of Tizen are provided\nby \nmeta-intel-iot-security\n, a set of yocto layers.\nThese layers were created by Intel to isolate Tizen specific security\ncomponents from the initial port of Tizen to Yocto.\nThe 3 layers are providing components for:\n\n\n\n\nImplementing Smack LSM\n\n\nImplementing Integrity Measurement Architecture\n\n\nImplementing Tizen Security Framework\n\n\n\n\nThe figure below shows the history of these layers.\n\n\n                  2014         2015\nTizen OBS ----------+---------------------------\n\n                     \\\n                      \\\n     Tizen Yocto       +---------+--------------\n\n                                  \\\n                                   \\\n       meta-intel-iot-security      +-----------\n\n\n\n\nWe took the decision to use these security layers that provides the\nbasis of the Tizen security, the security framework.\n\n\nFor the components of the application framework, built top of\nthe security framework, instead of pulling the huge set of packages\nfrom Tizen, we decided to refit it by developping a tiny set of\ncomponents that would implement the same behaviour but without all\nthe dependencies and with minor architectural improvements for AGL.\n\n\nThese components are \nafm-system-daemon\n and \nafm-user-daemon\n.\nThey provides infrastructure for installing, uninstalling,\nlaunching, terminating, stopping and resuming applications in\na multi user secure environment.\n\n\nA third component exists in the framework, the binder \nafb-daemon\n.\nThe binder provides the easiest way to provide secured API for\nany tier. Currently, the use of the binder is not absolutely mandatory.\n\n\nThis documentation explains the framework created by IoT.bzh\nby rewriting the Tizen Application Framework. Be aware of the\nprevious foreword.\n\n\nOverview\n\n\nThe figure below shows the major components of the framework\nand their interactions going through the following scenario:\nAPPLICATION installs an other application and then launch it.\n\n\n+-----------------------------------------------------------------------+\n|                                 User                                  |\n|  ................................                                     |\n|  :   Smack isolation context    :                                     |\n|  :                              :      ...........................    |\n|  :  +-----------------------+   :      : Smack isolation context :    |\n|  :  |                       |   :      :                         :    |\n|  :  |      APPLICATION      |   :      :     OTHER application   :    |\n|  :  |                       |   :      :.........................:    |\n|  :  +-----------+-----------+   :                ^                    |\n|  :              |               :                |                    |\n|  :              |(1),(7)        :                |(13)                |\n|  :              |               :                |                    |\n|  :  +-----------v-----------+   :      +---------+---------------+    |\n|  :  |   binder afb-daemon   |   :      |                         |    |\n|  :  +-----------------------+   :      |      afm-user-daemon    |    |\n|  :  |    afm-main-binding   |   :      |                         |    |\n|  :  +-----+--------------+--+   :      +------^-------+------+---+    |\n|  :........|..............|......:             |       |      :        |\n|           |(2)           |(8)                 |(10)   |      :        |\n|           |              |                    |       |      :        |\n|           |         +----v--------------------+---+   |      :        |\n|           |         |        D-Bus   session      |   |(11)  :(12)    |\n|           |         +-------------------------+---+   |      :        |\n|           |                                   |       |      :        |\n|           |                                   |(9)    |      :        |\n|           |                                   |       |      :        |\n:===========|===================================|=======|======:========:\n|           |                                   |       |      :        |\n|           |                               +---v-------v--+   :        |\n|    +------v-------------+     (3)         |              |   :        |\n|    |  D-Bus   system    +-----------------\n    CYNARA    |   :        |\n|    +------+-------------+                 |              |   :        |\n|           |                               +------^-------+   :        |\n|           |(4)                                   |           :        |\n|           |                                      |(6)        v        |\n|    +------v--------------+             +---------+---------------+    |\n|    |                     |    (5)      |                         |    |\n|    |  afm-system-daemon  +-------------\n     SECURITY-MANAGER    |    |\n|    |                     |             |                         |    |\n|    +---------------------+             +-------------------------+    |\n|                                                                       |\n|                              System                                   |\n+-----------------------------------------------------------------------+\n\n\n\nLet follow the sequence of calls:\n\n\n\n\n\n\nAPPLICATION calls its \nbinder\n to install the OTHER application.\n\n\n\n\n\n\nThe binding \nafm-main-binding\n of the \nbinder\n calls, through\n   \nD-Bus\n system, the system daemon to install the OTHER application.\n\n\n\n\n\n\nThe system \nD-Bus\n checks wether APPLICATION has the permission\n   or not to install applications by calling \nCYNARA\n.\n\n\n\n\n\n\nThe system \nD-Bus\n transmits the request to \nafm-system-daemon\n.\n\n\n\n\n\n\nafm-system-daemon\n checks the application to install, its\n   signatures and rights and install it.\n\n\n\n\n\n\nafm-system-daemon\n calls \nSECURITY-MANAGER\n for fullfilling\n   security context of the installed application.\n\n\n\n\n\n\nSECURITY-MANAGER\n calls \nCYNARA\n to install initial permissions\n   for the application.\n\n\n\n\n\n\nAPPLICATION call its binder to start the nearly installed OTHER application.\n\n\n\n\n\n\nThe binding \nafm-main-binding\n of the \nbinder\n calls, through\n   \nD-Bus\n session, the user daemon to launch the OTHER application.\n\n\n\n\n\n\nThe session \nD-Bus\n checks wether APPLICATION has the permission\n   or not to start an application by calling \nCYNARA\n.\n\n\n\n\n\n\nThe session \nD-Bus\n transmits the request to \nafm-user-daemon\n.\n\n\n\n\n\n\nafm-user-daemon\n checks wether APPLICATION has the permission\n    or not to start the OTHER application \nCYNARA\n.\n\n\n\n\n\n\nafm-user-daemon\n uses \nSECURITY-MANAGER\n features to set\n    the seciruty context for the OTHER application.\n\n\n\n\n\n\nafm-user-daemon\n launches the OTHER application.\n\n\n\n\n\n\nThis scenario does not cover all the features of the frameworks.\nShortly because details will be revealed in the next chapters,\nthe components are:\n\n\n\n\n\n\nSECURITY-MANAGER\n: in charge of setting Smack contexts and rules,\n  of setting groups, and, of creating initial content of \nCYNARA\n rules\n  for applications.\n\n\n\n\n\n\nCYNARA\n: in charge of handling API access permissions by users and by\n  applications.\n\n\n\n\n\n\nD-Bus\n: in charge of checking security of messaging. The usual D-Bus\n  security rules are enhanced by \nCYNARA\n checking rules.\n\n\n\n\n\n\nafm-system-daemon\n: in charge of installing and uninstalling applications.\n\n\n\n\n\n\nafm-user-daemon\n: in charge of listing applications, querying application details,\n  starting, terminating, stopping, resuming applications and their instances\n  for a given user context.\n\n\n\n\n\n\nafb-binder\n: in charge of serving resources and features through an\n  HTTP interface.\n\n\n\n\n\n\nafm-main-binding\n: This binding allows applications to use the API\n  of the AGL framework.\n\n\n\n\n\n\nLinks between the \"Security framework\" and the \"Application framework\"\n\n\nThe security framework refers to the security model used to ensure\nsecurity and to the tools that are provided for implementing that model.\n\n\nThe security model refers to how DAC (Discretionnary Access Control),\nMAC (Mandatory Access Control) and Capabilities are used by the system\nto ensure security and privacy. It also includes features of reporting\nusing audit features and by managing logs and alerts.\n\n\nThe application framework manages the applications:\ninstalling, uninstalling, starting, stopping, listing ...\n\n\nThe application framework uses the security model/framework\nto ensure the security and the privacy of the applications that\nit manages.\n\n\nThe application framework must be compliant with the underlyiong\nsecurity model/framework. But it should hide it to the applications.\n\n\nThe security framework\n\n\nThe implemented security model is the security model of Tizen 3.\nThis model is described \nhere\n.\n\n\nThe security framework then comes from Tizen 3 but through\nthe \nmeta-intel\n.\nIt includes: \nSecurity-Manager\n, \nCynara\n\nand \nD-Bus\n compliant to Cynara.\n\n\nTwo patches are applied to the security-manager. These patches are removing\ndependencies to packages specific of Tizen but that are not needed by AGL.\nNone of these patches adds or removes any behaviour.\n\n\nTheoritically, the security framework/model is an implementation details\nthat should not impact the layers above the application framework\n.\n\n\nThe security framework of Tizen provides \"nice lad\" a valuable component to\nscan log files and analyse auditing. This component is still in developement.\n\n\nThe application framework\n\n\nThe application framework on top of the security framework\nprovides the components to install and uninstall applications\nand to run it in a secured environment.\n\n\nThe goal is to manage applications and to hide the details of\nthe security framework to the applications.\n\n\nFor the reasons explained in introduction, we did not used the\napplication framework of Tizen as is but used an adaptation of it.\n\n\nThe basis is kept identical: the applications are distributed\nin a digitally signed container that must match the specifications\nof widgets (web applications). This is described by the technical\nrecomendations \nwidgets\n and \nwidgets-digsig\n of the W3 consortium.\n\n\nThis model allows the distribution of HTML, QML and binary applications.\n\n\nThe management of signatures of the widget packages \nThis basis is not meant as being rigid and it can be extended in the\nfutur to include for example incremental delivery.", 
            "title": "Overview"
        }, 
        {
            "location": "/developer/app-framework/main/overview/#agl-framework-overview-of-the-proposal-of-iotbzh", 
            "text": "", 
            "title": "AGL framework, overview of the proposal of IoT.bzh"
        }, 
        {
            "location": "/developer/app-framework/main/overview/#foreword", 
            "text": "This document describes what we intend to do. It may happen that our\ncurrent implementation and the content of this document differ.  In case of differences, it is assumed that this document is right\nand the implementation is wrong.", 
            "title": "Foreword"
        }, 
        {
            "location": "/developer/app-framework/main/overview/#introduction", 
            "text": "During the first works in having the security model of Tizen\nintegrated in AGL (Automotive Grade Linux) distribution, it became\nquickly obvious that the count of components specific to Tizen\nto integrate was huge.  Here is a minimal list of what was needed:   platform/appfw/app-installers  platform/core/security/cert-svc  platform/core/appfw/ail  platform/core/appfw/aul-1  platform/core/appfw/libslp-db-util  platform/core/appfw/pkgmgr-info  platform/core/appfw/slp-pkgmgr   But this list is complete because many dependencies are hidden.\nThose hidden dependencies are including some common libraries but also many\ntizen specific sub-components (iniparser, bundle, dlog, libtzplatform-config,\ndb-util, vconf-buxton, ...).  This is an issue because AGL is not expected to be Tizen. Taking it would\neither need to patch it for removing unwanted components or to take all\nof them.  However, a careful study of the core components of the security framework\nof Tizen showed that their dependencies to Tizen are light (and since some\nof our work, there is no more dependency to tizen).\nThose components are  cynara ,  security-manager ,  D-Bus aware of cynara .  Luckyly, these core security components of Tizen are provided\nby  meta-intel-iot-security , a set of yocto layers.\nThese layers were created by Intel to isolate Tizen specific security\ncomponents from the initial port of Tizen to Yocto.\nThe 3 layers are providing components for:   Implementing Smack LSM  Implementing Integrity Measurement Architecture  Implementing Tizen Security Framework   The figure below shows the history of these layers.                    2014         2015\nTizen OBS ----------+--------------------------- \n                     \\\n                      \\\n     Tizen Yocto       +---------+-------------- \n                                  \\\n                                   \\\n       meta-intel-iot-security      +-----------   We took the decision to use these security layers that provides the\nbasis of the Tizen security, the security framework.  For the components of the application framework, built top of\nthe security framework, instead of pulling the huge set of packages\nfrom Tizen, we decided to refit it by developping a tiny set of\ncomponents that would implement the same behaviour but without all\nthe dependencies and with minor architectural improvements for AGL.  These components are  afm-system-daemon  and  afm-user-daemon .\nThey provides infrastructure for installing, uninstalling,\nlaunching, terminating, stopping and resuming applications in\na multi user secure environment.  A third component exists in the framework, the binder  afb-daemon .\nThe binder provides the easiest way to provide secured API for\nany tier. Currently, the use of the binder is not absolutely mandatory.  This documentation explains the framework created by IoT.bzh\nby rewriting the Tizen Application Framework. Be aware of the\nprevious foreword.", 
            "title": "Introduction"
        }, 
        {
            "location": "/developer/app-framework/main/overview/#overview", 
            "text": "The figure below shows the major components of the framework\nand their interactions going through the following scenario:\nAPPLICATION installs an other application and then launch it.  +-----------------------------------------------------------------------+\n|                                 User                                  |\n|  ................................                                     |\n|  :   Smack isolation context    :                                     |\n|  :                              :      ...........................    |\n|  :  +-----------------------+   :      : Smack isolation context :    |\n|  :  |                       |   :      :                         :    |\n|  :  |      APPLICATION      |   :      :     OTHER application   :    |\n|  :  |                       |   :      :.........................:    |\n|  :  +-----------+-----------+   :                ^                    |\n|  :              |               :                |                    |\n|  :              |(1),(7)        :                |(13)                |\n|  :              |               :                |                    |\n|  :  +-----------v-----------+   :      +---------+---------------+    |\n|  :  |   binder afb-daemon   |   :      |                         |    |\n|  :  +-----------------------+   :      |      afm-user-daemon    |    |\n|  :  |    afm-main-binding   |   :      |                         |    |\n|  :  +-----+--------------+--+   :      +------^-------+------+---+    |\n|  :........|..............|......:             |       |      :        |\n|           |(2)           |(8)                 |(10)   |      :        |\n|           |              |                    |       |      :        |\n|           |         +----v--------------------+---+   |      :        |\n|           |         |        D-Bus   session      |   |(11)  :(12)    |\n|           |         +-------------------------+---+   |      :        |\n|           |                                   |       |      :        |\n|           |                                   |(9)    |      :        |\n|           |                                   |       |      :        |\n:===========|===================================|=======|======:========:\n|           |                                   |       |      :        |\n|           |                               +---v-------v--+   :        |\n|    +------v-------------+     (3)         |              |   :        |\n|    |  D-Bus   system    +-----------------     CYNARA    |   :        |\n|    +------+-------------+                 |              |   :        |\n|           |                               +------^-------+   :        |\n|           |(4)                                   |           :        |\n|           |                                      |(6)        v        |\n|    +------v--------------+             +---------+---------------+    |\n|    |                     |    (5)      |                         |    |\n|    |  afm-system-daemon  +-------------      SECURITY-MANAGER    |    |\n|    |                     |             |                         |    |\n|    +---------------------+             +-------------------------+    |\n|                                                                       |\n|                              System                                   |\n+-----------------------------------------------------------------------+  Let follow the sequence of calls:    APPLICATION calls its  binder  to install the OTHER application.    The binding  afm-main-binding  of the  binder  calls, through\n    D-Bus  system, the system daemon to install the OTHER application.    The system  D-Bus  checks wether APPLICATION has the permission\n   or not to install applications by calling  CYNARA .    The system  D-Bus  transmits the request to  afm-system-daemon .    afm-system-daemon  checks the application to install, its\n   signatures and rights and install it.    afm-system-daemon  calls  SECURITY-MANAGER  for fullfilling\n   security context of the installed application.    SECURITY-MANAGER  calls  CYNARA  to install initial permissions\n   for the application.    APPLICATION call its binder to start the nearly installed OTHER application.    The binding  afm-main-binding  of the  binder  calls, through\n    D-Bus  session, the user daemon to launch the OTHER application.    The session  D-Bus  checks wether APPLICATION has the permission\n   or not to start an application by calling  CYNARA .    The session  D-Bus  transmits the request to  afm-user-daemon .    afm-user-daemon  checks wether APPLICATION has the permission\n    or not to start the OTHER application  CYNARA .    afm-user-daemon  uses  SECURITY-MANAGER  features to set\n    the seciruty context for the OTHER application.    afm-user-daemon  launches the OTHER application.    This scenario does not cover all the features of the frameworks.\nShortly because details will be revealed in the next chapters,\nthe components are:    SECURITY-MANAGER : in charge of setting Smack contexts and rules,\n  of setting groups, and, of creating initial content of  CYNARA  rules\n  for applications.    CYNARA : in charge of handling API access permissions by users and by\n  applications.    D-Bus : in charge of checking security of messaging. The usual D-Bus\n  security rules are enhanced by  CYNARA  checking rules.    afm-system-daemon : in charge of installing and uninstalling applications.    afm-user-daemon : in charge of listing applications, querying application details,\n  starting, terminating, stopping, resuming applications and their instances\n  for a given user context.    afb-binder : in charge of serving resources and features through an\n  HTTP interface.    afm-main-binding : This binding allows applications to use the API\n  of the AGL framework.", 
            "title": "Overview"
        }, 
        {
            "location": "/developer/app-framework/main/overview/#links-between-the-security-framework-and-the-application-framework", 
            "text": "The security framework refers to the security model used to ensure\nsecurity and to the tools that are provided for implementing that model.  The security model refers to how DAC (Discretionnary Access Control),\nMAC (Mandatory Access Control) and Capabilities are used by the system\nto ensure security and privacy. It also includes features of reporting\nusing audit features and by managing logs and alerts.  The application framework manages the applications:\ninstalling, uninstalling, starting, stopping, listing ...  The application framework uses the security model/framework\nto ensure the security and the privacy of the applications that\nit manages.  The application framework must be compliant with the underlyiong\nsecurity model/framework. But it should hide it to the applications.", 
            "title": "Links between the \"Security framework\" and the \"Application framework\""
        }, 
        {
            "location": "/developer/app-framework/main/overview/#the-security-framework", 
            "text": "The implemented security model is the security model of Tizen 3.\nThis model is described  here .  The security framework then comes from Tizen 3 but through\nthe  meta-intel .\nIt includes:  Security-Manager ,  Cynara \nand  D-Bus  compliant to Cynara.  Two patches are applied to the security-manager. These patches are removing\ndependencies to packages specific of Tizen but that are not needed by AGL.\nNone of these patches adds or removes any behaviour.  Theoritically, the security framework/model is an implementation details\nthat should not impact the layers above the application framework .  The security framework of Tizen provides \"nice lad\" a valuable component to\nscan log files and analyse auditing. This component is still in developement.", 
            "title": "The security framework"
        }, 
        {
            "location": "/developer/app-framework/main/overview/#the-application-framework", 
            "text": "The application framework on top of the security framework\nprovides the components to install and uninstall applications\nand to run it in a secured environment.  The goal is to manage applications and to hide the details of\nthe security framework to the applications.  For the reasons explained in introduction, we did not used the\napplication framework of Tizen as is but used an adaptation of it.  The basis is kept identical: the applications are distributed\nin a digitally signed container that must match the specifications\nof widgets (web applications). This is described by the technical\nrecomendations  widgets  and  widgets-digsig  of the W3 consortium.  This model allows the distribution of HTML, QML and binary applications.  The management of signatures of the widget packages \nThis basis is not meant as being rigid and it can be extended in the\nfutur to include for example incremental delivery.", 
            "title": "The application framework"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/", 
            "text": "AGL Application Framework: A Quick Tutorial\n\n\nIntroduction\n\n\nThis document proposes a quick tutorial to demonstrate the major functionnalities of the AGL Application Framework. For more complete information, please refer to the inline documentation available in the main git repository: \nhttps://gerrit.automotivelinux.org/gerrit/#/admin/projects/src/app-framework-main\nhttps://gerrit.automotivelinux.org/gerrit/#/admin/projects/src/app-framework-binder\n\n\nFor more information on AGL, please visit:\nhttps://www.automotivelinux.org/\n\n\n\n\nSample applications\n\n\n4 sample applications (.wgt files) are prebuilt and available at the following address:\nhttps://github.com/iotbzh/afm-widget-examples\n\n\nYou can get them by cloning this git repository on your desktop (will be useful later in this tutorial):\n\n\n$ git clone https://github.com/iotbzh/afm-widget-examples\n\n\n\n\nUsing the CLI tool\n\n\nSetup Environment\n\n\nConnect your AGL target board to the network and copy some sample widgets on it through SSH (set BOARDIP with your board IP address) :\n\n\n$ cd afm-widget-examples\n$ BOARDIP=1.2.3.4\n$ scp *.wgt root@$BOARDIP:~/\n\n\n\n\nConnect through SSH on the target board and check for Application Framework daemons:\n\n\n$ ssh root@$BOARDIP\nroot@porter:~# ps -ef|grep bin/afm\nafm        409     1  0 13:00 ?        00:00:00 /usr/bin/afm-system-daemon\nroot       505   499  0 13:01 ?        00:00:00 /usr/bin/afm-user-daemon\nroot       596   550  0 13:22 pts/0    00:00:00 grep afm\n\n\n\nWe can see that there are two daemons running:\n\n \nafm-system-daemon\n runs with a system user 'afm' and is responsible for installing/uninstalling packages\n\n \nafm-user-daemon\n runs as a user daemon (currently as root because it's the only real user on the target board) and is responsible for the whole lifecycle of the applications running inside the user session.\n\n\nThe application framework has a tool running on the Command Line Interface (CLI). Using the \nafm-util\n command, you can install, uninstall, list, run, stop ... applications. \n\n\nTo begin, run '\nafm-util help\n' to get a quick help on commands:\n\n\nroot@porter:~# afm-util help\nusage: afm-util command [arg]\n\nThe commands are:\n\n  list\n  runnables      list the runnable widgets installed\n\n  add wgt\n  install wgt    install the wgt file\n\n  remove id\n  uninstall id   remove the installed widget of id\n\n  info id\n  detail id      print detail about the installed widget of id\n\n  ps\n  runners        list the running instance\n\n  run id\n  start id       start an instance of the widget of id\n\n  kill rid\n  terminate rid       terminate the running instance rid\n\n  stop rid\n  pause rid      stop the running instance rid\n\n  resume rid\n  continue rid   continue the previously rid\n\n  status rid\n  state rid     get status of the running instance rid\n\n\n\nInstall an application\n\n\nYou can then install your first application:\n\n\nroot@porter:~# afm-util install /home/root/annex.wgt \n{ \"added\": \"webapps-annex@0.0\" }\n\n\n\nLet's install a second application:\n\n\nroot@porter:~# afm-util install /home/root/memory-match.wgt \n{ \"added\": \"webapps-memory-match@1.1\" }\n\n\n\nNote that usually, \nafm-util\n will return a \nJSON result\n, which is the common format for messages returned by the Application Framework daemons.\n\n\nList installed applications\n\n\nYou can then list all installed applications:\n\n\nroot@porter:~# afm-util list\n[ { \"id\": \"webapps-annex@0.0\", \"version\": \"0.0.10\", \"width\": 0, \"height\": 0, \"name\": \"Annex\", \"description\": \"Reversi\\/Othello\", \"shortname\": \"\", \"author\": \"Todd Brandt \ntodd.e.brandt@intel.com\n\" },\n { \"id\": \"webapps-memory-match@1.1\", \"version\": \"1.1.7\", \"width\": 0, \"height\": 0, \"name\": \"MemoryMatch\", \"description\": \"Memory match\", \"shortname\": \"\", \"author\": \"Todd Brandt \ntodd.e.brandt@intel.com\n\" } ]\n\n\n\nHere, we can see the two previously installed applications.\n\n\nGet information about an application\n\n\nLet's get some details about the first application:\n\n\nroot@porter:~# afm-util info webapps-annex@0.0\n{ \"id\": \"webapps-annex@0.0\", \"version\": \"0.0.10\", \"width\": 0, \"height\": 0, \"name\": \"Annex\", \"description\": \"Reversi\\/Othello\", \"shortname\": \"\", \"author\": \"Todd Brandt \ntodd.e.brandt@intel.com\n\" }\n\n\n\nNote that AGL applications are mostly handled by afm-util through their IDs. In our example, the application ID is 'webapps-annex@0.0'.\n\n\nStart application\n\n\nLet's start the first application Annex:\n\n\nroot@porter:~# afm-util start webapps-annex@0.0\n1\n\n\n\nAs the application is a HTML5 game, you should then get a webview running with QML on the board display.\n\n\nSecurity Context\n\n\nThe application has been started in the user session, with a dedicated security context, enforced by SMACK. To illustrate this, we can take a look at the running processes and their respective SMACK labels:\n\n\nroot@porter:~# ps -efZ |grep webapps-annex | grep -v grep\nUser::App::webapps-annex        root       716   491  0 13:19 ?        00:00:00 /usr/bin/afb-daemon --mode=local --readyfd=8 --alias=/icons /usr/share/afm/icons --port=12348 --rootdir=/usr/share/afm/applications/webapps-annex/0.0 --token=7D6D2F16 --sessiondir=/home/root/app-data/webapps-annex/.afb-daemon\nUser::App::webapps-annex        root       717   491  0 13:19 ?        00:00:00 /usr/bin/qt5/qmlscene http://localhost:12348/index.html?token=7D6D2F16 /usr/bin/web-runtime-webkit.qml\n\n\n\nIn the previous result, we see that the application is composed of two processes:\n\n the application binder (afb-daemon)\n\n the application UI (qmlscene ...)\n\n\nWhile most system processes run with the label 'System', we see that the application runs with a specific SMACK label 'User::App::webapps-annex': this label is used to force the application to follow a Mandatory Access Control (MAC) scheme. This means that those processes run in their own security context, isolated from the rest of the system (and other applications). Global security rules can then be applied to restrict access to all other user or system resources.\n\n\nCheck running applications\n\n\nTo check for running applications, just run:\n\n\nroot@porter:~# afm-util ps\n[ { \"runid\": 1, \"state\": \"running\", \"id\": \"webapps-annex@0.0\" } ]\n\n\n\nThe 'runid' is the application instance ID and is used as an argument for the subcommands controlling the application runtime state (kill/stop/resume/status)\n\n\nStop application\n\n\nTo stop the application that was just started (the one with RUNID 1), just run the stop command:\n\n\nroot@porter:~# afm-util terminate 1\ntrue\n\n\n\nThe application is now stopped, as confirmed by a list of running apps:\n\n\nroot@porter:~# afm-util ps\n[ ]\n\n\n\nUninstall application\n\n\nTo uninstall an application, simply use its ID:\n\n\nroot@porter:~# afm-util uninstall webapps-annex@0.0\ntrue\n\n\n\nThen list the installed apps to confirm the removal:\n\n\nroot@porter:~# afm-util list\n[ { \"id\": \"webapps-memory-match@1.1\", \"version\": \"1.1.7\", \"width\": 0, \"height\": 0, \"name\": \"MemoryMatch\", \"description\": \"Memory match\", \"shortname\": \"\", \"author\": \"Todd Brandt \ntodd.e.brandt@intel.com\n\" } ]\n\n\n\nafm-client: a sample HTML5 'Homescreen'\n\n\nafm-client\n is a HTML5 UI that allows to install/uninstall applications as well as starting/stopping them as already demonstrated with afm-util.\n\n\nThe HTML5 UI is accessible remotely through this URL: \nhttp://[board_ip]:1234/opa?token=132456789\n\n\nInstalling an application\n\n\nBy clicking on the '\nUpload\n' button on the right, you can send an application package (WGT file) and install it. Select for example the file '\nrabbit.wgt\n' that was cloned initially from the git repository afm-widget-examples.\n\n\nThen a popup requester ask for a confirmation: 'Upload Application rabbit.wgt ?'. Click on the '\nInstall\n' button.\n\n\nYou should then see some changes in the toolbar: a new icon appeared, representing the freshly installed application.\n\n\nRunning an application\n\n\nIn the toolbar, click on the button representing the Rabbit application. You'll get a popup asking to:\n\n start the application\n\n or get some info about it\n* or uninstall it\n\n\nClick on the 'start' item: the application starts and should be visible as a webview on the target board display. Note that at this point, we could also run the application remotely, that is in the same browser as the Homescreen app. By default, the application framework is configured to run applications 'locally' on the board display.\n\n\nStopping an application\n\n\nIn the Homescreen application, click again on the Rabbit application button, then select 'stop': the application then stops.\n\n\nUninstalling an application\n\n\nFrom the same popup menu, you can select 'uninstall' to remove the application from the system. As a consequence, the application icon should disappear from the toolbar.\n\n\nafb-client: a template for Angular Applications\n\n\nAnother package '\nafb-client\n' is also available for testing.\nThis is a sample HTML5 application demonstrating various basic capabilities of the Binder daemon. It can be used by developers as a template to start writing real AGL Applications.\n\n\nThis application is not available as WGT file yet and it should be started manually without any specific security context:\n\n\nroot@porter:~# /usr/bin/afb-daemon --mode=remote --port=1235 --token='' --sessiondir=/home/root/.afm-daemon --rootdir=/usr/share/agl/afb-client --alias=/icons:/usr/share/afm/icons\n\n\n\nThen you can access it from a browser:\nhttp://[board_ip]:1235/opa/?token=132456789\n\n\nafb-client is a simple application to demonstrate the built-in capabilities of the binder daemon (handling sessions and security tokens, testing POSTs uploads...) and was used during the application framework development to validate the proposed features.", 
            "title": "Quick tutorial"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#agl-application-framework-a-quick-tutorial", 
            "text": "", 
            "title": "AGL Application Framework: A Quick Tutorial"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#introduction", 
            "text": "This document proposes a quick tutorial to demonstrate the major functionnalities of the AGL Application Framework. For more complete information, please refer to the inline documentation available in the main git repository: \nhttps://gerrit.automotivelinux.org/gerrit/#/admin/projects/src/app-framework-main\nhttps://gerrit.automotivelinux.org/gerrit/#/admin/projects/src/app-framework-binder  For more information on AGL, please visit:\nhttps://www.automotivelinux.org/", 
            "title": "Introduction"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#sample-applications", 
            "text": "4 sample applications (.wgt files) are prebuilt and available at the following address:\nhttps://github.com/iotbzh/afm-widget-examples  You can get them by cloning this git repository on your desktop (will be useful later in this tutorial):  $ git clone https://github.com/iotbzh/afm-widget-examples", 
            "title": "Sample applications"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#using-the-cli-tool", 
            "text": "", 
            "title": "Using the CLI tool"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#setup-environment", 
            "text": "Connect your AGL target board to the network and copy some sample widgets on it through SSH (set BOARDIP with your board IP address) :  $ cd afm-widget-examples\n$ BOARDIP=1.2.3.4\n$ scp *.wgt root@$BOARDIP:~/  Connect through SSH on the target board and check for Application Framework daemons:  $ ssh root@$BOARDIP\nroot@porter:~# ps -ef|grep bin/afm\nafm        409     1  0 13:00 ?        00:00:00 /usr/bin/afm-system-daemon\nroot       505   499  0 13:01 ?        00:00:00 /usr/bin/afm-user-daemon\nroot       596   550  0 13:22 pts/0    00:00:00 grep afm  We can see that there are two daemons running:   afm-system-daemon  runs with a system user 'afm' and is responsible for installing/uninstalling packages   afm-user-daemon  runs as a user daemon (currently as root because it's the only real user on the target board) and is responsible for the whole lifecycle of the applications running inside the user session.  The application framework has a tool running on the Command Line Interface (CLI). Using the  afm-util  command, you can install, uninstall, list, run, stop ... applications.   To begin, run ' afm-util help ' to get a quick help on commands:  root@porter:~# afm-util help\nusage: afm-util command [arg]\n\nThe commands are:\n\n  list\n  runnables      list the runnable widgets installed\n\n  add wgt\n  install wgt    install the wgt file\n\n  remove id\n  uninstall id   remove the installed widget of id\n\n  info id\n  detail id      print detail about the installed widget of id\n\n  ps\n  runners        list the running instance\n\n  run id\n  start id       start an instance of the widget of id\n\n  kill rid\n  terminate rid       terminate the running instance rid\n\n  stop rid\n  pause rid      stop the running instance rid\n\n  resume rid\n  continue rid   continue the previously rid\n\n  status rid\n  state rid     get status of the running instance rid", 
            "title": "Setup Environment"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#install-an-application", 
            "text": "You can then install your first application:  root@porter:~# afm-util install /home/root/annex.wgt \n{ \"added\": \"webapps-annex@0.0\" }  Let's install a second application:  root@porter:~# afm-util install /home/root/memory-match.wgt \n{ \"added\": \"webapps-memory-match@1.1\" }  Note that usually,  afm-util  will return a  JSON result , which is the common format for messages returned by the Application Framework daemons.", 
            "title": "Install an application"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#list-installed-applications", 
            "text": "You can then list all installed applications:  root@porter:~# afm-util list\n[ { \"id\": \"webapps-annex@0.0\", \"version\": \"0.0.10\", \"width\": 0, \"height\": 0, \"name\": \"Annex\", \"description\": \"Reversi\\/Othello\", \"shortname\": \"\", \"author\": \"Todd Brandt  todd.e.brandt@intel.com \" },\n { \"id\": \"webapps-memory-match@1.1\", \"version\": \"1.1.7\", \"width\": 0, \"height\": 0, \"name\": \"MemoryMatch\", \"description\": \"Memory match\", \"shortname\": \"\", \"author\": \"Todd Brandt  todd.e.brandt@intel.com \" } ]  Here, we can see the two previously installed applications.", 
            "title": "List installed applications"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#get-information-about-an-application", 
            "text": "Let's get some details about the first application:  root@porter:~# afm-util info webapps-annex@0.0\n{ \"id\": \"webapps-annex@0.0\", \"version\": \"0.0.10\", \"width\": 0, \"height\": 0, \"name\": \"Annex\", \"description\": \"Reversi\\/Othello\", \"shortname\": \"\", \"author\": \"Todd Brandt  todd.e.brandt@intel.com \" }  Note that AGL applications are mostly handled by afm-util through their IDs. In our example, the application ID is 'webapps-annex@0.0'.", 
            "title": "Get information about an application"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#start-application", 
            "text": "Let's start the first application Annex:  root@porter:~# afm-util start webapps-annex@0.0\n1  As the application is a HTML5 game, you should then get a webview running with QML on the board display.", 
            "title": "Start application"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#security-context", 
            "text": "The application has been started in the user session, with a dedicated security context, enforced by SMACK. To illustrate this, we can take a look at the running processes and their respective SMACK labels:  root@porter:~# ps -efZ |grep webapps-annex | grep -v grep\nUser::App::webapps-annex        root       716   491  0 13:19 ?        00:00:00 /usr/bin/afb-daemon --mode=local --readyfd=8 --alias=/icons /usr/share/afm/icons --port=12348 --rootdir=/usr/share/afm/applications/webapps-annex/0.0 --token=7D6D2F16 --sessiondir=/home/root/app-data/webapps-annex/.afb-daemon\nUser::App::webapps-annex        root       717   491  0 13:19 ?        00:00:00 /usr/bin/qt5/qmlscene http://localhost:12348/index.html?token=7D6D2F16 /usr/bin/web-runtime-webkit.qml  In the previous result, we see that the application is composed of two processes:  the application binder (afb-daemon)  the application UI (qmlscene ...)  While most system processes run with the label 'System', we see that the application runs with a specific SMACK label 'User::App::webapps-annex': this label is used to force the application to follow a Mandatory Access Control (MAC) scheme. This means that those processes run in their own security context, isolated from the rest of the system (and other applications). Global security rules can then be applied to restrict access to all other user or system resources.", 
            "title": "Security Context"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#check-running-applications", 
            "text": "To check for running applications, just run:  root@porter:~# afm-util ps\n[ { \"runid\": 1, \"state\": \"running\", \"id\": \"webapps-annex@0.0\" } ]  The 'runid' is the application instance ID and is used as an argument for the subcommands controlling the application runtime state (kill/stop/resume/status)", 
            "title": "Check running applications"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#stop-application", 
            "text": "To stop the application that was just started (the one with RUNID 1), just run the stop command:  root@porter:~# afm-util terminate 1\ntrue  The application is now stopped, as confirmed by a list of running apps:  root@porter:~# afm-util ps\n[ ]", 
            "title": "Stop application"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#uninstall-application", 
            "text": "To uninstall an application, simply use its ID:  root@porter:~# afm-util uninstall webapps-annex@0.0\ntrue  Then list the installed apps to confirm the removal:  root@porter:~# afm-util list\n[ { \"id\": \"webapps-memory-match@1.1\", \"version\": \"1.1.7\", \"width\": 0, \"height\": 0, \"name\": \"MemoryMatch\", \"description\": \"Memory match\", \"shortname\": \"\", \"author\": \"Todd Brandt  todd.e.brandt@intel.com \" } ]", 
            "title": "Uninstall application"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#afm-client-a-sample-html5-homescreen", 
            "text": "afm-client  is a HTML5 UI that allows to install/uninstall applications as well as starting/stopping them as already demonstrated with afm-util.  The HTML5 UI is accessible remotely through this URL: \nhttp://[board_ip]:1234/opa?token=132456789", 
            "title": "afm-client: a sample HTML5 'Homescreen'"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#installing-an-application", 
            "text": "By clicking on the ' Upload ' button on the right, you can send an application package (WGT file) and install it. Select for example the file ' rabbit.wgt ' that was cloned initially from the git repository afm-widget-examples.  Then a popup requester ask for a confirmation: 'Upload Application rabbit.wgt ?'. Click on the ' Install ' button.  You should then see some changes in the toolbar: a new icon appeared, representing the freshly installed application.", 
            "title": "Installing an application"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#running-an-application", 
            "text": "In the toolbar, click on the button representing the Rabbit application. You'll get a popup asking to:  start the application  or get some info about it\n* or uninstall it  Click on the 'start' item: the application starts and should be visible as a webview on the target board display. Note that at this point, we could also run the application remotely, that is in the same browser as the Homescreen app. By default, the application framework is configured to run applications 'locally' on the board display.", 
            "title": "Running an application"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#stopping-an-application", 
            "text": "In the Homescreen application, click again on the Rabbit application button, then select 'stop': the application then stops.", 
            "title": "Stopping an application"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#uninstalling-an-application", 
            "text": "From the same popup menu, you can select 'uninstall' to remove the application from the system. As a consequence, the application icon should disappear from the toolbar.", 
            "title": "Uninstalling an application"
        }, 
        {
            "location": "/developer/app-framework/main/quick-tutorial/#afb-client-a-template-for-angular-applications", 
            "text": "Another package ' afb-client ' is also available for testing.\nThis is a sample HTML5 application demonstrating various basic capabilities of the Binder daemon. It can be used by developers as a template to start writing real AGL Applications.  This application is not available as WGT file yet and it should be started manually without any specific security context:  root@porter:~# /usr/bin/afb-daemon --mode=remote --port=1235 --token='' --sessiondir=/home/root/.afm-daemon --rootdir=/usr/share/agl/afb-client --alias=/icons:/usr/share/afm/icons  Then you can access it from a browser:\nhttp://[board_ip]:1235/opa/?token=132456789  afb-client is a simple application to demonstrate the built-in capabilities of the binder daemon (handling sessions and security tokens, testing POSTs uploads...) and was used during the application framework development to validate the proposed features.", 
            "title": "afb-client: a template for Angular Applications"
        }, 
        {
            "location": "/developer/app-framework/main/security-framework/", 
            "text": "The security framework\n\n\nNOT STARTED !!!!!!\n\n\nSetting Smack rules for the application\n\n\nFor Tizen, the following rules are set by the security manager for each application.\n\n\nSystem ~APP~             rwx\nSystem ~PKG~             rwxat\nSystem ~PKG~::RO         rwxat\n~APP~  System            wx\n~APP~  System::Shared    rxl\n~APP~  System::Run       rwxat\n~APP~  System::Log       rwxa\n~APP~  _                 l\nUser   ~APP~             rwx\nUser   ~PKG~             rwxat\nUser   ~PKG~::RO         rwxat\n~APP~  User              wx\n~APP~  User::Home        rxl\n~APP~  User::App::Shared rwxat\n~APP~  ~PKG~             rwxat\n~APP~  ~PKG~::RO         rxl\n\n\n\nHere, ~PKG~ is the identifier of the package and ~APP~ is the identifier of the application.\n\n\nWhat user can run an application?\n\n\nNot all user are able to run all applications.\nHow to manage that?", 
            "title": "Security framework"
        }, 
        {
            "location": "/developer/app-framework/main/security-framework/#the-security-framework", 
            "text": "NOT STARTED !!!!!!", 
            "title": "The security framework"
        }, 
        {
            "location": "/developer/app-framework/main/security-framework/#setting-smack-rules-for-the-application", 
            "text": "For Tizen, the following rules are set by the security manager for each application.  System ~APP~             rwx\nSystem ~PKG~             rwxat\nSystem ~PKG~::RO         rwxat\n~APP~  System            wx\n~APP~  System::Shared    rxl\n~APP~  System::Run       rwxat\n~APP~  System::Log       rwxa\n~APP~  _                 l\nUser   ~APP~             rwx\nUser   ~PKG~             rwxat\nUser   ~PKG~::RO         rwxat\n~APP~  User              wx\n~APP~  User::Home        rxl\n~APP~  User::App::Shared rwxat\n~APP~  ~PKG~             rwxat\n~APP~  ~PKG~::RO         rxl  Here, ~PKG~ is the identifier of the package and ~APP~ is the identifier of the application.", 
            "title": "Setting Smack rules for the application"
        }, 
        {
            "location": "/developer/app-framework/main/security-framework/#what-user-can-run-an-application", 
            "text": "Not all user are able to run all applications.\nHow to manage that?", 
            "title": "What user can run an application?"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/", 
            "text": "The widgets\n\n\nThe widgets\n\n\nThe widgets are described by the technical recommendations\n\nwidgets\n and \nwidgets-digsig\n.\n\n\nIn summary, \nwidgets are ZIP files that can be signed and\nwhose content is described by the file \n.\n\n\nThe configuration file config.xml\n\n\nThis is one of the important file of the widget.\nIt fully describes the widget.\n\n\nHere is the example of the config file for the QML application SmartHome.\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nwidget xmlns=\nhttp://www.w3.org/ns/widgets\n id=\nsmarthome\n version=\n0.1\n\n  \nname\nSmartHome\n/name\n\n  \nicon src=\nsmarthome.png\n/\n\n  \ncontent src=\nqml/smarthome/smarthome.qml\n type=\ntext/vnd.qt.qml\n/\n\n  \ndescription\nThis is the Smarthome QML demo application. It shows some user interfaces for controlling an \nautomated house. The user interface is completely done with QML.\n/description\n\n  \nauthor\nQt team\n/author\n\n  \nlicense\nGPL\n/license\n\n\n/widget\n\n\n\n\n\nThe most important items are:\n\n\n\n\n\n\n\\\nwidget id=\"......\">\n: gives the id of the widget. It must be unique.\n\n\n\n\n\n\n\\\nwidget version=\"......\">\n: gives the version of the widget\n\n\n\n\n\n\n\\\nicon src=\"...\">\n: gives a path to the icon of the application\n  (can be repeated with different sizes)\n\n\n\n\n\n\n\\\ncontent src=\"...\" type=\"...\">\n: this indicates the entry point and its type.\n  The types handled are set through the file /etc/afm/afm-launch.conf\n\n\n\n\n\n\nFurther development will add handling of \n for requiring and providing\npermissions and services.\n\n\nTools for managing widgets\n\n\nThis project includes tools for managing widgets.\nThese tools are:\n\n\n\n\n\n\nwgtpkg-info\n: command line tool to display\n  informations about a widget file.\n\n\n\n\n\n\nwgtpkg-installer\n: command line tool to\n  install a widget file.\n\n\n\n\n\n\nwgtpkg-pack\n: command line tool to create\n  a widget file from a widget directory.\n\n\n\n\n\n\nwgtpkg-sign\n: command line tool to add a signature\n  to a widget directory.\n\n\n\n\n\n\nFor all these commands, a tiny help is available with\noptions \n-h\n or \n--help\n.\n\n\nThere is no tool for unpacking a widget. For doing such operation,\nyou can use the command \nunzip\n.\n\n\nTo list the files of a widget:\n\n\n$ unzip -l WIDGET\n\n\n\n\nTo extract a widget in some directory:\n\n\n$ unzip WIDGET -d DIRECTORY\n\n\n\n\nNote that DIRECTORY will be created if needed\n.\n\n\nSigning a widget\n\n\nTo sign a widget, you need a private key and its certificate.\n\n\nThe tool \nwgtpkg-sign\n creates or replace a signature file in\nthe directory of the widget BEFORE its packaging.\n\n\nThere are two types of signature files: author and distributor.\n\n\nExample 1: add an author signature\n\n\n$ wgtpkg-sign -a -k me.key.pem -c me.cert.pem DIRECTORY\n\n\n\n\nExample 2: add a distributor signature\n\n\n$ wgtpkg-sign -k authority.key.pem -c authority.cert.pem DIRECTORY\n\n\n\n\nPacking a widget\n\n\nThis operation can be done using the command \nzip\n but\nwe provide the tool \nwgtpkg-pack\n that may add checking.\n\n\nExample:\n\n\n$ wgtpkg-pack DIRECTORY -o file.wgt\n\n\n\n\nGetting data about a widget file\n\n\nThe command \nwgtpkg-info\n opens a widget file, reads its \nconfig.xml\n\nfile and displays its content in a human readable way.\n\n\nWriting a widget\n\n\nWhat kind of application?\n\n\nThe file \n/etc/afm/afm-launch.conf\n explain how to launch applications.\n(It is the current state that use afm-user-daemon. In a future, it may be\nreplace by systemd features.)\n\n\nCurrently the applications that can be run are:\n\n\n\n\n\n\nbinary applications: their type is \napplication/x-executable\n\n\n\n\n\n\nHTML5 applications: their type is \ntext/html\n\n\n\n\n\n\nQML applications: their type is \ntext/vnd.qt.qml\n\n\n\n\n\n\nThe steps for writing a widget\n\n\n\n\n\n\nmake your application\n\n\n\n\n\n\ncreate its configuration file \nconfig.xml\n\n\n\n\n\n\nsign it\n\n\n\n\n\n\npack it\n\n\n\n\n\n\nFairly easy, no?\n\n\nOrganization of directory of applications\n\n\ndirectory where are stored applications\n\n\nApplications can be installed in different places: the system itself, extension device.\nOn a phone application are typically installed on the sd card.\n\n\nThis translates to:\n\n\n\n\n/usr/applications: system wide applications\n\n\n/opt/applications: removable applications\n\n\n\n\nFrom here those paths are referenced as: \"APPDIR\".\n\n\nThe main path for applications is: APPDIR/PKGID/VER.\n\n\nWhere:\n\n\n\n\nAPPDIR is as defined above\n\n\nPKGID is a directory whose name is the package identifier\n\n\nVER is the version of the package MAJOR.MINOR\n\n\n\n\nThis organization has the advantage to allow several versions to leave together.\nThis is needed for some good reasons (rolling back) and also for less good reasons (user habits).\n\n\nIdentity of installed files\n\n\nAll files are installed as user \"afm\" and group \"afm\".\nAll files have rw(x) for user and r-(x) for group and others.\n\n\nThis allows every user to read every file.\n\n\nlabeling the directories of applications\n\n\nThe data of a user are in its directory and are labelled by the security-manager\nusing the labels of the application.", 
            "title": "Widgets"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#the-widgets", 
            "text": "", 
            "title": "The widgets"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#the-widgets_1", 
            "text": "The widgets are described by the technical recommendations widgets  and  widgets-digsig .  In summary,  widgets are ZIP files that can be signed and\nwhose content is described by the file  .", 
            "title": "The widgets"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#the-configuration-file-configxml", 
            "text": "This is one of the important file of the widget.\nIt fully describes the widget.  Here is the example of the config file for the QML application SmartHome.  ?xml version= 1.0  encoding= UTF-8 ?  widget xmlns= http://www.w3.org/ns/widgets  id= smarthome  version= 0.1 \n   name SmartHome /name \n   icon src= smarthome.png / \n   content src= qml/smarthome/smarthome.qml  type= text/vnd.qt.qml / \n   description This is the Smarthome QML demo application. It shows some user interfaces for controlling an \nautomated house. The user interface is completely done with QML. /description \n   author Qt team /author \n   license GPL /license  /widget   The most important items are:    \\ widget id=\"......\"> : gives the id of the widget. It must be unique.    \\ widget version=\"......\"> : gives the version of the widget    \\ icon src=\"...\"> : gives a path to the icon of the application\n  (can be repeated with different sizes)    \\ content src=\"...\" type=\"...\"> : this indicates the entry point and its type.\n  The types handled are set through the file /etc/afm/afm-launch.conf    Further development will add handling of   for requiring and providing\npermissions and services.", 
            "title": "The configuration file config.xml"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#tools-for-managing-widgets", 
            "text": "This project includes tools for managing widgets.\nThese tools are:    wgtpkg-info : command line tool to display\n  informations about a widget file.    wgtpkg-installer : command line tool to\n  install a widget file.    wgtpkg-pack : command line tool to create\n  a widget file from a widget directory.    wgtpkg-sign : command line tool to add a signature\n  to a widget directory.    For all these commands, a tiny help is available with\noptions  -h  or  --help .  There is no tool for unpacking a widget. For doing such operation,\nyou can use the command  unzip .  To list the files of a widget:  $ unzip -l WIDGET  To extract a widget in some directory:  $ unzip WIDGET -d DIRECTORY  Note that DIRECTORY will be created if needed .", 
            "title": "Tools for managing widgets"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#signing-a-widget", 
            "text": "To sign a widget, you need a private key and its certificate.  The tool  wgtpkg-sign  creates or replace a signature file in\nthe directory of the widget BEFORE its packaging.  There are two types of signature files: author and distributor.  Example 1: add an author signature  $ wgtpkg-sign -a -k me.key.pem -c me.cert.pem DIRECTORY  Example 2: add a distributor signature  $ wgtpkg-sign -k authority.key.pem -c authority.cert.pem DIRECTORY", 
            "title": "Signing a widget"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#packing-a-widget", 
            "text": "This operation can be done using the command  zip  but\nwe provide the tool  wgtpkg-pack  that may add checking.  Example:  $ wgtpkg-pack DIRECTORY -o file.wgt", 
            "title": "Packing a widget"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#getting-data-about-a-widget-file", 
            "text": "The command  wgtpkg-info  opens a widget file, reads its  config.xml \nfile and displays its content in a human readable way.", 
            "title": "Getting data about a widget file"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#writing-a-widget", 
            "text": "", 
            "title": "Writing a widget"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#what-kind-of-application", 
            "text": "The file  /etc/afm/afm-launch.conf  explain how to launch applications.\n(It is the current state that use afm-user-daemon. In a future, it may be\nreplace by systemd features.)  Currently the applications that can be run are:    binary applications: their type is  application/x-executable    HTML5 applications: their type is  text/html    QML applications: their type is  text/vnd.qt.qml", 
            "title": "What kind of application?"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#the-steps-for-writing-a-widget", 
            "text": "make your application    create its configuration file  config.xml    sign it    pack it    Fairly easy, no?", 
            "title": "The steps for writing a widget"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#organization-of-directory-of-applications", 
            "text": "", 
            "title": "Organization of directory of applications"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#directory-where-are-stored-applications", 
            "text": "Applications can be installed in different places: the system itself, extension device.\nOn a phone application are typically installed on the sd card.  This translates to:   /usr/applications: system wide applications  /opt/applications: removable applications   From here those paths are referenced as: \"APPDIR\".  The main path for applications is: APPDIR/PKGID/VER.  Where:   APPDIR is as defined above  PKGID is a directory whose name is the package identifier  VER is the version of the package MAJOR.MINOR   This organization has the advantage to allow several versions to leave together.\nThis is needed for some good reasons (rolling back) and also for less good reasons (user habits).", 
            "title": "directory where are stored applications"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#identity-of-installed-files", 
            "text": "All files are installed as user \"afm\" and group \"afm\".\nAll files have rw(x) for user and r-(x) for group and others.  This allows every user to read every file.", 
            "title": "Identity of installed files"
        }, 
        {
            "location": "/developer/app-framework/main/widgets/#labeling-the-directories-of-applications", 
            "text": "The data of a user are in its directory and are labelled by the security-manager\nusing the labels of the application.", 
            "title": "labeling the directories of applications"
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/", 
            "text": "Writing the configuration file \"config.xml\"\n\n\nAbout \"config.xml\"\n\n\nThe file \nconfig.xml\n describes important data of the application\nto the framework:\n\n\n\n\nthe unique identifier of the application\n\n\nthe name of the application\n\n\nthe type of the application\n\n\nthe icon of the application\n\n\nthe permissions linked to the application\n\n\nthe services and dependancies of the application\n\n\n\n\nThe file MUST be at the root of the widget and MUST be case sensitively name\n\nconfig.xml\n.\n\n\nThe file \nconfig.xml\n is a XML file described by the document\n\nwidgets\n.\n\n\nExample of \"config.xml\"\n\n\nHere is the example of the config file for the QML application SmartHome.\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nwidget xmlns=\nhttp://www.w3.org/ns/widgets\n id=\nsmarthome\n version=\n0.1\n\n  \nname\nSmartHome\n/name\n\n  \nicon src=\nsmarthome.png\n/\n\n  \ncontent src=\nqml/smarthome/smarthome.qml\n type=\ntext/vnd.qt.qml\n/\n\n  \ndescription\n\n    This is the Smarthome QML demo application.\n    It shows some user interfaces for controlling an automated house.\n    The user interface is completely done with QML.\n  \n/description\n\n  \nauthor\nQt team\n/author\n\n  \nlicense\nGPL\n/license\n\n\n/widget\n\n\n\n\n\nStandard elements of \"config.xml\"\n\n\nThe element widget\n\n\nthe attribute id of widget\n\n\nThe attribute \nid\n is mandatory (for version 2.x, blowfish) and must be unique.\n\n\nValues for \nid\n are any non empty string containing only latin letters,\narabic digits, and the three characters '.' (dot), '-' (dash) and\n'_' (underscore).\n\n\nAuthors can use a mnemonic id or can pick a unique id using\ncommand \nuuid\n or \nuuidgen\n.\n\n\nthe attribute version of widget\n\n\nThe attribute \nversion\n is mandatory (for version 2.x, blowfish).\n\n\nValues for \nid\n are any non empty string containing only latin letters,\narabic digits, and the three characters '.' (dot), '-' (dash) and\n'_' (underscore).\n\n\nVersion values are dot separated fields MAJOR.MINOR.REVISION.\n\n\nThe element content\n\n\nThe element \ncontent\n is mandatory (for version 2.x, blowfish) and must designate a file\n(subject to localisation) with its attribute \nsrc\n.\n\n\nThe content designed depends on its type. See below for the known types.\n\n\nThe element icon\n\n\nThe element \nicon\n is mandatory (for version 2.x, blowfish) and must\nbe unique. It must designate an image file with its attribute \nsrc\n.\n\n\nKnown widget types and content\n\n\nThe configuration file \n/etc/afm/afm-launch.conf\n defines the types\nof widget known and how to launch it.\n\n\nKnown types for the type of content are (for version 2.x, blowfish):\n\n\n\n\n\n\ntext/html\n: \n   HTML application,\n   content.src designates the home page of the application\n\n\n\n\n\n\napplication/x-executable\n:\n   Native application,\n   content.src designates the relative path of the binary\n\n\n\n\n\n\napplication/vnd.agl.url\n:\n   Internet url,\n   content.src designates the url to be used\n\n\n\n\n\n\napplication/vnd.agl.service\n:\n   AGL service defined as a binder,\n   content.src designates the directory of provided binders,\n   http content, if any, must be put in the subdirectory \nhtdocs\n of the widget\n\n\n\n\n\n\napplication/vnd.agl.native\n:\n   Native application with AGL service defined as a binder,\n   content.src designates the relative path of the binary,\n   bindings, if any must be put in the subdirectory \nlib\n of the widget,\n   http content, if any, must be put in the subdirectory \nhtdocs\n of the widget\n\n\n\n\n\n\ntext/vnd.qt.qml\n, \napplication/vnd.agl.qml\n:\n   QML application,\n   content.src designate the relative path of the QML root,\n   imports must be put in the subdirectory \nimports\n of the widget\n\n\n\n\n\n\napplication/vnd.agl.qml.hybrid\n:\n   QML application with bindings,\n   content.src designate the relative path of the QML root,\n   bindings, if any must be put in the subdirectory \nlib\n of the widget,\n   imports must be put in the subdirectory \nimports\n of the widget\n\n\n\n\n\n\napplication/vnd.agl.html.hybrid\n:\n   HTML application,\n   content.src designates the home page of the application,\n   bindings, if any must be put in the subdirectory \nlib\n of the widget,\n   http content must be put in the subdirectory \nhtdocs\n of the widget\n\n\n\n\n\n\nAGL features\n\n\nThe AGL framework uses the feature tag for specifying security and binding\nrequirement of the widget.\n\n\nThe current version of AGL (up to 2.0.1, blowfish) has no fully implemented\nfeatures.\n\n\nThe features planned to be implemented are described below.\n\n\nfeature name=\"urn:AGL:required-binding\"\n\n\nList of the bindings required by the widget.\n\n\nEach required binding must be explicited using a \n entry.\n\n\nparam name=[required binding name]\n\n\nThe value is either:\n\n\n\n\nrequired: the binding is mandatorily needed except if the feature\nisn't required (required=\"false\") and in that case it is optional.\n\n\noptional: the binding is optional\n\n\n\n\nfeature name=\"urn:AGL:required-permission\"\n\n\nList of the permissions required by the widget.\n\n\nEach required permission must be explicited using a \n entry.\n\n\nparam name=[required permission name]\n\n\nThe value is either:\n\n\n\n\nrequired: the permission is mandatorily needed except if the feature\nisn't required (required=\"false\") and in that case it is optional.\n\n\noptional: the permission is optional\n\n\n\n\nfeature name=\"urn:AGL:provided-binding\"\n\n\nUse this feature for each provided binding of the widget.\nThe parameters are:\n\n\nparam name=\"name\"\n\n\nREQUIRED\n\n\nThe value is the string that must match the binding prefix.\nIt must be unique.\n\n\nparam name=\"src\"\n\n\nREQUIRED\n\n\nThe value is the path of the shared library for the binding.\n\n\nparam name=\"type\"\n\n\nREQUIRED\n\n\nCurrently it must be \napplication/vnd.agl.binding.v1\n.\n\n\nparam name=\"scope\"\n\n\nREQUIRED\n\n\nThe value indicate the availability of the binidng:\n\n\n\n\nprivate: used only by the widget\n\n\npublic: available to allowed clients as a remote service (requires permission+)\n\n\ninline: available to allowed clients inside their binding (unsafe, requires permission+++)\n\n\n\n\nparam name=\"needed-binding\"\n\n\nOPTIONAL\n\n\nThe value is a space separated list of binding's names that the binding needs.\n\n\nfeature name=\"urn:AGL:defined-permission\"\n\n\nEach required permission must be explicited using a \n entry.\n\n\nparam name=[defined permission name]\n\n\nThe value is the level of the defined permission.\nStandard levels are: \n\n\n\n\nsystem\n\n\nplatform\n\n\npartner\n\n\npublic\n\n\n\n\nThis level defines the level of accreditation required to get the given\npermission. The accreditions are given by signatures of widgets.", 
            "title": "Writing config.xml"
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#writing-the-configuration-file-configxml", 
            "text": "", 
            "title": "Writing the configuration file \"config.xml\""
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#about-configxml", 
            "text": "The file  config.xml  describes important data of the application\nto the framework:   the unique identifier of the application  the name of the application  the type of the application  the icon of the application  the permissions linked to the application  the services and dependancies of the application   The file MUST be at the root of the widget and MUST be case sensitively name config.xml .  The file  config.xml  is a XML file described by the document widgets .", 
            "title": "About \"config.xml\""
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#example-of-configxml", 
            "text": "Here is the example of the config file for the QML application SmartHome.  ?xml version= 1.0  encoding= UTF-8 ?  widget xmlns= http://www.w3.org/ns/widgets  id= smarthome  version= 0.1 \n   name SmartHome /name \n   icon src= smarthome.png / \n   content src= qml/smarthome/smarthome.qml  type= text/vnd.qt.qml / \n   description \n    This is the Smarthome QML demo application.\n    It shows some user interfaces for controlling an automated house.\n    The user interface is completely done with QML.\n   /description \n   author Qt team /author \n   license GPL /license  /widget", 
            "title": "Example of \"config.xml\""
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#standard-elements-of-configxml", 
            "text": "", 
            "title": "Standard elements of \"config.xml\""
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#the-element-widget", 
            "text": "", 
            "title": "The element widget"
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#the-attribute-id-of-widget", 
            "text": "The attribute  id  is mandatory (for version 2.x, blowfish) and must be unique.  Values for  id  are any non empty string containing only latin letters,\narabic digits, and the three characters '.' (dot), '-' (dash) and\n'_' (underscore).  Authors can use a mnemonic id or can pick a unique id using\ncommand  uuid  or  uuidgen .", 
            "title": "the attribute id of widget"
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#the-attribute-version-of-widget", 
            "text": "The attribute  version  is mandatory (for version 2.x, blowfish).  Values for  id  are any non empty string containing only latin letters,\narabic digits, and the three characters '.' (dot), '-' (dash) and\n'_' (underscore).  Version values are dot separated fields MAJOR.MINOR.REVISION.", 
            "title": "the attribute version of widget"
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#the-element-content", 
            "text": "The element  content  is mandatory (for version 2.x, blowfish) and must designate a file\n(subject to localisation) with its attribute  src .  The content designed depends on its type. See below for the known types.", 
            "title": "The element content"
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#the-element-icon", 
            "text": "The element  icon  is mandatory (for version 2.x, blowfish) and must\nbe unique. It must designate an image file with its attribute  src .", 
            "title": "The element icon"
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#known-widget-types-and-content", 
            "text": "The configuration file  /etc/afm/afm-launch.conf  defines the types\nof widget known and how to launch it.  Known types for the type of content are (for version 2.x, blowfish):    text/html : \n   HTML application,\n   content.src designates the home page of the application    application/x-executable :\n   Native application,\n   content.src designates the relative path of the binary    application/vnd.agl.url :\n   Internet url,\n   content.src designates the url to be used    application/vnd.agl.service :\n   AGL service defined as a binder,\n   content.src designates the directory of provided binders,\n   http content, if any, must be put in the subdirectory  htdocs  of the widget    application/vnd.agl.native :\n   Native application with AGL service defined as a binder,\n   content.src designates the relative path of the binary,\n   bindings, if any must be put in the subdirectory  lib  of the widget,\n   http content, if any, must be put in the subdirectory  htdocs  of the widget    text/vnd.qt.qml ,  application/vnd.agl.qml :\n   QML application,\n   content.src designate the relative path of the QML root,\n   imports must be put in the subdirectory  imports  of the widget    application/vnd.agl.qml.hybrid :\n   QML application with bindings,\n   content.src designate the relative path of the QML root,\n   bindings, if any must be put in the subdirectory  lib  of the widget,\n   imports must be put in the subdirectory  imports  of the widget    application/vnd.agl.html.hybrid :\n   HTML application,\n   content.src designates the home page of the application,\n   bindings, if any must be put in the subdirectory  lib  of the widget,\n   http content must be put in the subdirectory  htdocs  of the widget", 
            "title": "Known widget types and content"
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#agl-features", 
            "text": "The AGL framework uses the feature tag for specifying security and binding\nrequirement of the widget.  The current version of AGL (up to 2.0.1, blowfish) has no fully implemented\nfeatures.  The features planned to be implemented are described below.", 
            "title": "AGL features"
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#feature-nameurnaglrequired-binding", 
            "text": "List of the bindings required by the widget.  Each required binding must be explicited using a   entry.", 
            "title": "feature name=\"urn:AGL:required-binding\""
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#param-namerequired-binding-name", 
            "text": "The value is either:   required: the binding is mandatorily needed except if the feature\nisn't required (required=\"false\") and in that case it is optional.  optional: the binding is optional", 
            "title": "param name=[required binding name]"
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#feature-nameurnaglrequired-permission", 
            "text": "List of the permissions required by the widget.  Each required permission must be explicited using a   entry.", 
            "title": "feature name=\"urn:AGL:required-permission\""
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#param-namerequired-permission-name", 
            "text": "The value is either:   required: the permission is mandatorily needed except if the feature\nisn't required (required=\"false\") and in that case it is optional.  optional: the permission is optional", 
            "title": "param name=[required permission name]"
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#feature-nameurnaglprovided-binding", 
            "text": "Use this feature for each provided binding of the widget.\nThe parameters are:", 
            "title": "feature name=\"urn:AGL:provided-binding\""
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#param-namename", 
            "text": "REQUIRED  The value is the string that must match the binding prefix.\nIt must be unique.", 
            "title": "param name=\"name\""
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#param-namesrc", 
            "text": "REQUIRED  The value is the path of the shared library for the binding.", 
            "title": "param name=\"src\""
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#param-nametype", 
            "text": "REQUIRED  Currently it must be  application/vnd.agl.binding.v1 .", 
            "title": "param name=\"type\""
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#param-namescope", 
            "text": "REQUIRED  The value indicate the availability of the binidng:   private: used only by the widget  public: available to allowed clients as a remote service (requires permission+)  inline: available to allowed clients inside their binding (unsafe, requires permission+++)", 
            "title": "param name=\"scope\""
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#param-nameneeded-binding", 
            "text": "OPTIONAL  The value is a space separated list of binding's names that the binding needs.", 
            "title": "param name=\"needed-binding\""
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#feature-nameurnagldefined-permission", 
            "text": "Each required permission must be explicited using a   entry.", 
            "title": "feature name=\"urn:AGL:defined-permission\""
        }, 
        {
            "location": "/developer/app-framework/main/writing-config.xml/#param-namedefined-permission-name", 
            "text": "The value is the level of the defined permission.\nStandard levels are:    system  platform  partner  public   This level defines the level of accreditation required to get the given\npermission. The accreditions are given by signatures of widgets.", 
            "title": "param name=[defined permission name]"
        }, 
        {
            "location": "/developer/audio/", 
            "text": "AGL Audio Framework\n\n\nPulseaudio Plugin\n\n\nSource code is hosted on \ngerrit:staging/agl-audio-plugin\n\n\nDocumentation is available on \nIoT.bzh site", 
            "title": "Home"
        }, 
        {
            "location": "/developer/audio/#agl-audio-framework", 
            "text": "", 
            "title": "AGL Audio Framework"
        }, 
        {
            "location": "/developer/audio/#pulseaudio-plugin", 
            "text": "Source code is hosted on  gerrit:staging/agl-audio-plugin  Documentation is available on  IoT.bzh site", 
            "title": "Pulseaudio Plugin"
        }, 
        {
            "location": "/developer/sec-blueprint/01-overview/", 
            "text": "title : Security BluePrint Overview\ndate  : 2016-07-06\ncategory: security\ntags: security, architecture, automotive, linux\nlayout: techdoc \n\n\n\n\nTable of Content\n\n\n\n\nTOC\n{:toc}\n\n\n\n\nIntroduction\n\n\nScope\n\n\nGlossary", 
            "title": "01 overview"
        }, 
        {
            "location": "/developer/sec-blueprint/01-overview/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/developer/sec-blueprint/01-overview/#scope", 
            "text": "", 
            "title": "Scope"
        }, 
        {
            "location": "/developer/sec-blueprint/01-overview/#glossary", 
            "text": "", 
            "title": "Glossary"
        }, 
        {
            "location": "/developer/sec-blueprint/02-plateform-security/", 
            "text": "title : platform Security\ndate  : 2016-06-30\ncategories: architecture, automotive\ntags: architecture, automotive, linux\nlayout: techdoc \n\n\n\n\nTable of Content\n\n\n\n\nTOC\n{:toc}\n\n\n\n\nPlatform Definition\n\n\nSecure boot\n\n\nCertificate and Key Management\n\n\nResource Management\n\n\nTrust Zone\n\n\nPlatform Software Update\n\n\nCritical Resource Protection\n\n\nUpdate\n\n\ncloud service infrastructure", 
            "title": "02 plateform security"
        }, 
        {
            "location": "/developer/sec-blueprint/02-plateform-security/#platform-definition", 
            "text": "", 
            "title": "Platform Definition"
        }, 
        {
            "location": "/developer/sec-blueprint/02-plateform-security/#secure-boot", 
            "text": "", 
            "title": "Secure boot"
        }, 
        {
            "location": "/developer/sec-blueprint/02-plateform-security/#certificate-and-key-management", 
            "text": "", 
            "title": "Certificate and Key Management"
        }, 
        {
            "location": "/developer/sec-blueprint/02-plateform-security/#resource-management", 
            "text": "", 
            "title": "Resource Management"
        }, 
        {
            "location": "/developer/sec-blueprint/02-plateform-security/#trust-zone", 
            "text": "", 
            "title": "Trust Zone"
        }, 
        {
            "location": "/developer/sec-blueprint/02-plateform-security/#platform-software-update", 
            "text": "", 
            "title": "Platform Software Update"
        }, 
        {
            "location": "/developer/sec-blueprint/02-plateform-security/#critical-resource-protection", 
            "text": "", 
            "title": "Critical Resource Protection"
        }, 
        {
            "location": "/developer/sec-blueprint/02-plateform-security/#update", 
            "text": "", 
            "title": "Update"
        }, 
        {
            "location": "/developer/sec-blueprint/02-plateform-security/#cloud-service-infrastructure", 
            "text": "", 
            "title": "cloud service infrastructure"
        }, 
        {
            "location": "/developer/sec-blueprint/03-security-concepts/", 
            "text": "title : Application Security Concepts\ndate  : 2016-06-30\ncategories: architecture, automotive\ntags: architecture, automotive, linux\nlayout: techdoc \n\n\n\n\nTable of Content\n\n\n\n\nTOC\n{:toc}\n\n\n\n\nSecurity Principles\n\n\nAccess Control\n\n\nSecure Boot\n\n\nApplications\n\n\nProcess Management", 
            "title": "03 security concepts"
        }, 
        {
            "location": "/developer/sec-blueprint/03-security-concepts/#security-principles", 
            "text": "", 
            "title": "Security Principles"
        }, 
        {
            "location": "/developer/sec-blueprint/03-security-concepts/#access-control", 
            "text": "", 
            "title": "Access Control"
        }, 
        {
            "location": "/developer/sec-blueprint/03-security-concepts/#secure-boot", 
            "text": "", 
            "title": "Secure Boot"
        }, 
        {
            "location": "/developer/sec-blueprint/03-security-concepts/#applications", 
            "text": "", 
            "title": "Applications"
        }, 
        {
            "location": "/developer/sec-blueprint/03-security-concepts/#process-management", 
            "text": "", 
            "title": "Process Management"
        }, 
        {
            "location": "/developer/sec-blueprint/04-adversaries/", 
            "text": "title : Adversaries\ndate  : 2016-06-30\ncategories: architecture, automotive\ntags: architecture, automotive, linux\nlayout: techdoc \n\n\n\n\nTable of Content\n\n\n\n\nTOC\n{:toc}\n\n\n\n\nAuthorised malicious project admin/developer\n\n\nMalware developer\n\n\nOrganised crime\n\n\nAuthorised device/cloud user\n\n\nNetwork mass attacker", 
            "title": "04 adversaries"
        }, 
        {
            "location": "/developer/sec-blueprint/04-adversaries/#authorised-malicious-project-admindeveloper", 
            "text": "", 
            "title": "Authorised malicious project admin/developer"
        }, 
        {
            "location": "/developer/sec-blueprint/04-adversaries/#malware-developer", 
            "text": "", 
            "title": "Malware developer"
        }, 
        {
            "location": "/developer/sec-blueprint/04-adversaries/#organised-crime", 
            "text": "", 
            "title": "Organised crime"
        }, 
        {
            "location": "/developer/sec-blueprint/04-adversaries/#authorised-devicecloud-user", 
            "text": "", 
            "title": "Authorised device/cloud user"
        }, 
        {
            "location": "/developer/sec-blueprint/04-adversaries/#network-mass-attacker", 
            "text": "", 
            "title": "Network mass attacker"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/", 
            "text": "title : Treat Analysis \n Coverage\ndate  : 2016-06-30\ncategories: architecture, automotive\ntags: architecture, automotive, linux\nlayout: techdoc \n\n\n\n\nTable of Content\n\n\n\n\nTOC\n{:toc}\n\n\n\n\nFactory/Dealer installed applications\n\n\nFactory/Dealer installed application updates\n\n\nFactory/Dealer installed application removal\n\n\nUser installed applications\n\n\nUser installed application update\n\n\nUser installed application removal\n\n\nApplication Data security\n\n\nApplication Data upgrades\n\n\nVehicle bus write access by Factoy applications\n\n\nVehicle bus write access by User applications\n\n\nVehicle bus read access by Factoy applications\n\n\nVehicle bus read access by User applications\n\n\nPlatform software update failure due to corrupted update package\n\n\nPlatform software update failure due to corrupted invalid package\n\n\nAttack from the Cloud\n\n\nMan in the middle\n\n\nMalicious CAN / USB devices", 
            "title": "04 threat analysis"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#factorydealer-installed-applications", 
            "text": "", 
            "title": "Factory/Dealer installed applications"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#factorydealer-installed-application-updates", 
            "text": "", 
            "title": "Factory/Dealer installed application updates"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#factorydealer-installed-application-removal", 
            "text": "", 
            "title": "Factory/Dealer installed application removal"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#user-installed-applications", 
            "text": "", 
            "title": "User installed applications"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#user-installed-application-update", 
            "text": "", 
            "title": "User installed application update"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#user-installed-application-removal", 
            "text": "", 
            "title": "User installed application removal"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#application-data-security", 
            "text": "", 
            "title": "Application Data security"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#application-data-upgrades", 
            "text": "", 
            "title": "Application Data upgrades"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#vehicle-bus-write-access-by-factoy-applications", 
            "text": "", 
            "title": "Vehicle bus write access by Factoy applications"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#vehicle-bus-write-access-by-user-applications", 
            "text": "", 
            "title": "Vehicle bus write access by User applications"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#vehicle-bus-read-access-by-factoy-applications", 
            "text": "", 
            "title": "Vehicle bus read access by Factoy applications"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#vehicle-bus-read-access-by-user-applications", 
            "text": "", 
            "title": "Vehicle bus read access by User applications"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#platform-software-update-failure-due-to-corrupted-update-package", 
            "text": "", 
            "title": "Platform software update failure due to corrupted update package"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#platform-software-update-failure-due-to-corrupted-invalid-package", 
            "text": "", 
            "title": "Platform software update failure due to corrupted invalid package"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#attack-from-the-cloud", 
            "text": "", 
            "title": "Attack from the Cloud"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#man-in-the-middle", 
            "text": "", 
            "title": "Man in the middle"
        }, 
        {
            "location": "/developer/sec-blueprint/04-threat-analysis/#malicious-can-usb-devices", 
            "text": "", 
            "title": "Malicious CAN / USB devices"
        }, 
        {
            "location": "/developer/sec-blueprint/06-attack-surfaces/", 
            "text": "title : Attack Surfaces\ndate  : 2016-06-30\ncategories: architecture, automotive\ntags: architecture, automotive, linux\nlayout: techdoc \n\n\n\n\nTable of Content\n\n\n\n\nTOC\n{:toc}\n\n\n\n\nOS installation at factory Key leak risk\n\n\nOS boot\n\n\nOS upgrade\n\n\nDevice bus (static and autodetection) USB\n\n\n\"Wireless connections (Wifi##  Bluetooth##  ...)\"\n\n\n\"Wired connection (Can##  Serial##  Eth ...)\"\n\n\nOS-Device file system\n\n\nUser data (local \n cloud)\n\n\nApplication FW\n\n\nApplication Store\n\n\nApplication data (local \n Cloud)", 
            "title": "06 attack surfaces"
        }, 
        {
            "location": "/developer/sec-blueprint/06-attack-surfaces/#os-installation-at-factory-key-leak-risk", 
            "text": "", 
            "title": "OS installation at factory Key leak risk"
        }, 
        {
            "location": "/developer/sec-blueprint/06-attack-surfaces/#os-boot", 
            "text": "", 
            "title": "OS boot"
        }, 
        {
            "location": "/developer/sec-blueprint/06-attack-surfaces/#os-upgrade", 
            "text": "", 
            "title": "OS upgrade"
        }, 
        {
            "location": "/developer/sec-blueprint/06-attack-surfaces/#device-bus-static-and-autodetection-usb", 
            "text": "", 
            "title": "Device bus (static and autodetection) USB"
        }, 
        {
            "location": "/developer/sec-blueprint/06-attack-surfaces/#wireless-connections-wifi-bluetooth", 
            "text": "", 
            "title": "\"Wireless connections (Wifi##  Bluetooth##  ...)\""
        }, 
        {
            "location": "/developer/sec-blueprint/06-attack-surfaces/#wired-connection-can-serial-eth", 
            "text": "", 
            "title": "\"Wired connection (Can##  Serial##  Eth ...)\""
        }, 
        {
            "location": "/developer/sec-blueprint/06-attack-surfaces/#os-device-file-system", 
            "text": "", 
            "title": "OS-Device file system"
        }, 
        {
            "location": "/developer/sec-blueprint/06-attack-surfaces/#user-data-local-cloud", 
            "text": "", 
            "title": "User data (local &amp; cloud)"
        }, 
        {
            "location": "/developer/sec-blueprint/06-attack-surfaces/#application-fw", 
            "text": "", 
            "title": "Application FW"
        }, 
        {
            "location": "/developer/sec-blueprint/06-attack-surfaces/#application-store", 
            "text": "", 
            "title": "Application Store"
        }, 
        {
            "location": "/developer/sec-blueprint/06-attack-surfaces/#application-data-local-cloud", 
            "text": "", 
            "title": "Application data (local &amp; Cloud)"
        }, 
        {
            "location": "/developer/sec-blueprint/", 
            "text": "title : Security BluePrint Overview\ndate  : 2016-07-06\ncategory: security\ntags: security, architecture, automotive, linux\nlayout: techdoc \n\n\n\n\nOverview\n\n\nPlateform Security\n\n\nSecurity Concepts\n\n\nAdversaries\n\n\nThreat Analysis\n\n\nAttack Surfaces", 
            "title": "Home"
        }, 
        {
            "location": "/developer/sec-blueprint/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/developer/sec-blueprint/#plateform-security", 
            "text": "", 
            "title": "Plateform Security"
        }, 
        {
            "location": "/developer/sec-blueprint/#security-concepts", 
            "text": "", 
            "title": "Security Concepts"
        }, 
        {
            "location": "/developer/sec-blueprint/#adversaries", 
            "text": "", 
            "title": "Adversaries"
        }, 
        {
            "location": "/developer/sec-blueprint/#threat-analysis", 
            "text": "", 
            "title": "Threat Analysis"
        }, 
        {
            "location": "/developer/sec-blueprint/#attack-surfaces", 
            "text": "", 
            "title": "Attack Surfaces"
        }, 
        {
            "location": "/developer/signaling/architecture/", 
            "text": "categories: architecture, appfw\ntags: architecture, signal, message\nlayout: techdoc\n\n\n\n\nTable of Content\n\n\n\n\nTOC\n{:toc}\n\n\n\n\nContext\n\n\nAutomotive applications need to understand in real time the context in which \nvehicles operate. In order to do so, it is critical for automotive application\nto rely on a simple, fast and secure method to access data generated by the\nmultiple sensors/ECU embedded in modern cars.\n\n\nThis signaling problem is neither new, neither unique to the automotive and\nmultiple solutions often described as Message Broker or Signaling Gateway have\nbeen around for a while.\nIn the context of Linux for Automotive, the \"Automotive Message Broker Daemon\n\" (aka AMBd) has been around for few years and is pretty well known within the\nLinux Automotive community.\n\n\nThe present discussion is a proposal to enhance existing signaling/message\nmodels. Our proposal relies on [[APbinder]] binder/bindings model to minimize\ncomplexity while keeping the system fast and secure.\nWe propose a model with multiple transport options and a full set of security\nfeature to protect the agent generating the signal as well as consuming them.\n\n\nObjectives\n\n\nOur objectives are to solve following 3 key issues:\n\n\n\n\nreduce as much as possible the amount of exchanged data to the meaningful subset really used by applications\n\n\noffer a high level API that obfuscates low level and proprietary interface to improve stability in time of the code\n\n\nhide specificities of low level implementation as well as the chosen deployment distribution model.\n\n\n\n\nTo reach first objective, events emission frequency should be controlled at the lowest level it possibly can.\nAggregation, composition, treatment, filtering of signals should be supported at software level when \nnot supported by the hardware.\n\n\nSecond objectives of offering long term stable hight level API while allowing flexibility in changing low level implementation\nmay look somehow conflicting. Nevertheless by isolating low level interface from high level and allowing dynamic composition\nit is possible to mitigate both objectives.\n\n\nArchitecture\n\n\nGood practice is often based on modularity with clearly separated components assembled within a common framework.\nSuch modularity ensures separation of duties, robustness, resilience and achievable long term maintenance.\n\n\nThis document uses the term \"AGENT\" to define a specific instance of this proposed common framework used to host a group\nof dedicated separated components that handle targeted signals/events. Each agent exposes to services/applications\nthe signals/events it is responsible for. \n\n\nAs an example, a CAN-bus agent may want to mix non-public proprietary API with CANopen compatible devices while hiding this\ncomplexity to applications. The goal is on one hand to isolate proprietary piece of code in such a way that it is\nas transparent as possible for the remaining part of the architecture. On a second hand isolation of code related\nto a specific device provides a better separation of responsibilities, keeping all specificity related to a given\ncomponent clearly isolated and much easier to test or maintain. Last but not least if needed this model may also\nhelp to provide some proprietary code directly as binary and not as source code.\n\n\n\n\nWhile in some cases it may be chosen to implement a single agent responsible for everything, other scenarii may chose\nto split responsibility between multiple agents. Those multiple agents may run on a single ECU or on multiple ECUs.\nChosen deployment distribution strategy should not impact the development of components responsible for signals/events\ncapture. As well as it should have a loose impact on applications/services consuming those events.\n\n\nA distributed capable architecture may provide multiple advantages:\n\n\n\n\nit avoids to concentrate complexity in a single big/fat component.\n\n\nit leverages naturally multiple ECUs and existing network architecture\n\n\nit simplifies security by enabling isolation and sandboxing\n\n\nit clearly separates responsibilities and simplifies resolution of conflicts\n\n\n\n\n\n\nPerformance matters. There is a trade-off between modularity and efficiency.\nThis is specially critical for signals where propagation time from one module to the other\nshould remain as short as possible and furthermore should consume as little computing resources as possible.\n\n\nA flexible solution should provide enough versatility to either compose modules in separate processes;\neither chose a model where everything is hosted within a single process. Chosen deployment model should have minor\nor no impact on development/integration processes. Deployment model should be something easy to change, it should remain\na tactical decision and never become a structuring decision.\n\n\nNevertheless while grouping modules may improve performance and reduce resource consumption, on the other hand,\nit has a clear impact on security. No one should forget that some signals have very different level of security from other ones.\nMixing everything within a single process makes all signal's handling within a single security context.\nSuch a decision may have a significant impact on the level on confidence one may have in the global system.\n\n\nProviding such flexibility constrains the communication model used by modules:\n\n\n\n\nThe API of integration of the modules (the API of the framework) that enables\n  the connection of modules must be independent of the implementation of\n  the communication layer\n\n\nThe communication layer must be as transparent as possible, its\n  implementation shouldn't impact how it is used\n\n\nThe cost of the abstraction for modules grouped in a same process\n  must be as little as possible\n\n\nThe cost of separating modules with the maximum of security must remain as minimal as possible\n\n\n\n\nAnother point impacting performance relates to a smart limitation on the number of emitted signals.\nImproving the cost of sending a signal is one thing, reducing the number of signals is an other one.\nNo one should forget that the faster you ignore a useless signal the better it is. \nThe best way to achieve this is by doing the filtering of useless signal as close as possible\nof the component generating the signal and when possible directly at the hardware level.\n\n\nTo enable the right component to filter useless signals, consumer clients must describe\nprecisely the data they need. Then services and agent must organise their computing to provide\nonly expected data at the expected rate. Also, any data not required by any client should at\nthe minimum never be transmitted. Furthermore when possible then should even not be computed at all.\n\n\nDescribing expected data in a precise but nevertheless simple manner remains a challenge.\nIt implies to manage:\n\n\n\n\nrequested frequency of expected data\n\n\naccuracy of data to avoid detection of inaccurate changes\n\n\nwhen signaling is required (raising edge, falling edge,\n  on maintained state, ...),\n\n\nfiltering of data to avoid glitches and noise,\n\n\ncomposition of signals both numerically and logically (adding,\n  subtracting, running logical operators like AND/OR/XOR, getting the mean, ...)\n\n\netc...\n\n\n\n\nIt is critical to enable multiple features in signal queries to enable modules \nto implement the best computing method. The best computing method may have an impact on\nwhich device to query as well as on which filters should be applied. Furthermore\nfiltering should happen as soon as possible and obviously when possible directly at hardware level.\n\n\nLeveraging Existing solutions\n\n\nUnfortunately, there is no existing solution ready to be integrated. Obviously some parts of required technologies to\nimplement such solution exist, but a significant part of the work remains to be done. If we look at the main building\nblocks used in the proposed architecture.\n\n\nTransport Solutions\n\n\nD-Bus is the standard choice for Linux, nevertheless it has some serious performance limitation due to\ninternal verbosity. Nevertheless because it is available and pre-integrated with almost every Linux component, D-Bus may\nstill remains an acceptable choice for signal with low rate of emission (i.e. HMI). \n\n\nFor a faster communication, Jaguar-Land-Rover proposes a memory shared signal infrastructure.\nUnfortunately this solution is far from solving all issues and has some drawbacks.\nLet check the open issues it has: \n\n\n\n\nthere is no management of what requested data are. This\ntranslate in computing data even when not needed.\n\n\non top of shared memory, an extra side channel is required for processes to communicate with the\ndaemon. \n\n\na single shared memory implies a lot of concurrency handling. This might\nintroduce drawbacks that otherwise would be solved through communication buffering.\n\n\n\n\nZeroMQ, NanoMSG and equivalent libraries focused on fast communication. Some (e.g. ZeroMQ) come with\na commercial licensing model when others (e.g. NanoMSG) use an open source licensing. \nThose solutions are well suited for both communicating inside a unique ECU or across several ECUs.\nHowever, most of them are using Unix domain sockets and TCP sockets and typically do not use shared memory for inter-process communication.\n\n\nLast but not least Android binder, Kdbus and other leverage shared memory, zero copy and sit directly within Linux kernel. \nWhile this may boost information passing between local processes, it also has some limitations. The first one is\nthe non support of a multi-ECU or vehicle to cloud distribution. The second one is that none of them is\napproved upstream in kernel tree. This last point may create some extra burden each time a new version\nof Linux kernel is needed or when porting toward a new hardware is required.\n\n\nQuery and Filtering Language\n\n\nDescription language for filtering of expected data remains an almost green field where nothing really fit signal agent requirements.\nLanguages like Simulink or signal processing graphical languages are valuable modelling tools. Unfortunately they\ncannot be inserted in the car. Furthermore those languages have many features that are not useful in proposed signal agent\ncontext and cost of integrating such complex languages might not be justified for something as simple as a signal agent.\nThe same remarks apply for automation languages.\n\n\nFurther investigations would be needed. Even if there is no obvious solutions fit or need. Existing solution use a different context or industry may exist or nearby solutions\nmight worse the value be adapted to our requirements.\n\n\nDescribing Signal Subscriptions using JSON\n\n\nJSON is a rich structured representation of data. For requested data, it allows the expression of multiple features and constraints.\nJSON is both very flexible and efficient.\nThere are significant advantages in describing requested data at subscription time using a language like JSON.\nAnother advantage of JSON is that no parser is required to analyse the request.\n\n\nHere is an example of what could be a subscription specification:\n\n\n{\n  \ndefine\n: {\n      \nspeed\n: {\n           \nsignal\n: \naverage-wheel-speed\n,\n           \nunit\n: \nkm/h\n,\n           \naccuracy\n: 0.5,\n           \nfiltered\n: \nyes\n\n       },\n   \nexpect\n: {\n      \nvalue\n: \nspeed\n,\n      \nwhen\n: {\n          \ncross\n: { \nspeed\n: [ 50, 90, 110, 130 ] }\n      },\n      \nmax-rate\n: 1\n  }\n}\n\n\n\n\nA generic library to handle such request definition should be provided.\nThis library should allow the agent to process the request, search if its business logic or any of present low level modules support requested signal. Finally it should notify the concerned lower module to optimise signal generation.\n\n\nWhile such an approach might not be the most common approach, organisation like \nSignal-K\n already uses JSON to transmit NMEA-2000 signals on boats. Others might already used it as well and some further investigations on existing solutions would be needed before moving in such a direction.\n\n\nNaming Signal\n\n\nNaming and defining signals is something very complex.\nFor example just \nspeed\n, as a signal, is difficult to define.\nWhat unit is used (km/h, M/h, m/s, ...)?\nFrom which source (wheels, GPS, AccelMeter)?\nHow was it captured (period of measure, instantaneous, mean, filtered)?\n\n\nIn order to simplify application development we should nevertheless agree on some naming convention for key signals.\nThose names might be relatively complex and featured. They may include a unit, a rate, a precision, etc.\n\n\nHow these names should be registered, documented and managed is out of scope of this document but\nextremely important and at some point in time should be addressed. Nevertheless this issue should not prevent\nfrom moving forward developing a modern architecture.\nDevelopers should be warned that naming is a complex\ntask, and that in the future naming scheme should be redefined, and potential adjustments would be required.\n\n\nLeveraging AGL binder\n\n\nSuch a model is loosely coupled with AGL binder. Low level signal modules as well as virtual signal\ncomponents may potentially run within any hosting environment that would provide the right API with corresponding required facilities.\nNevertheless leveraging [[APbinder]] has multiple advantages. It already implements event notification to support\na messaging/signaling model for distributed agents. It enables a subscribe model responding to the requirement and finally it uses JSON\nnatively.\n\n\nThis messaging/signalling model already enforces the notion of subscription for receiving data.\nIt implies that unexpected data are not sent and merely not computed.\nWhen expected data is available, it is pushed to all waiting subscriber only one time.\n\n\nThe [[APbinder]] provides transparency of communication.\nIt currently implements the transparency over D-Bus/Kdbus and WebSocket.\nIts transparency mechanism of communication is easy to extend to other\ntechnologies: pools of shared memory or any proprietary transport model.\n\n\nWhen modules are loaded by the same service agent, the [[APbinder]] provides transparently \"in-memory\" communication.\nThis in-memory communication is really efficient: on one hand, the exchanged\nJSON objects are not serialized (because not streamed), on the other hand,\nthose JSON objects provide a high level of abstraction able to transfer any\ndata.\n\n\nTechnically an agent is a standard [[APbinder]] service.\nTherefore Signal/Agent inherits of security protection through SMACK, access\ncontrol through Cynara, transparency of API to transport layer, life cycle\nmanagement, ... Like any other [[APbinder]] service Signal/Agent is composed of a set of bindings. In signal agent specific case, those bindings are in fact the \"signal modules\".\n\n\nThe proposed model allows to implement low level dependencies as independent signal modules.\nThose modules when developed are somehow like \"Lego Bricks\".\nThey can be spread or grouped within one or multiple agents depending on\ndeployment constraints (performance, multi-ECU, security \n isolation constraints,\n...).\n\n\nThe model naturally uses JSON to represent data.\n\n\nMulti-ECU and Vehicule to Cloud interactions:\n while this might not be a\nshow stopper for current projects, it is obvious that in the near future\nSignal/Agent should support a fully distributed architectures.\nSome event may come from the cloud (i.e. request to start monitoring a given\nfeature), some may come from SmartCity and nearby vehicles, and last but\nnot least some may come from another ECU within the same vehicle or from a\nvirtualized OS within the same ECU (e.g. cluster \n IVI). \nIn order to do so, Signal modules should enable composition within one or more\n[[APbinder]] inside the same ECU.\nFurthermore they should also support chaining with the outside world.\n\n\n\n\n\n\nApplication requests Virtual Signal exactly like if it was a low level\n   signal\n\n\nAgent Signal has direct relation to low level signal\n\n\nAgent needs to proxy to an other agent inside the same ECU to access the\n   signal\n\n\nSignal is not present on current ECU. Request has to be proxied to the\n   outside world\n\n\n\n\nWork to be Done\n\n\nAs stated before, the foundation for event signaling is already in place in\ndevelopment branch of [[APbinder]].\nNevertheless in order to provide a real added value to developers missing\ncomponents should be developed.\n\n\n\n\nAgent Core Components\n\n\nCreate a simple configuration model to move from low level signal\n  description to something more generic that could help to abstract the\n  hardware.\n\n\nSearch for an already existing library that provide high level signal\n  subscription and adapt it.\n  If no such library exist, create it.\n\n\nImplement some form of introspection to allow application to discover\n  the list of signal supported by a given agent.\n\n\n\n\n\n\nFew Common Agents\n\n\nProvide at least a reference implementation for a generic CAN agent\n\n\nAgent simulation, most developers may not have access to physical\n  devices during development phase, some form of simulator would be more\n  than welcome.\n\n\netc ...\n\n\n\n\n\n\n\n\nReusing existing/legacy code\n\n\nWhatever the final architecture will be, it is important not to forget how\nto leverage existing/legacy code within the new model.\nThere are multiple sources for reusable code that can be classified in two\nmain categories:\n\n\n\n\n\n\nLow Level\n Typically those existing code interface with CAN-BUS or any\n  other low level device.\n  Some AMBd[[6]] plugins could be a good source of input for low level\n  implementation.\n  But also more community oriented projects like: ArduPilot/Rover[[7]]\n  Barometer or Camera interfaces[[8]].\n\n\n\n\n\n\nVirtual Signal\n In many cases accessing to low level signal is not enough.\n  Low level information might need to be composed (i.e. GPS+Gyro+Accel).\n  Raw value might need to be processed (i.e.: change unit, average on the\n  last xx seconds, ...).\n  Writing this composition logic might be quite complex and reusing existing\n  libraries like: LibEkNav for Kalman filtering [[9]] or Vrgimbal for 3 axes\n  control[[10]] may help saving a lot of time.\n\n\n\n\n\n\nProposal\n\n\nIn order to start moving forward one option would be to take a concrete example\nwith some existing can devices (i.e. the one from MicroChips use within ALS demo).\n\n\nAn other option would be to leverage Porter+Cogent-Extension[[11]] that supports\nboth a GPS and a 9 axis sensor to implement a smart geoposition agent. \nWe could  reuse some existing code like the one from Rover[[7]] to provide a\nfine grain positioning service and then interface this new GeoPositioning\nagent with an application like GpsNavi[[12]] to get a end-to-end demonstrator.", 
            "title": "Architecture"
        }, 
        {
            "location": "/developer/signaling/architecture/#context", 
            "text": "Automotive applications need to understand in real time the context in which \nvehicles operate. In order to do so, it is critical for automotive application\nto rely on a simple, fast and secure method to access data generated by the\nmultiple sensors/ECU embedded in modern cars.  This signaling problem is neither new, neither unique to the automotive and\nmultiple solutions often described as Message Broker or Signaling Gateway have\nbeen around for a while.\nIn the context of Linux for Automotive, the \"Automotive Message Broker Daemon\n\" (aka AMBd) has been around for few years and is pretty well known within the\nLinux Automotive community.  The present discussion is a proposal to enhance existing signaling/message\nmodels. Our proposal relies on [[APbinder]] binder/bindings model to minimize\ncomplexity while keeping the system fast and secure.\nWe propose a model with multiple transport options and a full set of security\nfeature to protect the agent generating the signal as well as consuming them.", 
            "title": "Context"
        }, 
        {
            "location": "/developer/signaling/architecture/#objectives", 
            "text": "Our objectives are to solve following 3 key issues:   reduce as much as possible the amount of exchanged data to the meaningful subset really used by applications  offer a high level API that obfuscates low level and proprietary interface to improve stability in time of the code  hide specificities of low level implementation as well as the chosen deployment distribution model.   To reach first objective, events emission frequency should be controlled at the lowest level it possibly can.\nAggregation, composition, treatment, filtering of signals should be supported at software level when \nnot supported by the hardware.  Second objectives of offering long term stable hight level API while allowing flexibility in changing low level implementation\nmay look somehow conflicting. Nevertheless by isolating low level interface from high level and allowing dynamic composition\nit is possible to mitigate both objectives.", 
            "title": "Objectives"
        }, 
        {
            "location": "/developer/signaling/architecture/#architecture", 
            "text": "Good practice is often based on modularity with clearly separated components assembled within a common framework.\nSuch modularity ensures separation of duties, robustness, resilience and achievable long term maintenance.  This document uses the term \"AGENT\" to define a specific instance of this proposed common framework used to host a group\nof dedicated separated components that handle targeted signals/events. Each agent exposes to services/applications\nthe signals/events it is responsible for.   As an example, a CAN-bus agent may want to mix non-public proprietary API with CANopen compatible devices while hiding this\ncomplexity to applications. The goal is on one hand to isolate proprietary piece of code in such a way that it is\nas transparent as possible for the remaining part of the architecture. On a second hand isolation of code related\nto a specific device provides a better separation of responsibilities, keeping all specificity related to a given\ncomponent clearly isolated and much easier to test or maintain. Last but not least if needed this model may also\nhelp to provide some proprietary code directly as binary and not as source code.   While in some cases it may be chosen to implement a single agent responsible for everything, other scenarii may chose\nto split responsibility between multiple agents. Those multiple agents may run on a single ECU or on multiple ECUs.\nChosen deployment distribution strategy should not impact the development of components responsible for signals/events\ncapture. As well as it should have a loose impact on applications/services consuming those events.  A distributed capable architecture may provide multiple advantages:   it avoids to concentrate complexity in a single big/fat component.  it leverages naturally multiple ECUs and existing network architecture  it simplifies security by enabling isolation and sandboxing  it clearly separates responsibilities and simplifies resolution of conflicts    Performance matters. There is a trade-off between modularity and efficiency.\nThis is specially critical for signals where propagation time from one module to the other\nshould remain as short as possible and furthermore should consume as little computing resources as possible.  A flexible solution should provide enough versatility to either compose modules in separate processes;\neither chose a model where everything is hosted within a single process. Chosen deployment model should have minor\nor no impact on development/integration processes. Deployment model should be something easy to change, it should remain\na tactical decision and never become a structuring decision.  Nevertheless while grouping modules may improve performance and reduce resource consumption, on the other hand,\nit has a clear impact on security. No one should forget that some signals have very different level of security from other ones.\nMixing everything within a single process makes all signal's handling within a single security context.\nSuch a decision may have a significant impact on the level on confidence one may have in the global system.  Providing such flexibility constrains the communication model used by modules:   The API of integration of the modules (the API of the framework) that enables\n  the connection of modules must be independent of the implementation of\n  the communication layer  The communication layer must be as transparent as possible, its\n  implementation shouldn't impact how it is used  The cost of the abstraction for modules grouped in a same process\n  must be as little as possible  The cost of separating modules with the maximum of security must remain as minimal as possible   Another point impacting performance relates to a smart limitation on the number of emitted signals.\nImproving the cost of sending a signal is one thing, reducing the number of signals is an other one.\nNo one should forget that the faster you ignore a useless signal the better it is. \nThe best way to achieve this is by doing the filtering of useless signal as close as possible\nof the component generating the signal and when possible directly at the hardware level.  To enable the right component to filter useless signals, consumer clients must describe\nprecisely the data they need. Then services and agent must organise their computing to provide\nonly expected data at the expected rate. Also, any data not required by any client should at\nthe minimum never be transmitted. Furthermore when possible then should even not be computed at all.  Describing expected data in a precise but nevertheless simple manner remains a challenge.\nIt implies to manage:   requested frequency of expected data  accuracy of data to avoid detection of inaccurate changes  when signaling is required (raising edge, falling edge,\n  on maintained state, ...),  filtering of data to avoid glitches and noise,  composition of signals both numerically and logically (adding,\n  subtracting, running logical operators like AND/OR/XOR, getting the mean, ...)  etc...   It is critical to enable multiple features in signal queries to enable modules \nto implement the best computing method. The best computing method may have an impact on\nwhich device to query as well as on which filters should be applied. Furthermore\nfiltering should happen as soon as possible and obviously when possible directly at hardware level.", 
            "title": "Architecture"
        }, 
        {
            "location": "/developer/signaling/architecture/#leveraging-existing-solutions", 
            "text": "Unfortunately, there is no existing solution ready to be integrated. Obviously some parts of required technologies to\nimplement such solution exist, but a significant part of the work remains to be done. If we look at the main building\nblocks used in the proposed architecture.", 
            "title": "Leveraging Existing solutions"
        }, 
        {
            "location": "/developer/signaling/architecture/#transport-solutions", 
            "text": "D-Bus is the standard choice for Linux, nevertheless it has some serious performance limitation due to\ninternal verbosity. Nevertheless because it is available and pre-integrated with almost every Linux component, D-Bus may\nstill remains an acceptable choice for signal with low rate of emission (i.e. HMI).   For a faster communication, Jaguar-Land-Rover proposes a memory shared signal infrastructure.\nUnfortunately this solution is far from solving all issues and has some drawbacks.\nLet check the open issues it has:    there is no management of what requested data are. This\ntranslate in computing data even when not needed.  on top of shared memory, an extra side channel is required for processes to communicate with the\ndaemon.   a single shared memory implies a lot of concurrency handling. This might\nintroduce drawbacks that otherwise would be solved through communication buffering.   ZeroMQ, NanoMSG and equivalent libraries focused on fast communication. Some (e.g. ZeroMQ) come with\na commercial licensing model when others (e.g. NanoMSG) use an open source licensing. \nThose solutions are well suited for both communicating inside a unique ECU or across several ECUs.\nHowever, most of them are using Unix domain sockets and TCP sockets and typically do not use shared memory for inter-process communication.  Last but not least Android binder, Kdbus and other leverage shared memory, zero copy and sit directly within Linux kernel. \nWhile this may boost information passing between local processes, it also has some limitations. The first one is\nthe non support of a multi-ECU or vehicle to cloud distribution. The second one is that none of them is\napproved upstream in kernel tree. This last point may create some extra burden each time a new version\nof Linux kernel is needed or when porting toward a new hardware is required.", 
            "title": "Transport Solutions"
        }, 
        {
            "location": "/developer/signaling/architecture/#query-and-filtering-language", 
            "text": "Description language for filtering of expected data remains an almost green field where nothing really fit signal agent requirements.\nLanguages like Simulink or signal processing graphical languages are valuable modelling tools. Unfortunately they\ncannot be inserted in the car. Furthermore those languages have many features that are not useful in proposed signal agent\ncontext and cost of integrating such complex languages might not be justified for something as simple as a signal agent.\nThe same remarks apply for automation languages.  Further investigations would be needed. Even if there is no obvious solutions fit or need. Existing solution use a different context or industry may exist or nearby solutions\nmight worse the value be adapted to our requirements.", 
            "title": "Query and Filtering Language"
        }, 
        {
            "location": "/developer/signaling/architecture/#describing-signal-subscriptions-using-json", 
            "text": "JSON is a rich structured representation of data. For requested data, it allows the expression of multiple features and constraints.\nJSON is both very flexible and efficient.\nThere are significant advantages in describing requested data at subscription time using a language like JSON.\nAnother advantage of JSON is that no parser is required to analyse the request.  Here is an example of what could be a subscription specification:  {\n   define : {\n       speed : {\n            signal :  average-wheel-speed ,\n            unit :  km/h ,\n            accuracy : 0.5,\n            filtered :  yes \n       },\n    expect : {\n       value :  speed ,\n       when : {\n           cross : {  speed : [ 50, 90, 110, 130 ] }\n      },\n       max-rate : 1\n  }\n}  A generic library to handle such request definition should be provided.\nThis library should allow the agent to process the request, search if its business logic or any of present low level modules support requested signal. Finally it should notify the concerned lower module to optimise signal generation.  While such an approach might not be the most common approach, organisation like  Signal-K  already uses JSON to transmit NMEA-2000 signals on boats. Others might already used it as well and some further investigations on existing solutions would be needed before moving in such a direction.", 
            "title": "Describing Signal Subscriptions using JSON"
        }, 
        {
            "location": "/developer/signaling/architecture/#naming-signal", 
            "text": "Naming and defining signals is something very complex.\nFor example just  speed , as a signal, is difficult to define.\nWhat unit is used (km/h, M/h, m/s, ...)?\nFrom which source (wheels, GPS, AccelMeter)?\nHow was it captured (period of measure, instantaneous, mean, filtered)?  In order to simplify application development we should nevertheless agree on some naming convention for key signals.\nThose names might be relatively complex and featured. They may include a unit, a rate, a precision, etc.  How these names should be registered, documented and managed is out of scope of this document but\nextremely important and at some point in time should be addressed. Nevertheless this issue should not prevent\nfrom moving forward developing a modern architecture.\nDevelopers should be warned that naming is a complex\ntask, and that in the future naming scheme should be redefined, and potential adjustments would be required.", 
            "title": "Naming Signal"
        }, 
        {
            "location": "/developer/signaling/architecture/#leveraging-agl-binder", 
            "text": "Such a model is loosely coupled with AGL binder. Low level signal modules as well as virtual signal\ncomponents may potentially run within any hosting environment that would provide the right API with corresponding required facilities.\nNevertheless leveraging [[APbinder]] has multiple advantages. It already implements event notification to support\na messaging/signaling model for distributed agents. It enables a subscribe model responding to the requirement and finally it uses JSON\nnatively.  This messaging/signalling model already enforces the notion of subscription for receiving data.\nIt implies that unexpected data are not sent and merely not computed.\nWhen expected data is available, it is pushed to all waiting subscriber only one time.  The [[APbinder]] provides transparency of communication.\nIt currently implements the transparency over D-Bus/Kdbus and WebSocket.\nIts transparency mechanism of communication is easy to extend to other\ntechnologies: pools of shared memory or any proprietary transport model.  When modules are loaded by the same service agent, the [[APbinder]] provides transparently \"in-memory\" communication.\nThis in-memory communication is really efficient: on one hand, the exchanged\nJSON objects are not serialized (because not streamed), on the other hand,\nthose JSON objects provide a high level of abstraction able to transfer any\ndata.  Technically an agent is a standard [[APbinder]] service.\nTherefore Signal/Agent inherits of security protection through SMACK, access\ncontrol through Cynara, transparency of API to transport layer, life cycle\nmanagement, ... Like any other [[APbinder]] service Signal/Agent is composed of a set of bindings. In signal agent specific case, those bindings are in fact the \"signal modules\".  The proposed model allows to implement low level dependencies as independent signal modules.\nThose modules when developed are somehow like \"Lego Bricks\".\nThey can be spread or grouped within one or multiple agents depending on\ndeployment constraints (performance, multi-ECU, security   isolation constraints,\n...).  The model naturally uses JSON to represent data.  Multi-ECU and Vehicule to Cloud interactions:  while this might not be a\nshow stopper for current projects, it is obvious that in the near future\nSignal/Agent should support a fully distributed architectures.\nSome event may come from the cloud (i.e. request to start monitoring a given\nfeature), some may come from SmartCity and nearby vehicles, and last but\nnot least some may come from another ECU within the same vehicle or from a\nvirtualized OS within the same ECU (e.g. cluster   IVI). \nIn order to do so, Signal modules should enable composition within one or more\n[[APbinder]] inside the same ECU.\nFurthermore they should also support chaining with the outside world.    Application requests Virtual Signal exactly like if it was a low level\n   signal  Agent Signal has direct relation to low level signal  Agent needs to proxy to an other agent inside the same ECU to access the\n   signal  Signal is not present on current ECU. Request has to be proxied to the\n   outside world", 
            "title": "Leveraging AGL binder"
        }, 
        {
            "location": "/developer/signaling/architecture/#work-to-be-done", 
            "text": "As stated before, the foundation for event signaling is already in place in\ndevelopment branch of [[APbinder]].\nNevertheless in order to provide a real added value to developers missing\ncomponents should be developed.   Agent Core Components  Create a simple configuration model to move from low level signal\n  description to something more generic that could help to abstract the\n  hardware.  Search for an already existing library that provide high level signal\n  subscription and adapt it.\n  If no such library exist, create it.  Implement some form of introspection to allow application to discover\n  the list of signal supported by a given agent.    Few Common Agents  Provide at least a reference implementation for a generic CAN agent  Agent simulation, most developers may not have access to physical\n  devices during development phase, some form of simulator would be more\n  than welcome.  etc ...", 
            "title": "Work to be Done"
        }, 
        {
            "location": "/developer/signaling/architecture/#reusing-existinglegacy-code", 
            "text": "Whatever the final architecture will be, it is important not to forget how\nto leverage existing/legacy code within the new model.\nThere are multiple sources for reusable code that can be classified in two\nmain categories:    Low Level  Typically those existing code interface with CAN-BUS or any\n  other low level device.\n  Some AMBd[[6]] plugins could be a good source of input for low level\n  implementation.\n  But also more community oriented projects like: ArduPilot/Rover[[7]]\n  Barometer or Camera interfaces[[8]].    Virtual Signal  In many cases accessing to low level signal is not enough.\n  Low level information might need to be composed (i.e. GPS+Gyro+Accel).\n  Raw value might need to be processed (i.e.: change unit, average on the\n  last xx seconds, ...).\n  Writing this composition logic might be quite complex and reusing existing\n  libraries like: LibEkNav for Kalman filtering [[9]] or Vrgimbal for 3 axes\n  control[[10]] may help saving a lot of time.", 
            "title": "Reusing existing/legacy code"
        }, 
        {
            "location": "/developer/signaling/architecture/#proposal", 
            "text": "In order to start moving forward one option would be to take a concrete example\nwith some existing can devices (i.e. the one from MicroChips use within ALS demo).  An other option would be to leverage Porter+Cogent-Extension[[11]] that supports\nboth a GPS and a 9 axis sensor to implement a smart geoposition agent. \nWe could  reuse some existing code like the one from Rover[[7]] to provide a\nfine grain positioning service and then interface this new GeoPositioning\nagent with an application like GpsNavi[[12]] to get a end-to-end demonstrator.", 
            "title": "Proposal"
        }, 
        {
            "location": "/developer/signaling/", 
            "text": "===== AGL Message Signaling (proposal) =====\n\n\n==== Architecture Proposal ====\n\n\nThis \ndocument\n presents a proposal of architecture for message signaling in AGL.\n\n\nAlso available as a \nPDF Document\n\n\n==== Documentation ====\n\n\nDeveloper Guidelines are available as a \nPDF Document\n \n\n\nGPS Binding example is available on Github: \ngithub:iotbzh/af-gps-binding\n\n\n==== OpenXC Demo ====\n\n\nA reference HTML5 application has been developed: see \ngithub:iotbzh/txc-demo\n.\n\n\nThis application uses a \nOpenXC trace file\n to display 4 different panels representing live vehicle data.\n\n\nIt's available as an \nAGL Application paclage\n installable through AGL Application Framework.\n\n\n==== Benchmarks ====\n\n\nSome tests to evaluate the performances of the framework have been done by simulating CAN Data: \nAGL-AppFW-CAN-Signaling-Benchmark.pdf\n\n\n==== AMM Munich'16 Presentation ====\n\n\nJose's presentation at AGL AMM Munich'16", 
            "title": "Home"
        }, 
        {
            "location": "/user/getting-started/source-code/", 
            "text": "Download AGL Source Code\n\n\nThe AGL source code and Yocto layers are maintained on the AGL Gerrit server. For information on how to create accounts for gerrit see Getting Started with AGL.\n\n\nPrepare Repo Tool\n\n\nAGL Uses the Repo tool for managing repositories. First you need to setup layers of AGL. You can use the commands below to prepare Repo:\n\n\nmkdir ~/bin\nexport PATH=~/bin:$PATH\ncurl https://storage.googleapis.com/git-repo-downloads/repo \n ~/bin/repo\nchmod a+x ~/bin/repo\n\n\n\n\nDownload Latest Stable Release\n\n\nTo download all layers for the for the latest stable release, Blowfish 2.0.2:\n\n\nrepo init -b blowfish -m default_blowfish_2.0.2.xml -u https://gerrit.automotivelinux.org/gerrit/AGL/AGL-repo\nrepo sync\n\n\n\n\nDownload Latest on Blowfish Branch\n\n\nTo download all layers on the current release branch which may be in the midst of testing or changes prior to the next stable release:\n\n\nrepo init -b blowfish -u https://gerrit.automotivelinux.org/gerrit/AGL/AGL-repo\nrepo sync\n\n\n\n\nDownload Master Branch\n\n\nTo download all code from master:\n\n\nrepo init -u https://gerrit.automotivelinux.org/gerrit/AGL/AGL-repo\nrepo sync\n\n\n\n\nSet up Build Environment\n\n\nSet up the development environment for the desired target hardware. AGL has created a set up script for defining the target build and desired optional features. To get a complete list of the options available run.\n\n\n  $ source meta-agl/scripts/aglsetup.sh -h\n\n\n\n\nOnce you run aglsetup.sh with your desired paramaters, you can build any target desired.\n\n\nFeatures supported by aglsetup\n\n\nHere is the list of features for AGL 2.0 that can be specified in the aglsetup.sh command line:\n\n\n\n\nin \nmeta-agl\n\n\nagl-devel\n: activate development options (empty root password, debugger, strace, valgrind \u2026)\n\n\nagl-netboot\n: enable network boot support through TFTP and NBD (see meta-netboot layer)\n\n\n\n\n\n\nin \nmeta-agl-extra\n\n\nagl-appfw-smack\n: enables IoT.bzh Application Framework + SMACK + Cynara\n\n\nagl-demo\n: enable layer meta-agl-demo and meta-qt5 - required to build     * agl-demo-platform\n\n\nagl-localdev\n: add a local layer named \u201cmeta-localdev\u201d in meta directory and a local.dev.inc conf file if present\n\n\nagl-sota\n: enable SOTA components and dependencies (meta-sota, meta-filesystems, meta-ruby, meta-rust are added)\n\n\n\n\n\n\n\n\nFor newer features or to get more details on a given feature, take a look at the configuration files stored for each feature and/or each machine in meta-agl/templates and meta-agl-extra/templates.", 
            "title": "Source code"
        }, 
        {
            "location": "/user/getting-started/source-code/#download-agl-source-code", 
            "text": "The AGL source code and Yocto layers are maintained on the AGL Gerrit server. For information on how to create accounts for gerrit see Getting Started with AGL.", 
            "title": "Download AGL Source Code"
        }, 
        {
            "location": "/user/getting-started/source-code/#prepare-repo-tool", 
            "text": "AGL Uses the Repo tool for managing repositories. First you need to setup layers of AGL. You can use the commands below to prepare Repo:  mkdir ~/bin\nexport PATH=~/bin:$PATH\ncurl https://storage.googleapis.com/git-repo-downloads/repo   ~/bin/repo\nchmod a+x ~/bin/repo", 
            "title": "Prepare Repo Tool"
        }, 
        {
            "location": "/user/getting-started/source-code/#download-latest-stable-release", 
            "text": "To download all layers for the for the latest stable release, Blowfish 2.0.2:  repo init -b blowfish -m default_blowfish_2.0.2.xml -u https://gerrit.automotivelinux.org/gerrit/AGL/AGL-repo\nrepo sync", 
            "title": "Download Latest Stable Release"
        }, 
        {
            "location": "/user/getting-started/source-code/#download-latest-on-blowfish-branch", 
            "text": "To download all layers on the current release branch which may be in the midst of testing or changes prior to the next stable release:  repo init -b blowfish -u https://gerrit.automotivelinux.org/gerrit/AGL/AGL-repo\nrepo sync", 
            "title": "Download Latest on Blowfish Branch"
        }, 
        {
            "location": "/user/getting-started/source-code/#download-master-branch", 
            "text": "To download all code from master:  repo init -u https://gerrit.automotivelinux.org/gerrit/AGL/AGL-repo\nrepo sync", 
            "title": "Download Master Branch"
        }, 
        {
            "location": "/user/getting-started/source-code/#set-up-build-environment", 
            "text": "Set up the development environment for the desired target hardware. AGL has created a set up script for defining the target build and desired optional features. To get a complete list of the options available run.    $ source meta-agl/scripts/aglsetup.sh -h  Once you run aglsetup.sh with your desired paramaters, you can build any target desired.", 
            "title": "Set up Build Environment"
        }, 
        {
            "location": "/user/getting-started/source-code/#features-supported-by-aglsetup", 
            "text": "Here is the list of features for AGL 2.0 that can be specified in the aglsetup.sh command line:   in  meta-agl  agl-devel : activate development options (empty root password, debugger, strace, valgrind \u2026)  agl-netboot : enable network boot support through TFTP and NBD (see meta-netboot layer)    in  meta-agl-extra  agl-appfw-smack : enables IoT.bzh Application Framework + SMACK + Cynara  agl-demo : enable layer meta-agl-demo and meta-qt5 - required to build     * agl-demo-platform  agl-localdev : add a local layer named \u201cmeta-localdev\u201d in meta directory and a local.dev.inc conf file if present  agl-sota : enable SOTA components and dependencies (meta-sota, meta-filesystems, meta-ruby, meta-rust are added)     For newer features or to get more details on a given feature, take a look at the configuration files stored for each feature and/or each machine in meta-agl/templates and meta-agl-extra/templates.", 
            "title": "Features supported by aglsetup"
        }, 
        {
            "location": "/user/getting-started/troubleshooting/", 
            "text": "Troubleshooting\n\n\nDue to a known bug in the upstream of meta-rust the Yocto/OE recipe for rust-cross may fail while building RVI SOTA Client or another application written in the Rust programming language. Until the complete resolution of the issue the workaround is to disable all use of the CXX11 ABI by applying the following lines to \nconf/local.conf\n:\n\n\nLD_CXXFLAGS_append = \n -D_GLIBCXX_USE_CXX11_ABI=0\n\nTARGET_CXXFLAGS_append = \n -D_GLIBCXX_USE_CXX11_ABI=0\n\nCXXFLAGS_append = \n -D_GLIBCXX_USE_CXX11_ABI=0\n\n\nBUILD_CXXFLAGS_remove_pn-gcc-runtime = \n-D_GLIBCXX_USE_CXX11_ABI=0\n\nTARGET_CXXFLAGS_remove_pn-gcc-runtime = \n-D_GLIBCXX_USE_CXX11_ABI=0\n CXXFLAGS_remove_pn-gcc-runtime = \n-D_GLIBCXX_USE_CXX11_ABI=0", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/user/getting-started/troubleshooting/#troubleshooting", 
            "text": "Due to a known bug in the upstream of meta-rust the Yocto/OE recipe for rust-cross may fail while building RVI SOTA Client or another application written in the Rust programming language. Until the complete resolution of the issue the workaround is to disable all use of the CXX11 ABI by applying the following lines to  conf/local.conf :  LD_CXXFLAGS_append =   -D_GLIBCXX_USE_CXX11_ABI=0 \nTARGET_CXXFLAGS_append =   -D_GLIBCXX_USE_CXX11_ABI=0 \nCXXFLAGS_append =   -D_GLIBCXX_USE_CXX11_ABI=0 \n\nBUILD_CXXFLAGS_remove_pn-gcc-runtime =  -D_GLIBCXX_USE_CXX11_ABI=0 \nTARGET_CXXFLAGS_remove_pn-gcc-runtime =  -D_GLIBCXX_USE_CXX11_ABI=0  CXXFLAGS_remove_pn-gcc-runtime =  -D_GLIBCXX_USE_CXX11_ABI=0", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/user/getting-started/footers/porter-footer/", 
            "text": "Weston\n\n\nIf Weston fails to start double check /etc/xdg/weston/weston.ini and verify that the output name and screen resolution matches the configured U-Boot environment, for example on Renesas Porter board rev 1.0 with screen resolution 1024x768:\n\n\n[core]\nshell=desktop-shell.so\nbackend=drm-backend.so\n\n[shell]\nlocking=true\n# Uncomment below to hide panel\n#panel-location=none\n\n[output]\n#name=Virtual-1\nname=HDMI-A-1\nmode=1024x768", 
            "title": "Porter footer"
        }, 
        {
            "location": "/user/getting-started/footers/porter-footer/#weston", 
            "text": "If Weston fails to start double check /etc/xdg/weston/weston.ini and verify that the output name and screen resolution matches the configured U-Boot environment, for example on Renesas Porter board rev 1.0 with screen resolution 1024x768:  [core]\nshell=desktop-shell.so\nbackend=drm-backend.so\n\n[shell]\nlocking=true\n# Uncomment below to hide panel\n#panel-location=none\n\n[output]\n#name=Virtual-1\nname=HDMI-A-1\nmode=1024x768", 
            "title": "Weston"
        }, 
        {
            "location": "/user/getting-started/footers/raspberrypi-footer/", 
            "text": "Commercial Licensed Packages\n\n\nAppend to following lines to \nconf/local.conf\n to include libomxil under a commercial license to your build:\n\n\n# For libomxil\nLICENSE_FLAGS_WHITELIST = \ncommercial\n\n\nIMAGE_INSTALL_append = \n libomxil\n\n\n\n\n\nRaspberry Pi Touchscreen with Rotation\n\n\nIf you have Raspberry Pi official 7\" touchscreen connected, you can rotate it with these lines in /etc/xdg/weston/weston.ini\n\n\nroot@raspberrypi3:/etc/xdg/weston# cat weston.ini\n[core]\nbackend=drm-backend.so\nshell=desktop-shell.so\n\n[shell]\nlocking=true\n# Uncomment below to hide panel\n#panel-location=none\n\n[launcher]\nicon=/usr/share/weston/terminal.png\npath=/usr/bin/weston-terminal\n\n[launcher]\nicon=/usr/share/weston/icon_flower.png\npath=/usr/bin/weston-flower\n\n[output]\nname=DSI-1\ntransform=270\n\n\n\n\nDebugging\n\n\nIt is possible to debug AGL images on Raspberry Pi using 3.3V USB to serial cable, such as \nOlimex USB-Serial-Cable-F\n, connected to the UART of the board. Follow the instructions below to connect a cable to the board (do it on your own risk, no warranty is provided):\n\n\n\n\nConnect the BLUE wire if you are using Olimex USB-Serial-Cable-F to pin 6 of Raspberry Pi,\n\n\nConnect the RX line of the cable (GREEN wire if you are using Olimex USB-Serial-Cable-F) to pin 8 (TX line) of Raspberry Pi,\n\n\nConnect the TX line of the cable (RED wire if you are using Olimex USB-Serial-Cable-F) to pin 10 (RX line) of Raspberry Pi.\n\n\n\n\n\n\n\n\nPlug the USB connector of the cable to your computer and use your favorite tool for serial communication, for example on Ubuntu and other Linux distributions you may use screen:\n\n\n\n\nsudo screen /dev/ttyUSB0 115200\n\n\n\n\nPay attention that the colours of the cable may vary depending on the vendor. If you have USB console cable from Adafruit please have a look \nhere\n.", 
            "title": "Raspberrypi footer"
        }, 
        {
            "location": "/user/getting-started/footers/raspberrypi-footer/#commercial-licensed-packages", 
            "text": "Append to following lines to  conf/local.conf  to include libomxil under a commercial license to your build:  # For libomxil\nLICENSE_FLAGS_WHITELIST =  commercial \n\nIMAGE_INSTALL_append =   libomxil", 
            "title": "Commercial Licensed Packages"
        }, 
        {
            "location": "/user/getting-started/footers/raspberrypi-footer/#raspberry-pi-touchscreen-with-rotation", 
            "text": "If you have Raspberry Pi official 7\" touchscreen connected, you can rotate it with these lines in /etc/xdg/weston/weston.ini  root@raspberrypi3:/etc/xdg/weston# cat weston.ini\n[core]\nbackend=drm-backend.so\nshell=desktop-shell.so\n\n[shell]\nlocking=true\n# Uncomment below to hide panel\n#panel-location=none\n\n[launcher]\nicon=/usr/share/weston/terminal.png\npath=/usr/bin/weston-terminal\n\n[launcher]\nicon=/usr/share/weston/icon_flower.png\npath=/usr/bin/weston-flower\n\n[output]\nname=DSI-1\ntransform=270", 
            "title": "Raspberry Pi Touchscreen with Rotation"
        }, 
        {
            "location": "/user/getting-started/footers/raspberrypi-footer/#debugging", 
            "text": "It is possible to debug AGL images on Raspberry Pi using 3.3V USB to serial cable, such as  Olimex USB-Serial-Cable-F , connected to the UART of the board. Follow the instructions below to connect a cable to the board (do it on your own risk, no warranty is provided):   Connect the BLUE wire if you are using Olimex USB-Serial-Cable-F to pin 6 of Raspberry Pi,  Connect the RX line of the cable (GREEN wire if you are using Olimex USB-Serial-Cable-F) to pin 8 (TX line) of Raspberry Pi,  Connect the TX line of the cable (RED wire if you are using Olimex USB-Serial-Cable-F) to pin 10 (RX line) of Raspberry Pi.     Plug the USB connector of the cable to your computer and use your favorite tool for serial communication, for example on Ubuntu and other Linux distributions you may use screen:   sudo screen /dev/ttyUSB0 115200  Pay attention that the colours of the cable may vary depending on the vendor. If you have USB console cable from Adafruit please have a look  here .", 
            "title": "Debugging"
        }, 
        {
            "location": "/user/getting-started/machines/porter/", 
            "text": "Building the AGL Demo Platform for Renesas Porter\n\n\n\n\n\n\nDownload Renesas \ngraphics drivers with a \"click through\" license from Renesas website\n in directory ~/Downloads (or $XDG_DOWNLOAD_DIR).\n\n\n\n\n\n\nTo build AGL demo platform for Renesas Porter board use machine \nporter\n and feature \nagl-demo\n:\n\n\n\n\n\n\nsource meta-agl/scripts/aglsetup.sh -m porter agl-demo agl-netboot agl-appfw-smack\nbitbake agl-demo-platform\n\n\n\n\nBooting AGL Demo Platform on Renesas Porter\n\n\nDeployment\n\n\nOn the host\n\n\n\n\nPlug microSD card and get its associated device by either running \ndmesg | tail -15\n or \nlsblk\n, for example:\n\n\n\n\ndmesg | tail -15\n[ 1971.462160] sd 6:0:0:0: [sdc] Mode Sense: 03 00 00 00\n[ 1971.462277] sd 6:0:0:0: [sdc] No Caching mode page found\n[ 1971.462278] sd 6:0:0:0: [sdc] Assuming drive cache: write through\n[ 1971.463870]  sdc: sdc1 sdc2\n\n\n\n\nlsblk\nNAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\nsda      8:0    0 167,7G  0 disk \n\u251c\u2500sda1   8:1    0   512M  0 part /boot/efi\n\u251c\u2500sda2   8:2    0 159,3G  0 part /\n\u2514\u2500sda3   8:3    0   7,9G  0 part [SWAP]\nsdb      8:16   0 931,5G  0 disk \n\u2514\u2500sdb1   8:17   0 931,5G  0 part /media/storage\nsdc      8:32   1  14,9G  0 disk \n\u251c\u2500sdc1   8:33   1    40M  0 part \n\u2514\u2500sdc2   8:34   1   788M  0 part \n\n\n\n\nNote: In the \nexamples\n above, 'sdc' corresponds to the microSD card.\n\n\n\n\nCreate EXT3 partition on the SD-card using fdisk or another application. For \nexample\n, if the microSD card is \n/dev/sdc\n:\n\n\n\n\nsudo fdisk /dev/sdc\n\nWelcome to fdisk (util-linux 2.27.1).\nChanges will remain in memory only, until you decide to write them.\nBe careful before using the write command.\n\n\nCommand (m for help): o\nCreated a new DOS disklabel with disk identifier 0x96e5850d.\n\nCommand (m for help): n\nPartition type\n   p   primary (0 primary, 0 extended, 4 free)\n   e   extended (container for logical partitions)\nSelect (default p): \n\nUsing default response p.\nPartition number (1-4, default 1): \nFirst sector (2048-31291391, default 2048): \nLast sector, +sectors or +size{K,M,G,T,P} (2048-31291391, default 31291391): \n\nCreated a new partition 1 of type 'Linux' and of size 14,9 GiB.\n\nCommand (m for help): w\nThe partition table has been altered.\nCalling ioctl() to re-read partition table.\nSyncing disks.\n\n\n\n\n\n\nInitialize the ext3 partition using \u201cmke2fs\u201d, for \nexample\n if the microSD card is associated with \nsdc\n:\n\n\n\n\nsudo mke2fs -t ext3 /dev/sdc1\nmke2fs 1.42.13 (17-May-2015)\nCreating filesystem with 3911168 4k blocks and 979200 inodes\nFilesystem UUID: 690804b9-6c7d-4bbb-b1c1-e9357efabc52\nSuperblock backups stored on blocks: \n    32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208\n\nAllocating group tables: done                            \nWriting inode tables: done                            \nCreating journal (32768 blocks): done\nWriting superblocks and filesystem accounting information: done \n\n\n\n\n\n\nMount the microSD card partition, for example \nexample\n if the microSD card is associated with \nsdc\n:\n\n\n\n\nmkdir /tmp/agl\nsudo mount /dev/sdc1 /tmp/agl/\n\n\n\n\nNote: Please replace /dev/sdc with the actual path for your microSD card.\n\n\n\n\nGo to your build directory:\n\n\n\n\ncd $BUILDDIR/tmp/deploy/images/porter\n\n\n\n\n\n\nMake sure the filesystem is empty:\n\n\n\n\nsudo rm -rf /tmp/agl/*\n\n\n\n\n\n\nVerify that \ntar\n version is 1.28 or newer:\n\n\n\n\ntar --version\ntar (GNU tar) 1.28\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later \nhttp://gnu.org/licenses/gpl.html\n.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nWritten by John Gilmore and Jay Fenlason.\n\n\n\n\n\n\nCopy Automotive Grade Linux (AGL) files onto the mircoSD card by extracting the root file system archive:\n\n\n\n\nsudo tar --extract --numeric-owner --preserve-permissions --preserve-order --totals \\\n           --directory=/tmp/agl --file=agl-demo-platform-porter.tar.bz2\n\n\n\n\n\n\nCopy Kernel Image and Device Tree Blob file into the \nboot\n directory:\n\n\n\n\nsudo cp uImage+dtb /tmp/agl/boot/\n\n\n\n\n\n\nEnsure the changes have been written to the disk:\n\n\n\n\nsync\n\n\n\n\n\n\nUnmount the micrSD card:\n\n\n\n\nsudo umount /tmp/agl\n\n\n\n\n\n\nPlug the microSD card in Renesas Porter board.\n\n\n\n\nTo access the shell (serial)\n\n\n\n\nWith the Porter board powered off, connect the 'Debug Serial 0' port on the board (for Porter mini-USB port close to on/off switch) with the host PC using the USB cable.\n\n\nUse \nscreen\n to access the serial debug console (may needs to \napt-get install screen\n):\n\n\n\n\nsudo screen /dev/ttyUSB0 38400\n\n\n\n\nNote: Alternatively, start a terminal emulator, such as 'minicom' or 'picocom', on the host, connecting to the USB serial port (/dev/ttyUSB0) with 38400, 8n1 settings.\n\n\n\n\nPower on the Porter board to see a shell on the console\n\n\n\n\nOn the target board\n\n\nIt is assumed that the Renesas Porter board already has u-boot running as second stage boot loader.\n\n\nU-Boot configurations\n\n\nFollow the steps below to configure boot from microSD card and to set screen resolution:\n\n\n\n\nPower up the board and, using your preferred terminal emulator, stop the board's autoboot and type \nprint\n to check the environment:\n\n\n\n\nprint\n\n\n\n\n\n\nVerify that the ethaddr environment variable is set to the same MAC address value shown on the label on top of the RJ45 Ethernet connector. If not please set it using the following command:\n\n\n\n\nsetenv ethaddr \nMAC address\n\n\n\n\n\nFor example:\n\n\nsetenv ethaddr 2e:09:0a:00:75:b5\n\n\n\n\n\n\nSet the follow environment variables:\n\n\n\n\nsetenv bootargs_console 'console=ttySC6,38400 ignore_loglevel'\nsetenv bootargs_video 'vmalloc=384M video=HDMI-A-1:1920x1080-32@60'\nsetenv bootargs_root 'root=/dev/mmcblk0p1 rootdelay=3 rw rootfstype=ext3 rootwait'\nsetenv bootmmc '1:1'\nsetenv bootcmd_sd 'ext4load mmc ${bootmmc} 0x40007fc0 boot/uImage+dtb'\nsetenv bootcmd 'setenv bootargs ${bootargs_console} ${bootargs_video} ${bootargs_root}; run bootcmd_sd; bootm 0x40007fc0'\n\n\n\n\nWARNINGS:\n\n\nIf no display shows up when booting, e.g. for a non-full HD screen, replace  \n1920x1080\n value in the \nbootargs_video\n variable with lower screen resolution such as \n1024x768\n. Unfortunately for the moment there are no universally supported setting.\n\n\nDepending on your board (Porter rev B or rev C, Koelsch etc.), the SD card slots may differ. Try setting \nbootmmc\n to \n0:1\n or \n2:1\n depending on the slot and card format.\n\n\nFor Renesas Porter Rev 1.0 use screen resolution \n1024x768\n and set \nbootmmc\n to \n2:1\n.\n\n\n\n\nSave the environment variables:\n\n\n\n\nsaveenv\n\n\n\n\n\n\nReboot:\n\n\n\n\nreset", 
            "title": "Porter"
        }, 
        {
            "location": "/user/getting-started/machines/porter/#building-the-agl-demo-platform-for-renesas-porter", 
            "text": "Download Renesas  graphics drivers with a \"click through\" license from Renesas website  in directory ~/Downloads (or $XDG_DOWNLOAD_DIR).    To build AGL demo platform for Renesas Porter board use machine  porter  and feature  agl-demo :    source meta-agl/scripts/aglsetup.sh -m porter agl-demo agl-netboot agl-appfw-smack\nbitbake agl-demo-platform", 
            "title": "Building the AGL Demo Platform for Renesas Porter"
        }, 
        {
            "location": "/user/getting-started/machines/porter/#booting-agl-demo-platform-on-renesas-porter", 
            "text": "", 
            "title": "Booting AGL Demo Platform on Renesas Porter"
        }, 
        {
            "location": "/user/getting-started/machines/porter/#deployment", 
            "text": "", 
            "title": "Deployment"
        }, 
        {
            "location": "/user/getting-started/machines/porter/#on-the-host", 
            "text": "Plug microSD card and get its associated device by either running  dmesg | tail -15  or  lsblk , for example:   dmesg | tail -15\n[ 1971.462160] sd 6:0:0:0: [sdc] Mode Sense: 03 00 00 00\n[ 1971.462277] sd 6:0:0:0: [sdc] No Caching mode page found\n[ 1971.462278] sd 6:0:0:0: [sdc] Assuming drive cache: write through\n[ 1971.463870]  sdc: sdc1 sdc2  lsblk\nNAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\nsda      8:0    0 167,7G  0 disk \n\u251c\u2500sda1   8:1    0   512M  0 part /boot/efi\n\u251c\u2500sda2   8:2    0 159,3G  0 part /\n\u2514\u2500sda3   8:3    0   7,9G  0 part [SWAP]\nsdb      8:16   0 931,5G  0 disk \n\u2514\u2500sdb1   8:17   0 931,5G  0 part /media/storage\nsdc      8:32   1  14,9G  0 disk \n\u251c\u2500sdc1   8:33   1    40M  0 part \n\u2514\u2500sdc2   8:34   1   788M  0 part   Note: In the  examples  above, 'sdc' corresponds to the microSD card.   Create EXT3 partition on the SD-card using fdisk or another application. For  example , if the microSD card is  /dev/sdc :   sudo fdisk /dev/sdc\n\nWelcome to fdisk (util-linux 2.27.1).\nChanges will remain in memory only, until you decide to write them.\nBe careful before using the write command.\n\n\nCommand (m for help): o\nCreated a new DOS disklabel with disk identifier 0x96e5850d.\n\nCommand (m for help): n\nPartition type\n   p   primary (0 primary, 0 extended, 4 free)\n   e   extended (container for logical partitions)\nSelect (default p): \n\nUsing default response p.\nPartition number (1-4, default 1): \nFirst sector (2048-31291391, default 2048): \nLast sector, +sectors or +size{K,M,G,T,P} (2048-31291391, default 31291391): \n\nCreated a new partition 1 of type 'Linux' and of size 14,9 GiB.\n\nCommand (m for help): w\nThe partition table has been altered.\nCalling ioctl() to re-read partition table.\nSyncing disks.   Initialize the ext3 partition using \u201cmke2fs\u201d, for  example  if the microSD card is associated with  sdc :   sudo mke2fs -t ext3 /dev/sdc1\nmke2fs 1.42.13 (17-May-2015)\nCreating filesystem with 3911168 4k blocks and 979200 inodes\nFilesystem UUID: 690804b9-6c7d-4bbb-b1c1-e9357efabc52\nSuperblock backups stored on blocks: \n    32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208\n\nAllocating group tables: done                            \nWriting inode tables: done                            \nCreating journal (32768 blocks): done\nWriting superblocks and filesystem accounting information: done    Mount the microSD card partition, for example  example  if the microSD card is associated with  sdc :   mkdir /tmp/agl\nsudo mount /dev/sdc1 /tmp/agl/  Note: Please replace /dev/sdc with the actual path for your microSD card.   Go to your build directory:   cd $BUILDDIR/tmp/deploy/images/porter   Make sure the filesystem is empty:   sudo rm -rf /tmp/agl/*   Verify that  tar  version is 1.28 or newer:   tar --version\ntar (GNU tar) 1.28\nCopyright (C) 2014 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later  http://gnu.org/licenses/gpl.html .\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nWritten by John Gilmore and Jay Fenlason.   Copy Automotive Grade Linux (AGL) files onto the mircoSD card by extracting the root file system archive:   sudo tar --extract --numeric-owner --preserve-permissions --preserve-order --totals \\\n           --directory=/tmp/agl --file=agl-demo-platform-porter.tar.bz2   Copy Kernel Image and Device Tree Blob file into the  boot  directory:   sudo cp uImage+dtb /tmp/agl/boot/   Ensure the changes have been written to the disk:   sync   Unmount the micrSD card:   sudo umount /tmp/agl   Plug the microSD card in Renesas Porter board.", 
            "title": "On the host"
        }, 
        {
            "location": "/user/getting-started/machines/porter/#to-access-the-shell-serial", 
            "text": "With the Porter board powered off, connect the 'Debug Serial 0' port on the board (for Porter mini-USB port close to on/off switch) with the host PC using the USB cable.  Use  screen  to access the serial debug console (may needs to  apt-get install screen ):   sudo screen /dev/ttyUSB0 38400  Note: Alternatively, start a terminal emulator, such as 'minicom' or 'picocom', on the host, connecting to the USB serial port (/dev/ttyUSB0) with 38400, 8n1 settings.   Power on the Porter board to see a shell on the console", 
            "title": "To access the shell (serial)"
        }, 
        {
            "location": "/user/getting-started/machines/porter/#on-the-target-board", 
            "text": "It is assumed that the Renesas Porter board already has u-boot running as second stage boot loader.", 
            "title": "On the target board"
        }, 
        {
            "location": "/user/getting-started/machines/porter/#u-boot-configurations", 
            "text": "Follow the steps below to configure boot from microSD card and to set screen resolution:   Power up the board and, using your preferred terminal emulator, stop the board's autoboot and type  print  to check the environment:   print   Verify that the ethaddr environment variable is set to the same MAC address value shown on the label on top of the RJ45 Ethernet connector. If not please set it using the following command:   setenv ethaddr  MAC address   For example:  setenv ethaddr 2e:09:0a:00:75:b5   Set the follow environment variables:   setenv bootargs_console 'console=ttySC6,38400 ignore_loglevel'\nsetenv bootargs_video 'vmalloc=384M video=HDMI-A-1:1920x1080-32@60'\nsetenv bootargs_root 'root=/dev/mmcblk0p1 rootdelay=3 rw rootfstype=ext3 rootwait'\nsetenv bootmmc '1:1'\nsetenv bootcmd_sd 'ext4load mmc ${bootmmc} 0x40007fc0 boot/uImage+dtb'\nsetenv bootcmd 'setenv bootargs ${bootargs_console} ${bootargs_video} ${bootargs_root}; run bootcmd_sd; bootm 0x40007fc0'  WARNINGS:  If no display shows up when booting, e.g. for a non-full HD screen, replace   1920x1080  value in the  bootargs_video  variable with lower screen resolution such as  1024x768 . Unfortunately for the moment there are no universally supported setting.  Depending on your board (Porter rev B or rev C, Koelsch etc.), the SD card slots may differ. Try setting  bootmmc  to  0:1  or  2:1  depending on the slot and card format.  For Renesas Porter Rev 1.0 use screen resolution  1024x768  and set  bootmmc  to  2:1 .   Save the environment variables:   saveenv   Reboot:   reset", 
            "title": "U-Boot configurations"
        }, 
        {
            "location": "/user/getting-started/machines/qemu/", 
            "text": "Building the AGL Demo Platform for QEMU\n\n\nTo build the QEMU version of the AGL demo platform use machine \nqemux86-64\n and feature \nagl-demo\n:\n\n\nsource meta-agl/scripts/aglsetup.sh -m qemux86-64 agl-demo agl-netboot agl-appfw-smack\nbitbake agl-demo-platform", 
            "title": "Qemu"
        }, 
        {
            "location": "/user/getting-started/machines/qemu/#building-the-agl-demo-platform-for-qemu", 
            "text": "To build the QEMU version of the AGL demo platform use machine  qemux86-64  and feature  agl-demo :  source meta-agl/scripts/aglsetup.sh -m qemux86-64 agl-demo agl-netboot agl-appfw-smack\nbitbake agl-demo-platform", 
            "title": "Building the AGL Demo Platform for QEMU"
        }, 
        {
            "location": "/user/getting-started/machines/raspberrypi/", 
            "text": "Building the AGL Demo Platform for Raspberry Pi\n\n\nRaspberry Pi 3\n\n\nTo build AGL demo platform for Raspberry Pi 3 use machine \nraspberrypi3\n and feature \nagl-demo\n:\n\n\nsource meta-agl/scripts/aglsetup.sh -m raspberrypi3 agl-demo agl-netboot agl-appfw-smack\nbitbake agl-demo-platform\n\n\n\n\nRaspberry Pi 2\n\n\nTo build AGL demo platform for Raspberry Pi 2 use machine \nraspberrypi2\n and feature \nagl-demo\n:\n\n\nsource meta-agl/scripts/aglsetup.sh -m raspberrypi2 agl-demo agl-netboot agl-appfw-smack\nbitbake agl-demo-platform\n\n\n\n\nBooting AGL Demo Platform on Raspberry Pi\n\n\nFollow the steps below to copy the image to microSD card and to boot it on Raspberry Pi 2 or 3:\n\n\n\n\nConnect your sdcard in your linux machine.\n\n\nCopy output image from build machine to linux machine that is connected your sdcard. (Often, those are same machines)\n\n\nOutput Image location in build machine for Raspberry Pi 2: \ntmp/deploy/images/raspberrypi2/agl-demo-platform-raspberrypi2.rpi-sdimg\n\n\nOutput Image location in build machine for Raspberry Pi 3: \ntmp/deploy/images/raspberrypi3/agl-demo-platform-raspberrypi3.rpi-sdimg\n\n\nUnmount the microSD card and after that flash output image to it card with root user:\n\n\n\n\nsudo umount [sdcard device]\nsudo dd if=[output image] of=[sdcard device] bs=4M\nsync\n\n\n\n\n\n\nPlug your microSD card into Raspberry Pi 2 or 3 and boot the board", 
            "title": "Raspberrypi"
        }, 
        {
            "location": "/user/getting-started/machines/raspberrypi/#building-the-agl-demo-platform-for-raspberry-pi", 
            "text": "", 
            "title": "Building the AGL Demo Platform for Raspberry Pi"
        }, 
        {
            "location": "/user/getting-started/machines/raspberrypi/#raspberry-pi-3", 
            "text": "To build AGL demo platform for Raspberry Pi 3 use machine  raspberrypi3  and feature  agl-demo :  source meta-agl/scripts/aglsetup.sh -m raspberrypi3 agl-demo agl-netboot agl-appfw-smack\nbitbake agl-demo-platform", 
            "title": "Raspberry Pi 3"
        }, 
        {
            "location": "/user/getting-started/machines/raspberrypi/#raspberry-pi-2", 
            "text": "To build AGL demo platform for Raspberry Pi 2 use machine  raspberrypi2  and feature  agl-demo :  source meta-agl/scripts/aglsetup.sh -m raspberrypi2 agl-demo agl-netboot agl-appfw-smack\nbitbake agl-demo-platform", 
            "title": "Raspberry Pi 2"
        }, 
        {
            "location": "/user/getting-started/machines/raspberrypi/#booting-agl-demo-platform-on-raspberry-pi", 
            "text": "Follow the steps below to copy the image to microSD card and to boot it on Raspberry Pi 2 or 3:   Connect your sdcard in your linux machine.  Copy output image from build machine to linux machine that is connected your sdcard. (Often, those are same machines)  Output Image location in build machine for Raspberry Pi 2:  tmp/deploy/images/raspberrypi2/agl-demo-platform-raspberrypi2.rpi-sdimg  Output Image location in build machine for Raspberry Pi 3:  tmp/deploy/images/raspberrypi3/agl-demo-platform-raspberrypi3.rpi-sdimg  Unmount the microSD card and after that flash output image to it card with root user:   sudo umount [sdcard device]\nsudo dd if=[output image] of=[sdcard device] bs=4M\nsync   Plug your microSD card into Raspberry Pi 2 or 3 and boot the board", 
            "title": "Booting AGL Demo Platform on Raspberry Pi"
        }
    ]
}